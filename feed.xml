<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xiaOp的博客</title>
    <description>分享写代码，听音乐，看电影的心得
</description>
    <link>https://xiaoiver.github.io/</link>
    <atom:link href="https://xiaoiver.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 16 Nov 2017 23:34:23 +0800</pubDate>
    <lastBuildDate>Thu, 16 Nov 2017 23:34:23 +0800</lastBuildDate>
    <generator>Jekyll v3.4.5</generator>
    
      <item>
        <title>SSR 中的离线可用（三）</title>
        <description>&lt;p&gt;本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本文是第三部分，将使用 Vue SSR 和 Workbox 实践这一思路。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html&quot;&gt;第一部分&lt;/a&gt;以 PWA-Directory 为例进行分析。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/coding/2017/10/28/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%BA%8C.html&quot;&gt;第二部分&lt;/a&gt;研究了一个 WordPress 主题项目。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;思路回顾&quot;&gt;思路回顾&lt;/h3&gt;

&lt;p&gt;我们之前提供了一种 SSR 架构下通用的离线缓存思路：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;改造后端模板以支持返回完整页面和内容片段&lt;/li&gt;
  &lt;li&gt;服务端增加一条针对 App Shell 的路由规则，返回仅包含 App Shell 的 HTML 页面&lt;/li&gt;
  &lt;li&gt;预缓存 App Shell 页面&lt;/li&gt;
  &lt;li&gt;Service Worker 拦截所有 HTML 请求，统一返回缓存的 App Shell 页面。同时向服务端请求当前页面需要的内容片段并写入缓存&lt;/li&gt;
  &lt;li&gt;前端路由向服务端请求内容片段，发现缓存中已存在，将其填充进 App Shell 中，完成前端渲染&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将这一思路应用到 Vue SSR 项目中时，需要做一些改变。&lt;/p&gt;

&lt;p&gt;首先在 Vue 同构项目中，同一套代码在 Node 端和浏览器端都能运行，是没有“后端模板”的概念的，同样对于“内容片段”也是如此。在首屏使用服务端渲染直出 HTML 后，浏览器端进行 Hydrate，绑定事件使页面真正可响应，除非刷新页面，否则后续的路由切换都将由前端路由器完成。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/vue-ssr.png&quot; alt=&quot;Vue SSR&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/vue-ssr.png&quot; data-alt=&quot;Vue SSR&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;Vue SSR&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

</description>
        <pubDate>Mon, 13 Nov 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/11/12/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%89.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/11/12/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%89.html</guid>
        
        <category>PWA</category>
        
        <category>ServiceWorker</category>
        
        <category>vue</category>
        
        <category>workbox</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>在 Jekyll 中使用离线缓存</title>
        <description>&lt;p&gt;Jekyll 默认生成的站点由多个静态页面组成（虽然可以通过某些插件实现 SPA）。不同于之前介绍的 SSR，对于这类静态站点的缓存思路并不复杂，几乎不需要对已有站点结构进行任何改造：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;预缓存静态资源和部分关键页面，例如主页和最新的文章&lt;/li&gt;
  &lt;li&gt;对于非关键页面，进行访问后的动态缓存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上思路需要在 Service Worker 中实现预缓存和动态缓存机制，使用 Workbox 将让一切变得简单。&lt;/p&gt;

&lt;h3 id=&quot;workbox-是什么&quot;&gt;Workbox 是什么？&lt;/h3&gt;

&lt;p&gt;Workbox 吸收了之前包括 sw-precache 和 sw-toolbox 在内的类库，也就是预缓存和动态缓存的实现。提供了一系列工具帮助开发者快速生成 Service Worker。根据项目的构建流程，可以选择对应的 Webpack 或者 Gulp 插件，如果没有使用这类构建工具，也可以选择使用 Workbox-CLI 命令行工具。对于想自己编写 SW 的开发者，也可以直接调用封装好的 API，包括预缓存的方案细节，根据资源类型选择不同的策略。总之 Workbox 能极大减少开发 SW 的成本。&lt;/p&gt;

&lt;p&gt;可以观看开发者在&lt;a href=&quot;https://www.youtube.com/watch?v=DtuJ55tmjps&quot;&gt;Google Dev Summit 上的介绍&lt;/a&gt;或者前往官网了解更多技术细节。&lt;/p&gt;

&lt;p&gt;值得一提的是 Workbox 拆分成了多个功能模块，例如预缓存、动态缓存、策略、缓存更新插件等。由于项目仍处于开发阶段，部分文档还不是很全面，有些配置需要深入代码才能搞懂。我在使用时对其中的更新插件产生了理解上的偏差，通过&lt;a href=&quot;https://github.com/GoogleChrome/workbox/issues/1001&quot;&gt;ISSUE&lt;/a&gt;得到作者的回应才搞清楚。在看代码的过程中，我深刻感受到 Google 开发者对于问题考虑的全面性，就拿跨域资源的动态缓存来说，&lt;/p&gt;

&lt;h3 id=&quot;插件细节&quot;&gt;插件细节&lt;/h3&gt;

&lt;p&gt;我的博客使用了 Gulp 作为构建工具，按理说使用 Workbox 提供的插件足矣。但是考虑到不是所有使用者都会使用基于 Node.js 的构建工具，而且类似“缓存最近5篇文章”这样的需求是和 Jekyll 本身构建流程密切相关的，所以集成到默认的构建流程中是很有必要的。&lt;/p&gt;

&lt;p&gt;之前在&lt;a href=&quot;/coding/2017/08/10/%E5%9C%A8jekyll%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.html&quot;&gt;在 Jekyll 中使用代码高亮&lt;/a&gt;一文中，我使用了 Jekyll 插件中的&lt;a href=&quot;https://jekyllrb.com/docs/plugins/#tags&quot;&gt;Tags&lt;/a&gt;类型来处理 Markdown 中的代码块。这次我们将使用&lt;a href=&quot;https://jekyllrb.com/docs/plugins/#hooks&quot;&gt;Hooks&lt;/a&gt;类型插件介入构建流程。&lt;/p&gt;

&lt;h4 id=&quot;jekyll-hooks&quot;&gt;Jekyll Hooks&lt;/h4&gt;

&lt;p&gt;Jekyll 暴露了多个构建阶段的钩子，我们要介入的阶段包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在站点生成阶段，生成 sw-register.js，负责为当前页面注册 Service Worker&lt;/li&gt;
  &lt;li&gt;在站点生成阶段，生成 service-worker.js，根据配置项，调用 Workbox API 注入预缓存和动态缓存代码&lt;/li&gt;
  &lt;li&gt;在每一个页面生成阶段，插入引入 sw-register.js 的代码块&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Jekyll

    Hooks.register :pages, :post_render do |page|
        # append &amp;lt;script&amp;gt; for sw-register.js in &amp;lt;body&amp;gt;
        SWHelper.insert_sw_register_into_body(page)
    end

    Hooks.register :documents, :post_render do |document|
        # append &amp;lt;script&amp;gt; for sw-register.js in &amp;lt;body&amp;gt;
        SWHelper.insert_sw_register_into_body(document)
    end

    Hooks.register :site, :post_write do |site|
        pwa_config = site.config[&amp;#39;pwa&amp;#39;] || {}
        sw_helper = SWHelper.new(site, pwa_config)

        sw_helper.write_sw_register()
        sw_helper.generate_workbox_precache()
        sw_helper.write_sw()
    end

end&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里有一个问题，为什么要额外生成一个 sw-register.js 负责注册 Service Worker 呢？
在页面中，我们会加上时间戳类似&lt;code class=&quot;highlighter-rouge&quot;&gt;sw-register.js?v= new Date()&lt;/code&gt;保证浏览器不会对&lt;code class=&quot;highlighter-rouge&quot;&gt;sw-register.js&lt;/code&gt;进行缓存。而&lt;code class=&quot;highlighter-rouge&quot;&gt;sw-register.js&lt;/code&gt;中注册&lt;code class=&quot;highlighter-rouge&quot;&gt;service-worker.js&lt;/code&gt;时，会加上构建版本号保证&lt;code class=&quot;highlighter-rouge&quot;&gt;service-worker.js&lt;/code&gt;的更新。
更多详细细节可以参考之前同事写的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28161855&quot;&gt;如何优雅注册 SW&lt;/a&gt;这篇文章。&lt;/p&gt;

&lt;h4 id=&quot;预缓存资源的注入&quot;&gt;预缓存资源的注入&lt;/h4&gt;

&lt;p&gt;首先根据配置项中的 glob 过滤出要缓存的资源，这一点通过标准库&lt;code class=&quot;highlighter-rouge&quot;&gt;Dir.glob&lt;/code&gt;就能完成：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;# find precache files with glob
precache_files = []
patterns.each do |pattern|
    Dir.glob(File.join(directory, pattern)) do |filepath|
        precache_files.push(filepath)
    end
end
precache_files = precache_files.uniq&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后我们可以加上最近 N 篇文章，由于&lt;code class=&quot;highlighter-rouge&quot;&gt;.md&lt;/code&gt;文件最终会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;.html&lt;/code&gt;页面，我们需要同时记录下&lt;code class=&quot;highlighter-rouge&quot;&gt;url&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;path&lt;/code&gt;。要注意，最终添加进预缓存列表的是&lt;code class=&quot;highlighter-rouge&quot;&gt;url&lt;/code&gt;，而&lt;code class=&quot;highlighter-rouge&quot;&gt;path&lt;/code&gt;是根据文件内容生成版本号时用到的。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;# precache recent n posts
posts_path_url_map = {}
if recent_posts_num
    precache_files.concat(
        @site.posts.docs
            .reverse.take(recent_posts_num)
            .map do |post|
                posts_path_url_map[post.path] = post.url
                post.path
            end
    )
end&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后就是关键的步骤了，我们需要根据静态资源的内容生成 md5 版本号，这样能够保证每次 Service Worker 安装时，只会请求发生变动的新资源并缓存，同时清理掉已经不在列表中的旧资源。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;# generate md5 for each precache file
md5 = Digest::MD5.new
precache_files.each do |filepath|
    md5.reset
    md5 &amp;lt;&amp;lt; File.read(filepath)
    if posts_path_url_map[filepath]
        url = posts_path_url_map[filepath]
    else
        url = filepath.sub(@site.dest, &amp;#39;&amp;#39;)
    end
    @precache_list.push({
        url: @site.baseurl + url,
        revision: md5.hexdigest
    })
end&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就完成了预缓存列表的创建，由于符合&lt;code class=&quot;highlighter-rouge&quot;&gt;Workbox.precache&lt;/code&gt;的参数要求，我们直接把列表序列化作为参数传入就行了，在运行时 Workbox 会完成请求资源，清理缓存的工作。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;# generate precache list
precache_list_str = @precache_list.map do |precache_item|
    precache_item.to_json
end
.join(&amp;quot;,&amp;quot;)

# insert into precache function
&amp;lt;&amp;lt;-SCRIPT
    workboxSW.precache([#{precache_list_str}]);
SCRIPT&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;动态缓存也是根据配置项，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;workboxSW.router.registerRoute&lt;/code&gt;，这里就不再赘述了。&lt;/p&gt;

&lt;h4 id=&quot;使用-rubygem-发布&quot;&gt;使用 RubyGem 发布&lt;/h4&gt;

&lt;p&gt;说起来这是我第一次发布一个 RubyGem，不过按照文档说明就行了。gemspec 类似 npm 中的 package.json，虽然按照出现的时间顺序应该是反过来。Ruby 中有很多东西都被其他语言借鉴，我记得以前类似 Hibernate 这样的 ORM 都是有参考 RoR 中的 ActiveRecord。里面大部分字段都很熟悉，甚至和 package.json 都是一致的，&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;version&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;files&lt;/code&gt;等等。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;# jekyll-pwa-plugin.gemspec

Gem::Specification.new do |s|
  s.name        = &amp;#39;jekyll-pwa-plugin&amp;#39;
  s.version     = &amp;#39;1.0.0&amp;#39;
  s.date        = &amp;#39;2017-11-09&amp;#39;
  s.summary     = &amp;quot;PWA support for Jekyll.&amp;quot;
  s.description = &amp;quot;This plugin provides PWA support for Jekyll. Generate a service worker and provides precache with Google Workbox.&amp;quot;
  s.authors     = [&amp;quot;Pan Yuqi&amp;quot;]
  s.email       = &amp;#39;pyqiverson@gmail.com&amp;#39;
  s.files       = [&amp;quot;lib/jekyll-pwa-plugin.rb&amp;quot;, &amp;quot;lib/vendor/broadcast-channel-polyfill.js&amp;quot;, &amp;quot;lib/vendor/workbox-sw.prod.v2.1.1.js&amp;quot;]
  s.homepage    =
    &amp;#39;https://github.com/lavas-project/jekyll-pwa&amp;#39;
  s.license       = &amp;#39;MIT&amp;#39;
end&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在发布之前当然要先做好测试工作，我是直接把写好的插件放在项目&lt;code class=&quot;highlighter-rouge&quot;&gt;/_plugins&lt;/code&gt;下，确认本地可以正常使用。&lt;/p&gt;

&lt;h3 id=&quot;后续优化&quot;&gt;后续优化&lt;/h3&gt;

&lt;p&gt;目前至少有三点可以优化：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;提供一个离线页面，当用户离线访问不在缓存中的页面时展示&lt;/li&gt;
  &lt;li&gt;目前的 Service Worker 根据配置自动生成，可以支持用户传入自定义的模板，使用占位符的方式注入预缓存和动态缓存内容，这样更加灵活&lt;/li&gt;
  &lt;li&gt;开发模式下禁用缓存，不然在写作过程中使用 browser-sync 之类自动刷新的功能就无效了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lavas-project/jekyll-pwa&quot;&gt;插件项目地址&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 10 Nov 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/11/09/%E5%9C%A8Jekyll%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/11/09/%E5%9C%A8Jekyll%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98.html</guid>
        
        <category>jekyll</category>
        
        <category>ruby</category>
        
        <category>workbox</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>SSR 中的离线可用（二）</title>
        <description>&lt;p&gt;本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html&quot;&gt;第一部分&lt;/a&gt;以 PWA-Directory 为例。&lt;/li&gt;
  &lt;li&gt;本文将研究一个 WordPress 主题项目。这个项目是&lt;a href=&quot;https://developer.chrome.com/devsummit/schedule/sessions/wordpress-pwa&quot;&gt;Google Dev Summit 2017&lt;/a&gt;上的一个分享主题。
&lt;a href=&quot;https://github.com/GoogleChromeLabs/ProgressiveWordPress&quot;&gt;代码&lt;/a&gt;可以通过 Docker 启动。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sw-缓存思路&quot;&gt;SW 缓存思路&lt;/h3&gt;

&lt;p&gt;WordPress 本质上也是一个服务端渲染项目。因此也适用第一部分中提出的缓存思路：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;改造后端模板以支持返回完整页面和内容片段&lt;/li&gt;
  &lt;li&gt;服务端增加一条针对 App Shell 的路由规则，返回仅包含 App Shell 的 HTML 页面&lt;/li&gt;
  &lt;li&gt;预缓存 App Shell 页面&lt;/li&gt;
  &lt;li&gt;SW 拦截所有 HTML 请求，统一返回缓存的 App Shell 页面&lt;/li&gt;
  &lt;li&gt;前端路由负责代码片段的填充，完成前端渲染&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;按照这个思路，首先需要对模板进行改造。未来将以主题形式发布。其中使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;get_template_part()&lt;/code&gt;分别获取头部和底部模板片段，也就是 App Shell 了。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;// index.php

&amp;lt;?php
    etag_start();
    if(!is_fragment()) get_template_part(&amp;#39;header&amp;#39;);
?&amp;gt;
&amp;lt;?php if(have_posts()): ?&amp;gt;
    &amp;lt;?php while(have_posts()): the_post() ?&amp;gt;
        &amp;lt;?php include(&amp;#39;fragment-post-preview.php&amp;#39;); ?&amp;gt;
    &amp;lt;?php endwhile; ?&amp;gt;
&amp;lt;?php else: ?&amp;gt;
    Nothing here :(
&amp;lt;?php endif; ?&amp;gt;
&amp;lt;?php
    if(!is_fragment()) get_template_part(&amp;#39;footer&amp;#39;);
    etag_end();
?&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过 query 中&lt;code class=&quot;highlighter-rouge&quot;&gt;fragment&lt;/code&gt;参数区分完整页面 OR 页面内容片段。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;// functions.php

function is_fragment() {
    return isset( $_GET[&amp;#39;fragment&amp;#39;] ) &amp;amp;&amp;amp; &amp;#39;true&amp;#39; === $_GET[&amp;#39;fragment&amp;#39;];
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;index.php&lt;/code&gt;模板中使用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;etag_start/end()&lt;/code&gt;，顾名思义使用了 Etag 比对浏览器请求头中的 HTTP_IF_NONE_MATCH ，如果发现内容没有改变，直接返回304状态码。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;// functions.php

function etag_start() {
    global $etag_depth;

    if ( $etag_depth == 0 ) ob_start();
    $etag_depth++;
}

function etag_end() {
    global $etag_depth;
    $etag_depth--;
    if ( $etag_depth &amp;gt; 0 ) return;

    $content = ob_get_clean();
    $etag = hash(&amp;#39;sha256&amp;#39;, $content);
    $request = isset( $_SERVER[&amp;#39;HTTP_IF_NONE_MATCH&amp;#39;] ) &amp;amp;&amp;amp; $_SERVER[&amp;#39;HTTP_IF_NONE_MATCH&amp;#39;];
    if ( $etag == $request ) {
        http_response_code(304);
        return;
    }

    header(&amp;#39;Etag: &amp;#39; . $etag);
    echo $content;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 29 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/10/28/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%BA%8C.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/10/28/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%BA%8C.html</guid>
        
        <category>PWA</category>
        
        <category>ServiceWorker</category>
        
        <category>PHP</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>SSR 中的离线可用（一）</title>
        <description>&lt;p&gt;本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本文是第一部分，以&lt;a href=&quot;https://pwa-directory.appspot.com&quot;&gt;PWA-Directory&lt;/a&gt;为例。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/coding/2017/10/28/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%BA%8C.html&quot;&gt;第二部分&lt;/a&gt;将研究一个 WordPress 主题项目。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/coding/2017/11/12/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%89.html&quot;&gt;第三部分&lt;/a&gt;将使用 Vue SSR 实践这一思路。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PWA-Directory 是一个陈列 PWA 的站点，同时展示项目 Lighthouse 分数及其他页面性能数据。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/PWA-Directory.png&quot; alt=&quot;PWA-Directory&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/PWA-Directory.png&quot; data-alt=&quot;PWA-Directory&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;PWA-Directory&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;本文假设读者对 PWA 相关技术尤其是 Service Worker 的基础知识已有一定了解。&lt;/p&gt;

&lt;h3 id=&quot;app-shell-模型&quot;&gt;App Shell 模型&lt;/h3&gt;

&lt;p&gt;App Shell 是支持用户界面所需的最小的 HTML、CSS 和 JavaScript。对其进行离线缓存，可确保在用户重复访问时提供即时、可靠的良好性能。这意味着并不是每次用户访问时都要从网络加载 App Shell。 只需要从网络中加载必要的内容。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/appshell.png&quot; alt=&quot;App Shell 模型&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/appshell.png&quot; data-alt=&quot;App Shell 模型&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;App Shell 模型&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;PWA-Directory 包括我们后续的讨论都基于 App Shell 模型。下面我们需要了解一下缓存的细节。&lt;/p&gt;

&lt;h3 id=&quot;预缓存&quot;&gt;预缓存&lt;/h3&gt;

&lt;p&gt;Service Worker 最重要的功能便是控制缓存。这里先简单介绍下预缓存或者说 sw-precache 插件的基本工作原理。&lt;/p&gt;

&lt;p&gt;在项目构建阶段，将静态资源列表（数组形式）及本次构建版本号注入 Service Worker 代码中。在 SW 运行时（Install 阶段）依次发送请求获取静态资源列表中的资源（JS,CSS,HTML,IMG,FONT…），成功后放入缓存并进入下一阶段（Activated）。这个在实际请求之前进行缓存的过程就是预缓存。&lt;/p&gt;

&lt;p&gt;在 SPA/MPA 架构的应用中，App Shell 通常包含在 HTML 页面中，连同页面一并被预缓存，保证了离线可访问。但是在 SSR 架构场景下，情况就不一样了。所有页面首屏均是服务端渲染，预缓存的页面不再是有限且固定的。如果预缓存全部页面，SW 需要发送大量请求不说，每个页面都包含的 App Shell 部分都被重复缓存，也造成了缓存空间的浪费。&lt;/p&gt;

&lt;p&gt;既然针对全部页面的预缓存行不通，我们能不能将 App Shell 剥离出来，单独缓存仅包含这个空壳的页面呢？要实现这一点，就需要对后端模板进行修改，通过传入参数控制返回包含 App Shell 的完整页面 OR 代码片段。这样首屏使用完整页面，而后续页面切换交给前端路由完成，请求代码片段进行填充。这也是基于 React、Vue 等技术实现的同构项目的基本思路。&lt;/p&gt;

&lt;p&gt;对于模板的修改并不复杂，例如在 PWA-Directory 中，使用 Handlebars 作为后端模板，通过自定义的 contentOnly 参数就能适应首屏和后续 HTML 片段两种请求。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;// list.hbs

{{#unless contentOnly}}
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    {{&amp;gt; head}}
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    {{&amp;gt; header}}
    &amp;lt;div class=&amp;quot;page-holder&amp;quot;&amp;gt;
      &amp;lt;main class=&amp;quot;page&amp;quot;&amp;gt;
{{/unless}}
... 页面具体内容
{{#unless contentOnly}}
      &amp;lt;/main&amp;gt;
      &amp;lt;div class=&amp;#39;page-loader&amp;#39;&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    {{&amp;gt; footer}}
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
{{/unless}}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在 SW 中我们需要对 App Shell 页面和 Offline 页面进行预缓存，这里使用了 sw-toolbox 。同时后端需要增加返回 App Shell 的路由规则，这里是&lt;code class=&quot;highlighter-rouge&quot;&gt;/.app/shell&lt;/code&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// service-worker.js

const SHELL_URL = &amp;#39;/.app/shell&amp;#39;;
const ASSETS = [
   SHELL_URL,
   &amp;#39;/favicons/android-chrome-72x72.png&amp;#39;,
   &amp;#39;/manifest.json&amp;#39;,
   ...
];
// 使用 sw-toolbox 缓存静态资源
toolbox.precache(ASSETS);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后我们拦截掉所有 HTML 请求，请求目标页面的内容片段而非完整代码（getContentOnlyUrl 执行了 contentOnly 参数拼接工作），返回之前缓存的 App Shell 页面。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// service-worker.js

toolbox.router.default = (request, values, options) =&amp;gt; {
    // 拦截 HTML 请求
    if (request.mode === &amp;#39;navigate&amp;#39;) {
        // 请求代码片段
        toolbox.cacheFirst(new Request(getContentOnlyUrl(request.url)), values, options);
        // 返回 App Shell 页面
        return getFromCache(SHELL_URL)
            .then(response =&amp;gt; response || gulliverHandler(request, values, options));
    }
    return gulliverHandler(request, values, options);
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有一点值得注意，通常请求目标页面内容片段是放在前端路由中完成的，而这里放在了 SW 中，有什么好处呢？这一点 PWA-Directory 开发者有一篇文章进行了专门讨论，这里就直接使用文中的图片进行说明了。
先看看之前的做法，也就是在前端路由中：&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/pwa-directory-1.png&quot; alt=&quot;前端路由请求代码片段流程图&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/pwa-directory-1.png&quot; data-alt=&quot;前端路由请求代码片段流程图&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;前端路由请求代码片段流程图&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;app.js&lt;/code&gt;加载并执行时才会发出 HTML 代码片段请求，然后等待服务端响应。整个过程中 SW 处于空闲状态，而事实上第一次拦截到 HTML 请求时，SW 就完全可以先请求代码片段了（拼上参数），拿到响应后放入缓存中。这样当&lt;code class=&quot;highlighter-rouge&quot;&gt;app.js&lt;/code&gt;前端路由执行发出请求时，浏览器发现已经在缓存中，就可以直接使用。当然为了实现这一点，需要在服务端通过设置响应头&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control: max-age&lt;/code&gt;保证内容片段的缓存时间。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/pwa-directory-2.png&quot; alt=&quot;SW 请求代码片段流程图&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/pwa-directory-2.png&quot; data-alt=&quot;SW 请求代码片段流程图&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;SW 请求代码片段流程图&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;总结一下这个思路：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;改造后端模板以支持返回完整页面和内容片段&lt;/li&gt;
  &lt;li&gt;服务端增加一条针对 App Shell 的路由规则，返回仅包含 App Shell 的 HTML 页面&lt;/li&gt;
  &lt;li&gt;预缓存 App Shell 页面&lt;/li&gt;
  &lt;li&gt;SW 拦截所有 HTML 请求，统一返回缓存的 App Shell 页面&lt;/li&gt;
  &lt;li&gt;前端路由负责代码片段的填充，完成前端渲染&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际效果是，用户第一次访问应用站点时，首屏由服务端渲染，随后 SW 安装成功后，后续的路由切换包括刷新页面都将由前端渲染完成，服务端将只负责提供 HTML 代码片段的响应。&lt;/p&gt;

&lt;p&gt;解决了预缓存问题，下面我们需要关注另外一个离线可用目标中涉及的关键问题。&lt;/p&gt;

&lt;h3 id=&quot;数据统计&quot;&gt;数据统计&lt;/h3&gt;

&lt;p&gt;在衡量 PWA 效果时，至少有以下几个指标可以考量：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当弹出添加到桌面的 banner 时，用户是否选择了同意&lt;/li&gt;
  &lt;li&gt;当前的操作是否是来自添加到桌面之后&lt;/li&gt;
  &lt;li&gt;当前的操作是否发生在离线状态下&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;beforeinstallprompt&lt;/code&gt;事件，可以轻易获取用户对添加到桌面 banner 的反应：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;window.addEventListener(&amp;#39;beforeinstallprompt&amp;#39;, e =&amp;gt; {
    console.log(e.platforms); // e.g., [&amp;quot;web&amp;quot;, &amp;quot;android&amp;quot;, &amp;quot;windows&amp;quot;]
    e.userChoice.then(outcome =&amp;gt; {
        console.log(outcome); // either &amp;quot;installed&amp;quot;, &amp;quot;dismissed&amp;quot;, etc.
    }, handleError);
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过在&lt;code class=&quot;highlighter-rouge&quot;&gt;manifest.json&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;start_url&lt;/code&gt;中添加参数，很容易标识出当前的用户访问来自添加后的桌面快捷方式。例如使用&lt;a href=&quot;https://support.google.com/analytics/answer/1033863?hl=en&quot;&gt;GA Custom campaigns&lt;/a&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;// manifest.json

{
    &amp;quot;start_url&amp;quot;: &amp;quot;/?utm_source=homescreen&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;判断当前是否处于离线状态，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine&quot;&gt;navigator.onLine&lt;/a&gt;可以实现。但是要注意，返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;时不代表真的可以访问互联网。&lt;/p&gt;

&lt;p&gt;现在我们有了这些统计指标，接下来的问题就是如何保证离线状态下产生的统计数据不丢失。一个很自然的想法是，在 SW 中拦截所有统计请求，离线时将统计数据存储在本地 LocalStorage 或者 IndexedDB 中，上线后再进行数据的同步。&lt;/p&gt;

&lt;p&gt;Google 之前针对 GA 开发了 sw-offline-google-analytics 类库实现了这一功能，现在已经移到了 Workbox &lt;a href=&quot;https://workboxjs.org/reference-docs/latest/module-workbox-google-analytics.html&quot;&gt;相关模块&lt;/a&gt;中，可以很方便地使用：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// service-worker.js

importScripts(&amp;#39;path/to/offline-google-analytics-import.js&amp;#39;);
workbox.googleAnalytics.initialize();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样离线统计的问题就解决了。以上部分代码以 GA 为例，不过其他统计脚本思路也是一致的。&lt;/p&gt;

&lt;h3 id=&quot;离线体验&quot;&gt;离线体验&lt;/h3&gt;

&lt;p&gt;最后说说这个项目在离线用户体验上的亮点。PWA 中的离线用户体验绝不仅仅只是展示离线页面代替浏览器“恐龙”而已。离线时，“我究竟能使用哪些功能？”往往是用户最关心的。让我们来看看 PWA-Directory 在这一点上是怎么做的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/pwa-directory-screenshot.png&quot; alt=&quot;离线体验&quot; /&gt;
&lt;em&gt;离线体验&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在离线时，可以弹出 Toast（图中下方红色部分）给予用户提示。要实现这一点并不难，通过监听&lt;code class=&quot;highlighter-rouge&quot;&gt;online/offline&lt;/code&gt;事件就能做到，接下来才是亮点。&lt;/p&gt;

&lt;p&gt;前面说过，离线时用户很关心能访问哪些内容，如果能通过样式显式标注就再好不过了。在上图中，我访问过第一个 Tab “New” 下列表中的第一个项目，所以此时离线时，页面中其余部分都被置灰且不可点击，只有缓存过的内容被保留了下来，用户将不再有四处点击遇到同样离线页面的挫败感。&lt;/p&gt;

&lt;p&gt;要实现这一点可以从两方面入手，首先从全局样式上，离线时给&lt;code class=&quot;highlighter-rouge&quot;&gt;body&lt;/code&gt;或者具体页面容器加个自定义属性，关心离线功能的组件在这个规则下定义自己的离线样式就行了。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 监听 offline
window.addEventListener(&amp;#39;offline&amp;#39;, () =&amp;gt; {
    // 给容器加上自定义属性
    document.body.setAttribute(&amp;#39;offline&amp;#39;, &amp;#39;true&amp;#39;);
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外具体到某些特定组件，例如这个项目中的列表项，点击每个 PWA 项目的链接都将进入对应的详情页，首次访问会被加入 runtimeCache，因此只需要在缓存中按链接地址进行查询，就能知道这个列表项是否应该置灰。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 判断链接是否访问过
isAvailable(href) {
    if (!href || this.window.navigator.onLine) return Promise.resolve(true);
    return caches.match(href)
        .then(response =&amp;gt; response.status === 200)
        .catch(() =&amp;gt; false);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总之，离线用户体验是需要根据实际项目情况进行精心设计的。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;从 PWA 特性尤其是离线缓存来看，对于 SSR 架构的项目，进行 App Shell 的分离是很有必要的。相比 SPA/MPA 的预缓存方案，SSR 需要对后端模板，前端路由进行一些改造。另外，对于 PWA 相关数据的统计和离线同步，可以借鉴应用 Google 的 Workbox 方案。最后，离线用户体验也是需要仔细考量的。&lt;/p&gt;

&lt;p&gt;如果感兴趣，可以深入了解一下 PWA-Directory 的&lt;a href=&quot;https://github.com/GoogleChromeLabs/gulliver/&quot;&gt;代码&lt;/a&gt;，同时结合开发者的几篇技术文章：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/dev-channel/pwa-directory-loading-content-faster-in-the-application-shell-e35a485b8f4e&quot;&gt;结合 App Shell 优化内容加载速度&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/dev-channel/building-a-hybrid-rendered-pwa-c9d645baf158&quot;&gt;PWA-Directory 的设计思路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们将继续研究一个 WordPress 主题项目。&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.cn/web/fundamentals/architecture/app-shell&quot;&gt;App Shell 模型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/dev-channel/pwa-directory-loading-content-faster-in-the-application-shell-e35a485b8f4e&quot;&gt;PWA-Directory 关于请求内容片段的优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/dev-channel/tracking-pwa-events-with-google-analytics-3b50030d8922&quot;&gt;基于 GA 的 PWA 指标统计&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2016/07/offline-google-analytics&quot;&gt;GA 离线统计&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://workboxjs.org/overview.html&quot;&gt;Workbox&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook&quot;&gt;Offline Cookbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 25 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html</guid>
        
        <category>PWA</category>
        
        <category>ServiceWorker</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Code + Cartoon</title>
        <description>&lt;p&gt;说实话，第一次在&lt;a href=&quot;https://hacks.mozilla.org/&quot;&gt;Hacks&lt;/a&gt;上看到包含如下图片的文章是很意外的。看过不少技术文章，穿插卡通画的还是头一遭，而且这诡异的画风是咋回事。
&lt;img src=&quot;/img/cartoon.png&quot; alt=&quot;降临中的七肢桶？&quot; /&gt;
&lt;em&gt;降临中的七肢桶？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如果你认为这些图不过是点缀罢了，那么来看看个人看过的对浏览器渲染流程最生动的诠释：
&lt;img src=&quot;/img/webrender.png&quot; alt=&quot;一图胜千言&quot; /&gt;
&lt;em&gt;一图胜千言&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;反正我是被这些图吸引着，读完了 WebAssembly 的&lt;a href=&quot;https://hacks.mozilla.org/author/lclarkmozilla-com/&quot;&gt;系列文章&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/10/15/code+cartoon.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/10/15/code+cartoon.html</guid>
        
        <category>tech-blog</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Webpack代码分割[未完]</title>
        <description>&lt;p&gt;了解 Webpack 的启动代码对于分析模块和 chunk 是非常有帮助的。&lt;/p&gt;

&lt;h2 id=&quot;webpack-启动代码&quot;&gt;Webpack 启动代码&lt;/h2&gt;

&lt;p&gt;首先从最简单的情况入手，在入口文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; 中简单引用了一个模块中的方法：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// index.js
import {func1} from &amp;#39;./module1&amp;#39;;

// module1.js
export function func1() {
    console.log(&amp;#39;func1&amp;#39;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据以上入口文件，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;target: web&lt;/code&gt;（默认情况）下生成的 chunk 文件只有一个。观察其中包含的 Webpack 启动代码，可以发现由一个 IIFE 构成，其中传入的参数是一个方法数组。从其中每个方法的签名可以看出，类似 AMD。很明显，&lt;code class=&quot;highlighter-rouge&quot;&gt;module1.js&lt;/code&gt; 模块的全部代码都在模块1中，而模块0对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt;，引用了模块1。另外有一点值得注意，&lt;code class=&quot;highlighter-rouge&quot;&gt;module1.js&lt;/code&gt; 中的方法并没有被真正使用到，注释 &lt;code class=&quot;highlighter-rouge&quot;&gt;/* unused harmony export func1 */&lt;/code&gt; 也反映了这一点，后续在生产环境配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;UglifyJSPlugin&lt;/code&gt; 插件使用时，依托 &lt;a href=&quot;https://doc.webpack-china.org/guides/tree-shaking/&quot;&gt;TreeShaking 技术&lt;/a&gt;，这段无用代码会被移除。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;(function(modules) { // IIFE
 	// 暂时省略处理模块的逻辑
})
([
/* 模块0 */
(function(module, __webpack_exports__, __webpack_require__) {
    &amp;quot;use strict&amp;quot;;
    Object.defineProperty(__webpack_exports__, &amp;quot;__esModule&amp;quot;, { value: true });
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__module1__ = __webpack_require__(1);
}),
/* 模块1 */
(function(module, __webpack_exports__, __webpack_require__) {
    &amp;quot;use strict&amp;quot;;
    /* unused harmony export func1 */
    function func1() {
        console.log(&amp;#39;func1&amp;#39;);
    }
})
]);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在可以深入表达式方法细节了。首先定义了 &lt;code class=&quot;highlighter-rouge&quot;&gt;__webpack_require__&lt;/code&gt; 方法，然后在方法上挂了一些属性便于快捷访问，最后调用入口模块也就是模块0。官方的注释非常详细，尤其是 &lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt; 方法的，就不再赘述了。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// The module cache
var installedModules = {};

// The require function
function __webpack_require__(moduleId) {

    // Check if module is in cache
    if(installedModules[moduleId]) {
        return installedModules[moduleId].exports;
    }
    // Create a new module (and put it into the cache)
    var module = installedModules[moduleId] = {
        i: moduleId,
        l: false,
        exports: {}
    };

    // Execute the module function
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    // Flag the module as loaded
    module.l = true;

    // Return the exports of the module
    return module.exports;
}

// 省略挂载属性...

// Load entry module and return exports
return __webpack_require__(__webpack_require__.s = 0);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在方法上挂载的属性中，&lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt; 用来处理常量&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// define getter function for harmony exports
__webpack_require__.d = function(exports, name, getter) {
    if(!__webpack_require__.o(exports, name)) {
        Object.defineProperty(exports, name, {
            configurable: false,
            enumerable: true,
            get: getter
        });
    }
};

// getDefaultExport function for compatibility with non-harmony modules
__webpack_require__.n = function(module) {
    var getter = module &amp;amp;&amp;amp; module.__esModule ?
        function getDefault() { return module[&amp;#39;default&amp;#39;]; } :
        function getModuleExports() { return module; };
    __webpack_require__.d(getter, &amp;#39;a&amp;#39;, getter);
    return getter;
};

// Object.prototype.hasOwnProperty.call
__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

// __webpack_public_path__
__webpack_require__.p = &amp;quot;&amp;quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// index.js

import(/* webpackChunkName: &amp;quot;lodash&amp;quot; */ &amp;#39;lodash&amp;#39;).then(_ =&amp;gt; {
    return _.version();
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 Webpack 中，chunk 一共有&lt;a href=&quot;https://survivejs.com/webpack/building/bundle-splitting/#chunk-types-in-webpack&quot;&gt;三类&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Entry chunk:&lt;/li&gt;
  &lt;li&gt;Normal chunk:&lt;/li&gt;
  &lt;li&gt;Initial chunk:&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://survivejs.com/webpack/building/bundle-splitting/&quot;&gt;SurviveJS Webpack Book&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/TheLarkInn/artsy-webpack-tour&quot;&gt;Webpack 核心开发者基于源码的解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/lcxfs1991/blog/issues/14&quot;&gt;Webpack runtime 代码分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/prpl-pattern/&quot;&gt;PRPL Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 07 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/10/06/Webpack%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/10/06/Webpack%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2.html</guid>
        
        <category>webpack</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>简单生活节</title>
        <description>&lt;p&gt;第一次去音乐节，站了一天真的是累，幸亏没买3天的套票。&lt;/p&gt;

&lt;p&gt;首先这个“Simple Life 简单生活节”的名字我不知道跟热狗的歌有没有关系。但至少 10.4 这场的主基调是嘻哈无疑了，&lt;a href=&quot;http://i.xiami.com/jfever&quot;&gt;小老虎&lt;/a&gt;，&lt;a href=&quot;http://i.xiami.com/luirap&quot;&gt;Lu1&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/artist/bgqsdcca4&quot;&gt;蛋堡&lt;/a&gt;，&lt;a href=&quot;http://i.xiami.com/higherbrothers&quot;&gt;Higher Brothers&lt;/a&gt;和压轴登场的&lt;a href=&quot;http://www.xiami.com/artist/724&quot;&gt;MC Hotdog&lt;/a&gt;都被集中到了大地舞台。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一堆文青 想要过着简单的生活节&lt;/p&gt;

  &lt;p&gt;你想要生活更复杂点 显然你得跟我学
——《贫民百万歌星》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;房东的猫&quot;&gt;房东的猫&lt;/h4&gt;

&lt;p&gt;下午1点多表演从果实舞台首先开始，一个叫&lt;a href=&quot;http://i.xiami.com/fangdongdemao&quot;&gt;房东的猫&lt;/a&gt;的校园乐队，唱了一首&lt;a href=&quot;http://www.xiami.com/song/1796526633&quot;&gt;『你是我最愚蠢的一次浪漫』&lt;/a&gt;，声音很像陈老师，听着很舒服。看看&lt;a href=&quot;http://dashi.streetvoice.cn/article/%E6%88%BF%E4%B8%9C%E7%9A%84%E7%8C%AB%E8%B6%81%E5%B9%B4%E8%BD%BB%E5%8E%BB%E8%BF%87%E5%96%9C%E6%AC%A2%E7%9A%84%E7%94%9F%E6%B4%BB/&quot;&gt;这篇专访&lt;/a&gt;了解更多她们的故事。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/music/mao.jpg&quot; alt=&quot;你是我最愚蠢的一次浪漫&quot; /&gt;
&lt;em&gt;房东的猫&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;小老虎&quot;&gt;小老虎&lt;/h4&gt;

&lt;p&gt;大概一点半，很多人就都开始往大地舞台走，小老虎的表演就要开始了。&lt;a href=&quot;/music/2017/06/03/%E6%9C%80%E8%BF%91%E5%90%AC%E7%9A%84%E8%AF%B4%E5%94%B1.html&quot;&gt;大学里从跑火车电台听到&lt;/a&gt;小老虎，『为你出生入死九十九次』几乎能背出来。看到穿的跟烤串买买提似的小老虎蹦跳着从后台出来，置身欢呼的人群不禁有点激动。可能有些歌不适合现场吧，除了结尾的&lt;a href=&quot;http://www.xiami.com/song/1772491213&quot;&gt;『无人喝彩』&lt;/a&gt;，其他的我都没听过。人群里每一首都能跟唱的也就前两排吧，不过这也不妨碍大家用自己舒服的姿势跟着摇摆。我很喜欢小老虎说的“我不会要求你们把手借给我”。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/jfever.png&quot; alt=&quot;小老虎&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/jfever.png&quot; data-alt=&quot;小老虎&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;小老虎&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;h4 id=&quot;lu1&quot;&gt;Lu1&lt;/h4&gt;

&lt;p&gt;接下来是 Lu1，一个货真价实的学霸，同为程序员有种天生的好感。之前只听过一首他和蛋堡，Cee 合作的&lt;a href=&quot;http://www.xiami.com/song/1776221807&quot;&gt;『Highlight』&lt;/a&gt;，他的那段 verse 用词真的很特别。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;从这里，他们flip a page，对事&lt;/p&gt;

  &lt;p&gt;重新做考估，难免有分歧或对峙
——《Highlight》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/music/lu1.jpg&quot; alt=&quot;Lu1&quot; /&gt;
&lt;em&gt;Lu1&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;蛋堡--李英宏&quot;&gt;蛋堡 &amp;amp; 李英宏&lt;/h4&gt;

&lt;p&gt;蛋堡的歌个人感觉其实不太适合现场，尤其是整体偏燥的氛围下有些昏昏欲睡。但是惊喜的是另一位嘉宾歌手&lt;a href=&quot;http://www.xiami.com/artist/yhD1O0b734b&quot;&gt;李英宏&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/mQXlXIcd689&quot;&gt;『台北直直撞』&lt;/a&gt;如同他的泡面头+大红色一样骚气十足。十分不能理解边上传出的“蛋堡还不上来啊，这谁赶紧下去”之类的声音，个人很喜欢他的风格。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/softlipa.png&quot; alt=&quot;蛋堡&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/softlipa.png&quot; data-alt=&quot;蛋堡&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;蛋堡&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;h4 id=&quot;higher-brothers&quot;&gt;Higher Brothers&lt;/h4&gt;

&lt;p&gt;吃了点东西，就到了海尔兄弟。从每一遍垫场广告里“made in china”都有人跟唱就能看出，他们的人气真的高的恐怖。视野里每个人几乎都处于全程跳跃状态。由于已经是傍晚，在舞台灯光配合下真的有一种迷幻的感觉。海尔兄弟已经走向世界，我还是最喜欢 masiwei 的崂山道士。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/higherbrothers.png&quot; alt=&quot;Higher Brothers: dz &amp;amp; masiwei&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/higherbrothers.png&quot; data-alt=&quot;Higher Brothers: dz &amp;amp; masiwei&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;Higher Brothers: dz &amp;amp; masiwei&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;h4 id=&quot;万芳&quot;&gt;万芳&lt;/h4&gt;

&lt;p&gt;由于热狗迟到一小时，等待的间隙去微风舞台看了&lt;a href=&quot;http://dashi.streetvoice.cn/article/20171002/002/&quot;&gt;万芳&lt;/a&gt;的表演。我就是她说的“只知道我的『新不了情』的新朋友”，听了几首感觉嗓子保养的真好，与之形成鲜明对比的是另一个星空舞台上的高旗，虽然唱摇滚不好这样简单对比，但听着着实感到吃力。推荐一首&lt;a href=&quot;http://www.xiami.com/song/bf0Ho8u305cd&quot;&gt;『落音』&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;mc-hotdog&quot;&gt;MC Hotdog&lt;/h4&gt;

&lt;p&gt;热狗的压轴演出对得起观众老爷们的等待，&lt;a href=&quot;http://www.xiami.com/song/erWf62e123&quot;&gt;『谢谢哑虎』&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/mQC67x9545a&quot;&gt;『贫民百万歌星』&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/8Gi4kAf3809&quot;&gt;『轻熟女』&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/bAgql12f94&quot;&gt;『差不多先生』&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/mQC67ycfb9a&quot;&gt;『不吃早餐才是一件很嘻哈的事』&lt;/a&gt;应该是很多人的回忆吧。说实话他现在的兄弟本色一首都没听过。。。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/mchotdog.png&quot; alt=&quot;MC Hotdog&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/mchotdog.png&quot; data-alt=&quot;MC Hotdog&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;MC Hotdog&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;部分图片来自&lt;a href=&quot;http://dashi.streetvoice.cn/article/20171012/001/&quot;&gt;图集&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/music/2017/10/05/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%E8%8A%82.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/music/2017/10/05/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%E8%8A%82.html</guid>
        
        <category>hiphop</category>
        
        
        <category>music</category>
        
      </item>
    
      <item>
        <title>火车和出租车</title>
        <description>&lt;p&gt;看着火车这一意象不断出现在一幕幕闪回中，观众们对男主角的唏嘘也愈发被强化。命运是在哪一步被搬了道岔，驶向了万劫不复的终结呢。明明曾经有着美好的初恋，也怀着梦想参军，却莫名地被大事件裹挟，如同粗暴的被上级士官一脚踹飞而散落一地的薄荷糖，被无数慌乱的脚步踩的稀碎。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/mint.jpg&quot; alt=&quot;《薄荷糖》&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/mint.jpg&quot; data-alt=&quot;《薄荷糖》&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;《薄荷糖》&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;谈起韩国的伤痕文学，“光州事件”是永远无法绕开的。《薄荷糖》展现了一个木讷士兵的视角，明明脚中了流弹还以为靴子里灌满了水，慌乱中误杀女学生成了一切悲剧的根源。这是我第一次看薛景求的片子，男主各阶段的状态就如同他的发型，被他演绎的令人无比信服，人物转变没有一丝突兀。结尾处男主独自离开众人潸然泪下的场景，呼应开头又透出浓浓的宿命味道。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/movie/mint2.jpg&quot; alt=&quot;我要回去&quot; /&gt;
&lt;em&gt;薛景求：“我要回去！”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;最近另一部涉及同题材的片子在网络上遭遇大面积封禁。除了都大量出现了交通工具，男主宋康昊也展现了自己的纯熟演技。虽然个人不喜欢大事件之后某些过度煽情的场景，但片子传达出媒体和政府的反思不得不说令人欣羨。&lt;/p&gt;

&lt;p&gt;其实我一直很奇怪的一点是同属文艺作品，相比电影的审查尺度，书却宽松许多。最近看完了冯骥才的《一百个人的十年》，作者一直在思考一个问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么人性的弱点，如人的自私、贪欲、怯弱、妒忌、虚荣等被“文革”利用；人性的优点，如忠诚、勇敢、淳朴、无私、诚实也成为“文革”推波助澜的动力？在人性的两极都被“文革”利用的同时，那些真正属于人性的人道、人权、人的尊严、人的价值等所有人的最高贵的成分，都受到“文革”公开的践踏？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在面对历史的时候我觉得至少要保持自信和诚实。且不说能不能拍和拍好，现在连评论他国的作品都要噤声了，买菜市民真的那么可怕吗？&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/movie/2017/10/03/%E7%81%AB%E8%BD%A6%E5%92%8C%E5%87%BA%E7%A7%9F%E8%BD%A6.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/movie/2017/10/03/%E7%81%AB%E8%BD%A6%E5%92%8C%E5%87%BA%E7%A7%9F%E8%BD%A6.html</guid>
        
        <category>movie</category>
        
        
        <category>movie</category>
        
      </item>
    
      <item>
        <title>Webpack 中的 HMR</title>
        <description>&lt;p&gt;在使用 Webpack 构建项目时，开发模式下代码的 hotreload 特性帮助开发者节省了很多手动刷新浏览器的时间。最近在项目中遇到了这方面的问题，决定深入研究一下背后的实现原理。&lt;/p&gt;

&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;

&lt;p&gt;首先需要引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;webpack-hot-middleware&lt;/code&gt; 中间件和 &lt;code class=&quot;highlighter-rouge&quot;&gt;HotModuleReplacementPlugin&lt;/code&gt; 插件。当然开发环境下 &lt;code class=&quot;highlighter-rouge&quot;&gt;webpack-dev-middleware&lt;/code&gt; 肯定也是必不可少的。&lt;/p&gt;

&lt;p&gt;启动项目后打开 Chrome Devtools，这个&lt;code class=&quot;highlighter-rouge&quot;&gt;/__webpack_hmr&lt;/code&gt;请求很明显是实现 hotreload 的关键。可以看出请求一直保持连接，并不断接收到“心跳”事件。
&lt;img src=&quot;/img/hmr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;客户端发起-socket-连接&quot;&gt;客户端发起 socket 连接&lt;/h2&gt;

&lt;p&gt;首先观察一下请求头&lt;code class=&quot;highlighter-rouge&quot;&gt;text/event-stream&lt;/code&gt;，这个请求是由客户端代码通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&quot;&gt;EventSource&lt;/a&gt;创建的：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/client.js

function init() {
    source = new window.EventSource(options.path);
    source.onopen = handleOnline;
    source.onerror = handleDisconnect;
    source.onmessage = handleMessage;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里提到的“客户端代码”是指使用 webpack-hot-middleware 时，除了使用中间件之外，还需要把&lt;a href=&quot;https://github.com/glenjamin/webpack-hot-middleware/blob/master/client.js#L74-L79&quot;&gt;client.js&lt;/a&gt;加入入口依赖，因此这段代码会被打包到客户端代码中。创建完 EventSource 之后，绑定了若干事件处理函数，我们后续会查看这些细节。&lt;/p&gt;

&lt;h2 id=&quot;服务端中间件响应&quot;&gt;服务端中间件响应&lt;/h2&gt;

&lt;p&gt;在收到客户端请求后，中间件需要进行响应，同时需要管理每一个客户端连接，这里将响应对象通过自增的 ID 保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;clients&lt;/code&gt;中，当连接断开时删除。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/middleware.js

function(req, res) {
    req.socket.setKeepAlive(true);
    res.writeHead(200, {
        &amp;#39;Access-Control-Allow-Origin&amp;#39;: &amp;#39;*&amp;#39;,
        &amp;#39;Content-Type&amp;#39;: &amp;#39;text/event-stream;charset=utf-8&amp;#39;,
        &amp;#39;Cache-Control&amp;#39;: &amp;#39;no-cache, no-transform&amp;#39;,
        &amp;#39;Connection&amp;#39;: &amp;#39;keep-alive&amp;#39;,
        &amp;#39;X-Accel-Buffering&amp;#39;: &amp;#39;no&amp;#39;
    });
    res.write(&amp;#39;\n&amp;#39;);
    var id = clientId++;
    clients[id] = res;
    req.on(&amp;quot;close&amp;quot;, function(){
        delete clients[id];
    });
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;向每个连接发送心跳事件是通过定时器完成的。值得一提的是&lt;code class=&quot;highlighter-rouge&quot;&gt;unref()&lt;/code&gt;的用法，使这个定时器不会影响事件循环的退出，如果没有其他事件进入队列，事件循环将结束，进程就退出了。更多关于&lt;code class=&quot;highlighter-rouge&quot;&gt;unref()&lt;/code&gt;的说明，可以参考这个&lt;a href=&quot;https://cnodejs.org/topic/570924d294b38dcb3c09a7a0#5709f1b8bc564eaf3c6a48e1&quot;&gt;回答&lt;/a&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/middleware.js

setInterval(function heartbeatTick() {
    everyClient(function(client) {
        // 向每个 client 发送心跳字符
        client.write(&amp;quot;data: \uD83D\uDC93\n\n&amp;quot;);
    });
}, heartbeat).unref();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么在代码发生变动时，如何通知客户端呢？在创建中间件时，为 webpack 编译器添加了对应编译阶段的监听函数：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/middleware.js

compiler.plugin(&amp;quot;compile&amp;quot;, function() {
    eventStream.publish({action: &amp;quot;building&amp;quot;});
});
compiler.plugin(&amp;quot;done&amp;quot;, function(statsResult) {
    eventStream.publish({
        name: stats.name,
        action: action,
        time: stats.time,
        hash: stats.hash,
        warnings: stats.warnings || [],
        errors: stats.errors || [],
        modules: buildModuleMap(stats.modules)
    });
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;客户端热更新&quot;&gt;客户端热更新&lt;/h2&gt;

&lt;p&gt;在接收到代码变动后服务端发送的事件后，客户端代码需要进行模块热替换处理。客户端在创建 EventSource 时通过&lt;code class=&quot;highlighter-rouge&quot;&gt;onmessage&lt;/code&gt;定义了处理服务端消息的函数。其中&lt;code class=&quot;highlighter-rouge&quot;&gt;building&lt;/code&gt;事件只是简单的输出控制台信息，我们将着重关注&lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt;事件。另外通过&lt;code class=&quot;highlighter-rouge&quot;&gt;customHandler&lt;/code&gt;支持自定义事件，例如可以为 html-webpack-plugin 添加自动刷新页面功能，后续将会介绍具体做法。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/client.js

case &amp;quot;sync&amp;quot;:
    processUpdate(obj.hash, obj.modules, options);
    break;
default:
    if (customHandler) {
        customHandler(obj);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们通过比对当前代码的 hash 和服务端发来的 hash 判断代码是否发生了更新。当前代码的 hash 是通过 webpack 的&lt;a href=&quot;https://doc.webpack-china.org/api/module-variables/#__webpack_hash__-webpack-specific-&quot;&gt;全局模块变量&lt;/a&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/* global window __webpack_hash__ */&lt;/code&gt;在编译时注入。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/process-update.js

/* global window __webpack_hash__ */
function upToDate(hash) {
    if (hash) lastHash = hash;
    return lastHash == __webpack_hash__;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当发现 hash 不匹配，也就是代码发生了更新时，首先需要获取最新的代码，这依赖 webpack 模块的&lt;a href=&quot;https://doc.webpack-china.org/api/hot-module-replacement#check&quot;&gt;hot.check()&lt;/a&gt;接口。调用后将发送一个 HTTP 请求用来获取更新后的模块信息，触发回调函数。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var result = module.hot.check(false, cb);
if (result &amp;amp;&amp;amp; result.then) {
    result.then(function(updatedModules) {
        cb(null, updatedModules);
    });
    result.catch(cb);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在回调函数中，如果没有报错，就调用模块的 &lt;code class=&quot;highlighter-rouge&quot;&gt;hot.apply()&lt;/code&gt; 进行热替换。要注意正常的热替换是不需要触发浏览器刷新页面的，会执行代码中&lt;code class=&quot;highlighter-rouge&quot;&gt;if (module.hot)&lt;/code&gt;条件分支的热替换逻辑。
详细信息可以参考&lt;a href=&quot;https://doc.webpack-china.org/guides/hot-module-replacement&quot;&gt; Webpack 文档的介绍&lt;/a&gt;或者 style-loader 的实现。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var cb = function(err, updatedModules) {
    if (err) return handleError(err);
    var applyResult = module.hot.apply(applyOptions, applyCallback);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此我们了解了代码热更新时，服务端和客户端的整个通信流程。&lt;/p&gt;

&lt;h2 id=&quot;为-html-webpack-plugin-添加自动刷新&quot;&gt;为 html-webpack-plugin 添加自动刷新&lt;/h2&gt;

&lt;p&gt;最后让我们来看一个开发中具体的问题。在使用 html-webpack-plugin 插件生成 HTML 的场景中，我们希望做到修改模版自动刷新页面，节省手动刷新的时间。这里使用到了之前 webpack-hot-middleware 客户端代码接收自定义更新事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;customHandler&lt;/code&gt;。在使用中间件的服务端代码中，每次 HTML 生成后，都会向客户端发送一个自定义事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;reload&lt;/code&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 使用 webpack-hot-middleware 的服务端代码

compiler.plugin(&amp;#39;compilation&amp;#39;, (compilation) =&amp;gt; {
    compilation.plugin(&amp;#39;html-webpack-plugin-after-emit&amp;#39;, (data, cb) =&amp;gt; {
        hotMiddleware.publish({
            action: &amp;#39;reload&amp;#39;
        });
        cb();
    });
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在客户端 entry 代码中，只需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;subscribe&lt;/code&gt; 订阅该自定义事件即可。另外，这里使用到了 Webpack 模块的 query 参数。关于 &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;noInfo&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;reload&lt;/code&gt; 这些客户端参数的含义，可以参考 webpack-hot-middleware 的&lt;a href=&quot;https://github.com/glenjamin/webpack-hot-middleware#config&quot;&gt;文档说明&lt;/a&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 客户端 entry 代码

import &amp;#39;eventsource-polyfill&amp;#39;;
import hotClient from &amp;#39;webpack-hot-middleware/client?name=compilerName&amp;amp;noInfo=true&amp;amp;reload=true&amp;#39;;

hotClient.subscribe(payload =&amp;gt; {
    if (payload.action === &amp;#39;reload&amp;#39; || payload.reload === true) {
        window.location.reload();
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 vuejs-templates 官方 Webpack 模版中，就采用了这种做法。但是其中有一个&lt;a href=&quot;https://github.com/vuejs-templates/webpack/issues/751#issuecomment-309955295&quot;&gt;ISSUE&lt;/a&gt;值得关注，包括我自己在使用时，也遇到了同样的问题。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://doc.webpack-china.org/concepts/hot-module-replacement/&quot;&gt;Webpack HMR 官方介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/vuejs-templates/webpack/issues/751#issuecomment-309955295&quot;&gt;vuejs-templates issue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 30 Sep 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/09/29/Webpack-%E4%B8%AD%E7%9A%84-HMR.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/09/29/Webpack-%E4%B8%AD%E7%9A%84-HMR.html</guid>
        
        <category>javascript</category>
        
        <category>webpack</category>
        
        <category>eventstream</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Node.js 中的消息队列</title>
        <description>&lt;p&gt;在用户注册的场景中，服务端接收到提交的表单内容，将数据写入数据库，随后发送一封注册成功邮件。
通常处理请求参数，操作数据库，调用 STMP 邮件服务器发送邮件都写在一个请求处理函数中。这样的问题是任何一步发生错误，都需要重试。这还只是一个简单场景，如果流程复杂，依赖外部系统众多，显然问题就不可避免了。&lt;/p&gt;

&lt;p&gt;我们引入消息队列，producer 负责向队列中推送消息，而 worker 负责消费。
&lt;img src=&quot;/img/work-queue.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用消息队列的好处是显而易见的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;解耦了 producer 和 worker。尤其是像发送邮件这样对实时性要求不高的步骤，如果这一步操作失败，我们显然不需要回滚之前对数据库的修改，只需要在合适的时间重试就行了。&lt;/li&gt;
  &lt;li&gt;实现重试逻辑变得简单。另外，当进程出现错误，不至于丢失全部状态，甚至可以从错误中恢复。&lt;/li&gt;
  &lt;li&gt;分布式和扩展性。配合 cluster，创建多个 worker 变得简单。&lt;/li&gt;
  &lt;li&gt;让外部系统更容易集成进来，相比在一个请求回调函数中完成所有逻辑处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;简单的内存队列&quot;&gt;简单的内存队列&lt;/h2&gt;

&lt;p&gt;首先实现一个内存中的队列管理，使用 async 创建队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 创建并发度为1的异步队列
const queue = async.queue(work, 1);

function work(item, cb) {
    ensureConnected(function() {
        domotic.command(item.command, item.options, callback);
    });

    function callback(err) {
        // 出错重试
        if (err &amp;amp;&amp;amp; err.code == &amp;#39;ECONN&amp;#39;) {
            connected = false;
            work(item, cb);
        } else cb(err);
    }
}
// 推送消息到队列中
queue.push(work, cb);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样一个简单的 demo 存在的问题就是所有状态存在于内存中，一旦崩溃就无法恢复了。另外内存毕竟有限，对于一个长时间运行的系统，迟早是会超出内存限制的。&lt;/p&gt;

&lt;h2 id=&quot;通过-leveldb-持久化&quot;&gt;通过 LevelDB 持久化&lt;/h2&gt;

&lt;p&gt;持久化队列是个不错的改进方向。LevelDB 是一个键值对数据库，不需要安装，可以在指定目录下创建。另外，使用配套的 &lt;code class=&quot;highlighter-rouge&quot;&gt;level-jobs&lt;/code&gt; 可以快捷的创建队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const level = require(&amp;#39;level&amp;#39;);
// 创建本地数据库
const db = level(&amp;#39;./event/db&amp;#39;);
const Jobs = require(&amp;#39;level-jobs&amp;#39;);
const maxConcurrency = 1;
// 创建队列，并发度1
const queue = Jobs(db, worker, maxConcurrency);

module.exports = queue;

function worker(id, payload, cb) {
    sendEventToRemoteService(payload, (err) =&amp;gt; {
        if (err) {
            console.error(&amp;#39;Error processing event %s: %s&amp;#39;,payload.id, err.message);
        }
        else {
            console.log(&amp;#39;event %s successfully relayed&amp;#39;, payload.id);
        }
        cb(err);
    });
}
// 模拟复杂异步处理流程
function sendEventToRemoteService(payload, cb) {
    setTimeout(() =&amp;gt; {
        let err;
        if (Math.random() &amp;gt; 0.5) {
            err = Error(&amp;#39;something awful has happened&amp;#39;);
        }
        cb(err);
    }, 100);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;queue.push(payload)&lt;/code&gt;可以向队列中推送消息。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const relay = require(&amp;#39;./event_relay&amp;#39;);
for(let i = 0; i &amp;lt; 10; i++) {
    relay.push({
        id: i,
        event: &amp;#39;door opened&amp;#39;
    });
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在我们解决了持久化队列的问题，但是我们的 worker 是单线程运行的。如果任务是 CPU 密集型的，还是需要分配负载到多个线程上。&lt;/p&gt;

&lt;h2 id=&quot;redis-和多线程&quot;&gt;Redis 和多线程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;simple-redis-safe-work-queue&lt;/code&gt; 是一个基于 Redis 的分布式 worker/producer 的队列解决方案。
创建 worker，设置重试次数。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const request = require(&amp;#39;request&amp;#39;);
const Queue = require(&amp;#39;simple-redis-safe-work-queue&amp;#39;)
// 设置重试次数
const workerOptions = {
  maxRetries: 2
};

const worker = Queue.worker(&amp;#39;invoke webhook&amp;#39;, invokeWebhook, workerOptions);

function invokeWebhook(webhook, cb) {
    console.log(&amp;#39;invoke webhook: %j&amp;#39;, webhook);

    request(webhook, done);

    function done(err, res) {
        if (!err &amp;amp;&amp;amp; (res.statusCode &amp;lt; 200 || res.statusCode &amp;gt;= 300)) {
            err = Error(&amp;#39;response status code was &amp;#39; + res.statusCode);
        }
        cb(err);
    }
}

worker.on(&amp;#39;max retries&amp;#39;, function(err, payload) {
    console.error(
        &amp;#39;max retries reached trying to talk to %s.: %s\nrequest params: %j&amp;#39;,
        payload.url, err.stack, payload);
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而对于 producer，在一个实际的例子中，在数据库操作完成后向队列推送消息，并在 server 停止时关闭队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const Queue = require(&amp;#39;simple-redis-safe-work-queue&amp;#39;)
const webhookQueueClient = Queue.client(&amp;#39;invoke webhook&amp;#39;);
const server = Server();
server.listen(8080);
server.post(&amp;#39;/some/important/action&amp;#39;, (req, res, next) =&amp;gt; {
    db.insert(someDoc, err =&amp;gt; {
        if (err) res.send(err);
        else {
            webhookQueueClient.push({
                url: &amp;#39;http://example.com&amp;#39;,
                method: &amp;#39;POST&amp;#39;,
                json: {
                    a: 1,
                    b: 2
                }
            }, pushedWebhookWork);
        }

        function pushedWebhookWork(err) {
            if (err) res.stats(500).send(err);
            else res.stats(201).send({ok: true});
        }
    });
});
// 关闭队列
server.once(&amp;#39;close&amp;#39;, () =&amp;gt; {
    webhookQueueClient.quit();
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们可以启动多个 worker 线程消费队列。Redis 在处理简单的场景中足够了，如果对可扩展性和稳定性有更高要求，就需要更为成熟的平台了。&lt;/p&gt;

&lt;h2 id=&quot;rabbitmq&quot;&gt;RabbitMQ&lt;/h2&gt;

&lt;p&gt;通过 homebrew 安装后。启动服务器：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/sbin/rabbitmq-server&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;创建 channel，无论成功与否都会触发回调函数。worker 和 producer 都会通过该方法连接队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const amqp = require(&amp;#39;amqplib/callback_api&amp;#39;);
const url = process.env.AMQP_URL || &amp;#39;amqp://guest:guest@localhost:5672&amp;#39;;

module.exports = createQueueChannel;

function createQueueChannel(queue, cb) {
    amqp.connect(url, onceConnected);

    function onceConnected(err, conn) {
        if (err) {
            console.error(&amp;#39;Error connecting:&amp;#39;, err.stack);
        }
        else {
            console.log(&amp;#39;connected&amp;#39;);
            conn.createChannel(onceChannelCreated);
        }

        function onceChannelCreated(err, channel) {
            if (err) {
                cb(err);
            }
            else {
                channel.assertQueue(queue, {durable: true}, onceQueueCreated);
            }

            function onceQueueCreated(err) {
                if (err) {
                    cb(err);
                }
                else {
                    cb(null, channel, conn);
                }
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于 producer 而言，需要连接 channel，然后向队列发送消息，随后断开连接：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const Channel = require(&amp;#39;./channel&amp;#39;);
const QUEUE = &amp;#39;queue&amp;#39;;

Channel(QUEUE, (err, channel, conn) =&amp;gt; {
    if (err) {
        console.error(err.stack);
    }
    else {
        console.log(&amp;#39;channel and queue created&amp;#39;);
        let work = &amp;#39;make me a sandwich&amp;#39;;
        channel.sendToQueue(QUEUE, encode(work), {
            persistent: true
        });
        setImmediate(() =&amp;gt; {
            channel.close();
            conn.close();
        });
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而对于每一个 worker，连接成功后，取出队列中的消息内容载荷进行消费，完成后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ack()&lt;/code&gt;通知队列，继续消费下一个消息。而如果队列为空，通过定时器在一定延迟后继续消费。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Channel(QUEUE, (err, channel, conn) =&amp;gt; {
    if (err) {
        console.error(err.stack);
    }
    else {
        console.log(&amp;#39;channel and queue created&amp;#39;);
        consume();
    }

    function consume() {
        channel.get(QUEUE, {}, onConsume);

        function onConsume(err, msg) {
            if (err) {
                console.warn(err.message);
            }
            else if (msg) {
                console.log(&amp;#39;consuming %j&amp;#39;, msg.content.toString());
                setTimeout(() =&amp;gt; {
                    channel.ack(msg);
                    consume();
                }, 1e3);
            }
            else {
                console.log(&amp;#39;no message, waiting...&amp;#39;);
                setTimeout(consume, 1e3);
            }
        }
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.yld.io/2016/05/10/introducing-queues/#.Wb4dqHeg_2Q&quot;&gt;YLD博客的系列文章&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rabbitmq.com/documentation.html&quot;&gt;RabbitMQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 17 Sep 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html</guid>
        
        <category>javascript</category>
        
        <category>nodejs</category>
        
        <category>leveldb</category>
        
        <category>redis</category>
        
        <category>rabbitMQ</category>
        
        
        <category>coding</category>
        
      </item>
    
  </channel>
</rss>
