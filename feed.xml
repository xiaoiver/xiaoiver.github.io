<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xiaOp的博客</title>
    <description>分享写代码，听音乐，看电影的心得
</description>
    <link>https://xiaoiver.github.io/</link>
    <atom:link href="https://xiaoiver.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 17 Sep 2017 20:36:25 +0800</pubDate>
    <lastBuildDate>Sun, 17 Sep 2017 20:36:25 +0800</lastBuildDate>
    <generator>Jekyll v3.4.5</generator>
    
      <item>
        <title>Node.js 中的消息队列</title>
        <description>&lt;p&gt;在用户注册的场景中，服务端接收到提交的表单内容，将数据写入数据库，随后发送一封注册成功邮件。
通常处理请求参数，操作数据库，调用 STMP 邮件服务器发送邮件都写在一个请求处理函数中。这样的问题是任何一步发生错误，都需要重试。这还只是一个简单场景，如果流程复杂，依赖外部系统众多，显然问题就不可避免了。&lt;/p&gt;

&lt;p&gt;我们引入消息队列，producer 负责向队列中推送消息，而 worker 负责消费。
&lt;img src=&quot;/img/work-queue.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用消息队列的好处是显而易见的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;解耦了 producer 和 worker。尤其是像发送邮件这样对实时性要求不高的步骤，如果这一步操作失败，我们显然不需要回滚之前对数据库的修改，只需要在合适的时间重试就行了。&lt;/li&gt;
  &lt;li&gt;实现重试逻辑变得简单。另外，当进程出现错误，不至于丢失全部状态，甚至可以从错误中恢复。&lt;/li&gt;
  &lt;li&gt;分布式和扩展性。配合 cluster，创建多个 worker 变得简单。&lt;/li&gt;
  &lt;li&gt;让外部系统更容易集成进来，相比在一个请求回调函数中完成所有逻辑处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;简单的内存队列&quot;&gt;简单的内存队列&lt;/h2&gt;

&lt;p&gt;首先实现一个内存中的队列管理，使用 async 创建队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 创建并发度为1的异步队列
const queue = async.queue(work, 1);

function work(item, cb) {
    ensureConnected(function() {
        domotic.command(item.command, item.options, callback);
    });

    function callback(err) {
        // 出错重试
        if (err &amp;amp;&amp;amp; err.code == &amp;#39;ECONN&amp;#39;) {
            connected = false;
            work(item, cb);
        } else cb(err);
    }
}
// 推送消息到队列中
queue.push(work, cb);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样一个简单的 demo 存在的问题就是所有状态存在于内存中，一旦崩溃就无法恢复了。另外内存毕竟有限，对于一个长时间运行的系统，迟早是会超出内存限制的。&lt;/p&gt;

&lt;h2 id=&quot;通过-leveldb-持久化&quot;&gt;通过 LevelDB 持久化&lt;/h2&gt;

&lt;p&gt;持久化队列是个不错的改进方向。LevelDB 是一个键值对数据库，不需要安装，可以在指定目录下创建。另外，使用配套的 &lt;code class=&quot;highlighter-rouge&quot;&gt;level-jobs&lt;/code&gt; 可以快捷的创建队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const level = require(&amp;#39;level&amp;#39;);
// 创建本地数据库
const db = level(&amp;#39;./event/db&amp;#39;);
const Jobs = require(&amp;#39;level-jobs&amp;#39;);
const maxConcurrency = 1;
// 创建队列，并发度1
const queue = Jobs(db, worker, maxConcurrency);

module.exports = queue;

function worker(id, payload, cb) {
    sendEventToRemoteService(payload, (err) =&amp;gt; {
        if (err) {
            console.error(&amp;#39;Error processing event %s: %s&amp;#39;,payload.id, err.message);
        }
        else {
            console.log(&amp;#39;event %s successfully relayed&amp;#39;, payload.id);
        }
        cb(err);
    });
}
// 模拟复杂异步处理流程
function sendEventToRemoteService(payload, cb) {
    setTimeout(() =&amp;gt; {
        let err;
        if (Math.random() &amp;gt; 0.5) {
            err = Error(&amp;#39;something awful has happened&amp;#39;);
        }
        cb(err);
    }, 100);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;queue.push(payload)&lt;/code&gt;可以向队列中推送消息。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const relay = require(&amp;#39;./event_relay&amp;#39;);
for(let i = 0; i &amp;lt; 10; i++) {
    relay.push({
        id: i,
        event: &amp;#39;door opened&amp;#39;
    });
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在我们解决了持久化队列的问题，但是我们的 worker 是单线程运行的。如果任务是 CPU 密集型的，还是需要分配负载到多个线程上。&lt;/p&gt;

&lt;h2 id=&quot;redis-和多线程&quot;&gt;Redis 和多线程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;simple-redis-safe-work-queue&lt;/code&gt; 是一个基于 Redis 的分布式 worker/producer 的队列解决方案。
创建 worker，设置重试次数。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const request = require(&amp;#39;request&amp;#39;);
const Queue = require(&amp;#39;simple-redis-safe-work-queue&amp;#39;)
// 设置重试次数
const workerOptions = {
  maxRetries: 2
};

const worker = Queue.worker(&amp;#39;invoke webhook&amp;#39;, invokeWebhook, workerOptions);

function invokeWebhook(webhook, cb) {
    console.log(&amp;#39;invoke webhook: %j&amp;#39;, webhook);

    request(webhook, done);

    function done(err, res) {
        if (!err &amp;amp;&amp;amp; (res.statusCode &amp;lt; 200 || res.statusCode &amp;gt;= 300)) {
            err = Error(&amp;#39;response status code was &amp;#39; + res.statusCode);
        }
        cb(err);
    }
}

worker.on(&amp;#39;max retries&amp;#39;, function(err, payload) {
    console.error(
        &amp;#39;max retries reached trying to talk to %s.: %s\nrequest params: %j&amp;#39;,
        payload.url, err.stack, payload);
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而对于 producer，在一个实际的例子中，在数据库操作完成后向队列推送消息，并在 server 停止时关闭队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const Queue = require(&amp;#39;simple-redis-safe-work-queue&amp;#39;)
const webhookQueueClient = Queue.client(&amp;#39;invoke webhook&amp;#39;);
const server = Server();
server.listen(8080);
server.post(&amp;#39;/some/important/action&amp;#39;, (req, res, next) =&amp;gt; {
    db.insert(someDoc, err =&amp;gt; {
        if (err) res.send(err);
        else {
            webhookQueueClient.push({
                url: &amp;#39;http://example.com&amp;#39;,
                method: &amp;#39;POST&amp;#39;,
                json: {
                    a: 1,
                    b: 2
                }
            }, pushedWebhookWork);
        }

        function pushedWebhookWork(err) {
            if (err) res.stats(500).send(err);
            else res.stats(201).send({ok: true});
        }
    });
});
// 关闭队列
server.once(&amp;#39;close&amp;#39;, () =&amp;gt; {
    webhookQueueClient.quit();
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们可以启动多个 worker 线程消费队列。Redis 在处理简单的场景中足够了，如果对可扩展性和稳定性有更高要求，就需要更为成熟的平台了。&lt;/p&gt;

&lt;h2 id=&quot;rabbitmq&quot;&gt;RabbitMQ&lt;/h2&gt;

&lt;p&gt;通过 homebrew 安装后。启动服务器：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/sbin/rabbitmq-server&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;创建 channel，无论成功与否都会触发回调函数。worker 和 producer 都会通过该方法连接队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const amqp = require(&amp;#39;amqplib/callback_api&amp;#39;);
const url = process.env.AMQP_URL || &amp;#39;amqp://guest:guest@localhost:5672&amp;#39;;

module.exports = createQueueChannel;

function createQueueChannel(queue, cb) {
    amqp.connect(url, onceConnected);

    function onceConnected(err, conn) {
        if (err) {
            console.error(&amp;#39;Error connecting:&amp;#39;, err.stack);
        }
        else {
            console.log(&amp;#39;connected&amp;#39;);
            conn.createChannel(onceChannelCreated);
        }

        function onceChannelCreated(err, channel) {
            if (err) {
                cb(err);
            }
            else {
                channel.assertQueue(queue, {durable: true}, onceQueueCreated);
            }

            function onceQueueCreated(err) {
                if (err) {
                    cb(err);
                }
                else {
                    cb(null, channel, conn);
                }
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于 producer 而言，需要连接 channel，然后向队列发送消息，随后断开连接：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const Channel = require(&amp;#39;./channel&amp;#39;);
const QUEUE = &amp;#39;queue&amp;#39;;

Channel(QUEUE, (err, channel, conn) =&amp;gt; {
    if (err) {
        console.error(err.stack);
    }
    else {
        console.log(&amp;#39;channel and queue created&amp;#39;);
        let work = &amp;#39;make me a sandwich&amp;#39;;
        channel.sendToQueue(QUEUE, encode(work), {
            persistent: true
        });
        setImmediate(() =&amp;gt; {
            channel.close();
            conn.close();
        });
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而对于每一个 worker，连接成功后，取出队列中的消息内容载荷进行消费，完成后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ack()&lt;/code&gt;通知队列，继续消费下一个消息。而如果队列为空，通过定时器在一定延迟后继续消费。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Channel(QUEUE, (err, channel, conn) =&amp;gt; {
    if (err) {
        console.error(err.stack);
    }
    else {
        console.log(&amp;#39;channel and queue created&amp;#39;);
        consume();
    }

    function consume() {
        channel.get(QUEUE, {}, onConsume);

        function onConsume(err, msg) {
            if (err) {
                console.warn(err.message);
            }
            else if (msg) {
                console.log(&amp;#39;consuming %j&amp;#39;, msg.content.toString());
                setTimeout(() =&amp;gt; {
                    channel.ack(msg);
                    consume();
                }, 1e3);
            }
            else {
                console.log(&amp;#39;no message, waiting...&amp;#39;);
                setTimeout(consume, 1e3);
            }
        }
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.yld.io/2016/05/10/introducing-queues/#.Wb4dqHeg_2Q&quot;&gt;YLD博客的系列文章&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rabbitmq.com/documentation.html&quot;&gt;RabbitMQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 17 Sep 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html</guid>
        
        <category>javascript</category>
        
        <category>nodejs</category>
        
        <category>leveldb</category>
        
        <category>redis</category>
        
        <category>rabbitMQ</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>判断元素是否在视口内</title>
        <description>&lt;p&gt;在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function inViewport( el, h ) {
    var elH = el.offsetHeight, // 元素高度
        scrolled = scrollY(), // 视口顶部距离document顶部的距离
        viewed = scrolled + getViewportH(), // 视口底部距离document的距离
        elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离
        elBottom = elTop + elH, // 元素底部距离document顶部的距离
        h = h || 0; // 高度系数
    return (elTop + elH * h) &amp;lt;= viewed &amp;amp;&amp;amp; (elBottom) &amp;gt;= scrolled;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方法的问题是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;读取元素尺寸数据时，会造成 re-layout，在滚动过程中会导致页面卡顿(jank)。&lt;/p&gt;

&lt;h2 id=&quot;intersectionobserver&quot;&gt;IntersectionObserver&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wicg.github.io/IntersectionObserver/&quot;&gt;IntersectionObserver&lt;/a&gt; 作为新引入的 API，异步查询元素相对于另一个元素（例如视口）的位置，不会影响主线程，可以解决检测方法带来的性能问题。&lt;/p&gt;

&lt;p&gt;首先我们需要创建一个观察对象，构造函数方法签名如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;new IntersectionObserver(entries =&amp;gt; {}, options);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随后将使用这个观察对象对元素的位置变化进行观测：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;io.observe(element);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;观察对象构造函数的第一个参数便是回调函数，这能避免旧方法中轮询带来的性能问题。
在回调函数中，传入的参数是一个数组（可以观测多个元素），每个元素对象包含以下属性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootBounds&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientRect&lt;/code&gt;对象，等同于对根元素（默认值为视口）调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;boundingClientRect&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientRect&lt;/code&gt;对象，等同于对被观测元素调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;intersectionRect&lt;/code&gt;，以上两个矩形的交集&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;intersectionRatio&lt;/code&gt;，被观测元素被覆盖的比例，如下图所示：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/intersectratio.png&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/intersectratio.png&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();
        }
    });
&lt;/script&gt;

&lt;p&gt;现在来看看观察对象的第二个参数，这是一个配置对象，其中包含3个重要的配置项：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;，默认值为视口，在容器内滚动的场景中，我们可以指定根元素为容器&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootMargin&lt;/code&gt;，顾名思义，值的格式与&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;一样&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threshold&lt;/code&gt;，这个阈值甚至可以是一个列表，每次达到其中的一个阈值时都会触发回调函数，取值范围为[0-1]&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;observe()&lt;/code&gt;观测方法，自然也有解除观测方法&lt;code class=&quot;highlighter-rouge&quot;&gt;unobserve()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上就是这个新 API 的全部内容了，下面让我们看看在实际场景中如何应用吧。&lt;/p&gt;

&lt;h2 id=&quot;懒加载图片&quot;&gt;懒加载图片&lt;/h2&gt;

&lt;p&gt;有了这个新的 API，实现滚动到视口内加载图片就十分简单了，其实就是多了新的判断方法，不再需要在滚动事件中获取了。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 创建观测对象
let observer = new IntersectionObserver(entries =&amp;gt; {
    entries.forEach(entry =&amp;gt; {
        // 图片和视口有交集了
        if (entry.intersectionRatio &amp;gt; 0) {
            // 停止继续观测，直接加载
            observer.unobserve(entry.target);
            loadImage(entry.target);
        }
    });
}, {threshold: 0.01});

// 观测所有图片
images.forEach(image =&amp;gt; {
    observer.observe(image);
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，这里还有一些细节，例如：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;考虑浏览器兼容性，目前&lt;a href=&quot;https://caniuse.com/#feat=intersectionobserver&quot;&gt;最新版 Chrome 和 Firefox 支持&lt;/a&gt;良好。&lt;a href=&quot;https://github.com/WICG/IntersectionObserver/tree/gh-pages/polyfill&quot;&gt;polyfill&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;图片的 src 属性存放在例如 data-src 上&lt;/li&gt;
  &lt;li&gt;全部图片加载完毕，调用观测对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;disconnect()&lt;/code&gt;方法彻底关闭&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以参考&lt;a href=&quot;https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163&quot;&gt;这篇文章&lt;/a&gt;的实现。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2016/04/intersectionobserver&quot;&gt;Google Developer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hacks.mozilla.org/2017/08/intersection-observer-comes-to-firefox/&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163&quot;&gt;懒加载图片文章&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html</guid>
        
        <category>javascript</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>在 jekyll 中使用代码高亮</title>
        <description>&lt;p&gt;代码高亮是一个技术博客的重要特性，Jekyll 中默认使用&lt;a href=&quot;http://jekyllrb.com/docs/templates/#code-snippet-highlighting&quot;&gt; Rouge&lt;/a&gt;进行词法分析生成 DOM 结构，搭配自定义样式。使用 Python 编写的&lt;a href=&quot;http://pygments.org/&quot;&gt; Pygments&lt;/a&gt;也是一个可选方案。&lt;/p&gt;

&lt;p&gt;博客作者可以使用如下 markdown 语法插入代码块，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;linenos&lt;/code&gt;表示显示行号：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;\{\% highlight ruby linenos %}
    def foo
      puts &amp;#39;foo&amp;#39;
    end
    \{\% endhighlight %}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本来我是采用默认的 Rouge，但是发现样式有点丑，尤其是行号部分。而且有时我需要高亮显示若干行代码，例如这样：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;\{\% highlight ruby linenos=1-2 %}
    def foo
      puts &amp;#39;foo&amp;#39;
    end
    \{\% endhighlight %}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时 Rouge 就做不到了，而且 Rouge 和 Pygments 似乎很久没有更新了，想找一个漂亮的样式也不容易。&lt;/p&gt;

&lt;p&gt;我在网上搜了一下，发现了&lt;a href=&quot;http://prismjs.com/&quot;&gt; Prism&lt;/a&gt;这样一个库。MDN，Smashing magazine 很多技术网站都在使用，难怪样式看着有点眼熟。那么如何在 jekyll 中使用呢？&lt;/p&gt;

&lt;h2 id=&quot;编写-jekyll-插件&quot;&gt;编写 jekyll 插件&lt;/h2&gt;

&lt;p&gt;参考 Prism 文档，在项目中引入定制后的 JS 和 CSS 文件都很简单。值得一提的是之前提过的高亮特定行数的代码，可以通过&lt;a href=&quot;http://prismjs.com/plugins/line-highlight/&quot;&gt; Prism 插件&lt;/a&gt;实现。所以我们只需要关注如何通过 jekyll 插件将 markdown 代码块转换成对应的 HTML 代码即可。&lt;/p&gt;

&lt;p&gt;之前介绍过如何在&lt;a href=&quot;/coding/2017/07/22/%E5%9C%A8GithubPages%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6.html&quot;&gt; Github Pages 中使用第三方插件&lt;/a&gt;。由于我的博客在本地进行编译，所以只需要将插件放在&lt;code class=&quot;highlighter-rouge&quot;&gt;_plugins&lt;/code&gt;文件夹下即可。&lt;/p&gt;

&lt;p&gt;我搜索到一个&lt;a href=&quot;https://github.com/gmurphey/jekyll-prism-plugin&quot;&gt; jekyll 插件&lt;/a&gt;，已经很久没有维护了，ISSUE 也很久没有回复。看了代码后决定在此基础上进行修改，顺便学习一下自定义插件的相关知识。&lt;/p&gt;

&lt;h3 id=&quot;liquid&quot;&gt;Liquid&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; 是使用 Ruby 编写的模版引擎。jekyll 使用它进行 markdown 语法的解析。通过继承 Liquid 内部封装的类，可以自定义我们的语法块。&lt;/p&gt;

&lt;p&gt;以下是声明和注册代码，继承&lt;a href=&quot;http://www.rubydoc.info/gems/liquid/Liquid/Block&quot;&gt; Block&lt;/a&gt;而非 Tag 的原因很简单，我们需要使用闭合标签，类似&lt;code class=&quot;highlighter-rouge&quot;&gt;\{\% endprism %}&lt;/code&gt;，否则一旦解析到闭合标签就会报错了。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;2,11&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Jekyll
  class PrismBlock &amp;lt; Liquid::Block
    include Liquid::StandardFilters
    def initialize(tag_name, markup, tokens)
        super
    end

    def render(context)
    end
end
Liquid::Template.register_tag(&amp;#39;prism&amp;#39;, Jekyll::PrismBlock)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码中还引入了&lt;code class=&quot;highlighter-rouge&quot;&gt;StandardFilters&lt;/code&gt;，这个后续在输出 HTML 时会使用。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;3&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Jekyll
  class PrismBlock &amp;lt; Liquid::Block
    include Liquid::StandardFilters
end
Liquid::Template.register_tag(&amp;#39;prism&amp;#39;, Jekyll::PrismBlock)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;真正的处理逻辑将在两个方法：构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;initialize()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt;中完成。&lt;/p&gt;

&lt;h3 id=&quot;解析行号&quot;&gt;解析行号&lt;/h3&gt;

&lt;p&gt;通过方法签名&lt;code class=&quot;highlighter-rouge&quot;&gt;initialize(tag_name, markup, tokens)&lt;/code&gt;可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;markup&lt;/code&gt;包含了代码语言和行号的声明。解析工作交给正则完成：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;`OPTIONS_SYNTAX = %r{^([a-zA-Z0-9.+#-]+)((\s+\w+(=[0-9,-]+)?)*)$}`
markup.strip =~ OPTIONS_SYNTAX&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以对于&lt;code class=&quot;highlighter-rouge&quot;&gt;\{\% prism ruby linenos=2,11-13 %}&lt;/code&gt;这样的代码块声明，我们能够得到语言&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby&lt;/code&gt;，行号&lt;code class=&quot;highlighter-rouge&quot;&gt;linenos=2,11-13&lt;/code&gt;。这部分基本不需要做修改，相关代码就不贴了。&lt;/p&gt;

&lt;h3 id=&quot;输出-html&quot;&gt;输出 HTML&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt;函数十分简单，我们按照 Prism 接受的 HTML 结构输出即可，这里我根据&lt;code class=&quot;highlighter-rouge&quot;&gt;linenos&lt;/code&gt;决定是否展示全部行号，另外通过&lt;code class=&quot;highlighter-rouge&quot;&gt;data-line&lt;/code&gt;配合 Prism 插件实现高亮特定行：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;# 转义内容
code = h(super).strip
linenos = &amp;#39;&amp;#39;
linenos_content = @options[&amp;quot;linenos&amp;quot;]
if !linenos_content.nil?
    linenos = &amp;quot;class=&amp;#39;line-numbers&amp;#39; data-line=&amp;#39;#{linenos_content}&amp;#39;&amp;quot;
end
# 返回 HTML 内容
&amp;lt;&amp;lt;-HTML
    &amp;lt;div&amp;gt;
      &amp;lt;pre #{linenos}&amp;gt;&amp;lt;code class=&amp;#39;language-#{@lang}&amp;#39;&amp;gt;#{code}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
    &amp;lt;/div&amp;gt;
HTML&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上代码有两点需要注意：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;类似 JS 中的字符串模版功能，Ruby 中也有类似的语法，在上面最终输出 HTML 内容中有使用，但是必须使用双引号包裹。&lt;/li&gt;
  &lt;li&gt;转义标签內的代码内容使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;h()&lt;/code&gt;函数，还记得开头引入的 StandardFilters 嘛，&lt;code class=&quot;highlighter-rouge&quot;&gt;h()&lt;/code&gt;是里面&lt;code class=&quot;highlighter-rouge&quot;&gt;escape()&lt;/code&gt;的&lt;a href=&quot;https://github.com/Shopify/liquid/blob/master/lib/liquid/standardfilters.rb#L35-L38&quot;&gt;同名函数&lt;/a&gt;。这个函数接受输入流（这里就是代码块内容），返回解析后的 HTML 字符串。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;深刻感觉到 jekyll 用的人真的不多了，很多插件都处于无人维护的状态。&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/08/10/%E5%9C%A8jekyll%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/08/10/%E5%9C%A8jekyll%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.html</guid>
        
        <category>ruby</category>
        
        <category>jekyll</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>垃圾围城</title>
        <description>&lt;p&gt;前两天听《反派影评》，节目里说到西宁 FIRST 电影展播放了纪录片《塑料王国》完整版。很早之前我看过半小时的&lt;a href=&quot;https://www.youtube.com/watch?v=TUmuOmEqXZQ&quot;&gt;媒体版本&lt;/a&gt;，但现在豆瓣此片的页面已经没了，据说影展结束后也不允许媒体再提这部片子。&lt;/p&gt;

&lt;div class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/plastic-china-post.jpg&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/plastic-china-post.jpg&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();
        }
    });
&lt;/script&gt;

&lt;p&gt;在我看的半小时版本中，影片讲述了大量“洋垃圾”漂洋过海来到中国某个小山村，村民们在及其恶劣的环境中，使用及其原始的方式手工进行分拣。整个村子的环境也被破坏。最震撼的一幕就是孩子们在垃圾堆中玩耍，其中一个随手捡起一个注射器就吸里面的水。&lt;/p&gt;

&lt;div class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/plastic-china.jpg&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/plastic-china.jpg&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();
        }
    });
&lt;/script&gt;

&lt;p&gt;这个版本并没有类似抨击政府不作为这样的激进作者表达，只是希望唤起社会对这些分拣垃圾村民的关注，而且国家已经出台法律禁止进口这些“洋垃圾”，所以被禁播很让人费解，到底在担心什么呢？&lt;/p&gt;

&lt;p&gt;不过相比《塑料王国》，导演王久良之前的另一部&lt;a href=&quot;https://www.youtube.com/watch?v=7zZ2K1rrqpE&quot;&gt;《垃圾围城》&lt;/a&gt;就没有这么克制了，直接将矛头对准了北京的垃圾处理机制。&lt;/p&gt;

&lt;p&gt;北京被周边的几百个垃圾处理场包围。人们从大山中开采城市化需要的砂石，挖出一个个大坑，然后将城市产生的垃圾回填。垃圾填埋场周边的地下地上水源都遭到了不同程度的污染。&lt;/p&gt;

&lt;div class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/garbage.jpg&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/garbage.jpg&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();
        }
    });
&lt;/script&gt;

&lt;p&gt;随着城市的不断扩张，终于需要在垃圾场上建起学校，廉租房。看着挖开地基后，显露出的一层层厚厚的垃圾，不禁让人感慨，曾经被我们丢弃的垃圾，换了一种面目又回到了我们身边。&lt;/p&gt;

&lt;p&gt;在影片中，作者看着被严重污染的通榆河，感慨为了解决北京的缺水问题，我们实现了南水北调，却对身边的水源毫不珍惜。从谷歌地图的历史照片中可以发现短短几年间，几片水域的颜色就由绿变黑。&lt;/p&gt;

&lt;p&gt;有一群人不得不终日与垃圾为邻，那就是来自全国各地的拾荒者。他们用垃圾中的建筑材料盖起了简易窝棚，从中获取衣物甚至是食物，将手工分拣出来的材料低价卖给回收站。&lt;/p&gt;

&lt;p&gt;我其实很好奇，对于这些垃圾，国际上先进的方法到底是什么，难道只有填埋这一种么。&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/movie/2017/08/05/%E5%9E%83%E5%9C%BE%E5%9B%B4%E5%9F%8E.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/movie/2017/08/05/%E5%9E%83%E5%9C%BE%E5%9B%B4%E5%9F%8E.html</guid>
        
        <category>movie</category>
        
        
        <category>movie</category>
        
      </item>
    
      <item>
        <title>浏览器的恢复滚动行为</title>
        <description>&lt;p&gt;平常使用浏览器的后退功能时，常常会发现返回的页面滚动到了之前的位置，而不是简单的回到顶部。这是由于浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。值得一提的是，在&lt;a href=&quot;http://www.w3.org/TR/html51/browsers.html#history&quot;&gt; HTML History Spec&lt;/a&gt;中并没有强制要求浏览器记录与恢复滚动距离。在传统的页面中，这一默认行为非常贴心，但是在 SPA 中存在以下问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;浏览器试图恢复滚动距离时，页面可能还没有加载完毕，可能存在异步加载的部分。这样恢复之后，页面会出现跳动。&lt;/li&gt;
  &lt;li&gt;点击链接进入页面就不会应用恢复滚动这一行为。对于开发者而言，希望提供统一的恢复滚动实现，而不是后退等历史记录这部分依赖浏览器。&lt;/li&gt;
  &lt;li&gt;浏览器的滚动行为让开发者无法实现滚动过程的动画。而且对于容器内滚动的设计，浏览器是无法帮助恢复的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;按照&lt;a href=&quot;https://majido.github.io/scroll-restoration-proposal/&quot;&gt;《浏览器恢复滚动提案》&lt;/a&gt;的介绍，针对这一问题，现在常见的解决方案包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不使用 body 滚动，采用容器内滚动的方式。但显然，这样会丢失一部分浏览器默认行为，例如滑动隐藏顶部地址栏。&lt;/li&gt;
  &lt;li&gt;在浏览器恢复滚动行为之后，进行第二次滚动。缺点是会有明显的用户感知。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;疑似方案&quot;&gt;疑似方案？&lt;/h2&gt;

&lt;p&gt;话说我们能监听到浏览器恢复滚动的行为么？&lt;/p&gt;

&lt;p&gt;浏览器恢复滚动时会触发 scroll 事件。但这里涉及到 scroll 和 popState 事件的触发顺序。Chrome 在恢复滚动之前会先触发 popState 事件，这就意味着我们可以在此时记录下页面的滚动距离，然后触发 scroll 时我们就能使用类似&lt;code class=&quot;highlighter-rouge&quot;&gt;window.scrollTo&lt;/code&gt;来手动恢复了。但是 Firefox 刚好相反，这样在 popState 中我们已经无法获取旧的滚动距离了，因为浏览器已经自动恢复了。&lt;/p&gt;

&lt;p&gt;事实上，在前端路由的设计中，通常都包含 hash 和 History 模式。在&lt;a href=&quot;https://github.com/ReactTraining/react-router/issues/707&quot;&gt; react-router的这个 ISSUE&lt;/a&gt;中，列举了 hashchange/popState 与 scroll 事件在 Chrome/Firefox 中的触发顺序，可以看出并不统一。
所以这个方案至少在兼容性上并不可行。&lt;/p&gt;

&lt;h2 id=&quot;引入新的-api&quot;&gt;引入新的 API&lt;/h2&gt;

&lt;p&gt;为了让开发者能够通过编程方式关闭这一浏览器行为，&lt;a href=&quot;https://majido.github.io/scroll-restoration-proposal/&quot;&gt;《浏览器恢复滚动提案》&lt;/a&gt;引入了新的 API：&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;if (&amp;#39;scrollRestoration&amp;#39; in history) {
    // 默认值为&amp;#39;auto&amp;#39;
    history.scrollRestoration = &amp;#39;manual&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据&lt;a href=&quot;https://developers.google.com/web/updates/2015/09/history-api-scroll-restoration&quot;&gt; Google 开发者文档&lt;/a&gt;，Chrome 46 以上已经实装。&lt;/p&gt;

&lt;p&gt;我自己也写了一个 demo 测试了一下确实可行，这或许才是最好的解决方案，等待其他浏览器厂商支持吧。&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%81%A2%E5%A4%8D%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%81%A2%E5%A4%8D%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA.html</guid>
        
        <category>browser</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>为vue项目添加骨架屏</title>
        <description>&lt;p&gt;前段时间阅读了&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/&quot;&gt;饿了么的 PWA 升级实践&lt;/a&gt;一文，受益匪浅。其中&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/#在构建时使用-vue-预渲染骨架屏&quot;&gt;构建时使用 Vue 预渲染骨架屏&lt;/a&gt;一节，为开发者提供了减少白屏时间，提升用户感知体验的新思路。本文将借鉴这一思路，尝试为 Vue 项目添加骨架屏。&lt;/p&gt;

&lt;h2 id=&quot;骨架屏是什么&quot;&gt;骨架屏是什么？&lt;/h2&gt;

&lt;p&gt;在 Google 提出的&lt;a href=&quot;https://developers.google.com/web/updates/2017/06/user-centric-performance-metrics&quot;&gt;以用户为中心&lt;/a&gt;的四个页面性能衡量指标中，FP/FCP(首屏渲染)可能是开发者最熟悉的了。下图来自&lt;a href=&quot;https://developers.google.com/web/updates/2017/06/user-centric-performance-metrics&quot;&gt;原文&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://developers.google.com/web/updates/images/2017/06/perf-metrics-load-timeline.png&quot; alt=&quot;google页面在各个阶段的截屏&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于尽快渲染出首屏，减少白屏时间，我能想到的优化方式大致有以下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优化 &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/&quot;&gt;Critical Rendering Path(关键渲染路径)&lt;/a&gt;，尽可能减少阻塞渲染的 JavaScript 和 CSS。常见做法包括使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;async/defer&lt;/code&gt; 让浏览器下载 JavaScript 的同时不阻塞 HTML 解析，内联页面关键部分的样式到 HTML 中等。&lt;/li&gt;
  &lt;li&gt;使用 Service Worker 缓存&lt;a href=&quot;https://developers.google.com/web/updates/2015/11/app-shell&quot;&gt; AppShell&lt;/a&gt;，加快后续访问速度。&lt;/li&gt;
  &lt;li&gt;使用 HTTP/2 Server Push，帮助浏览器尽早发现静态资源，减少请求数。&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26757514&quot;&gt;浅谈 HTTP/2 Server Push&lt;/a&gt;一文介绍了 Ele.me 在这方面的实践，推送 API 请求而非静态资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;骨架屏充分利用了前两点。下图来自原文&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/#为感知体验奋斗&quot;&gt;为感知体验奋斗&lt;/a&gt;一节。从图中的 Skeleton Screen (骨架屏)中可以看出，在页面完全渲染完成之前，用户会看到一个样式简单，描绘了当前页面的大致框架，感知到页面正在逐步加载，最终骨架屏中各个占位部分被完全替换，体验良好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://huangxuan.me/img/in-post/post-eleme-pwa/after-skeleton.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;骨架屏可以看成一个简单的关键渲染路径，由于只是页面的大致框架，样式不会太复杂，内联在 HTML 中体积很小。使用 Service Worker 缓存包含骨架屏的 HTML 页面之后，从缓存中取出展示速度更快。&lt;/p&gt;

&lt;h2 id=&quot;实现思路&quot;&gt;实现思路&lt;/h2&gt;

&lt;p&gt;参考原文中&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/#在构建时使用-vue-预渲染骨架屏&quot;&gt;在构建时使用 Vue 预渲染骨架屏&lt;/a&gt;一节介绍的思路，我将骨架屏也看成路由组件，在构建时使用 Vue 预渲染功能，将骨架屏组件的渲染结果 HTML 片段插入 HTML 页面模版的挂载点中，将样式内联到 head 标签中。这样等前端渲染完成时，Vue 将使用&lt;a href=&quot;https://ssr.vuejs.org/zh/hydration.html&quot;&gt;客户端混合&lt;/a&gt;，把挂载点中的骨架屏内容替换成真正的页面内容。&lt;/p&gt;

&lt;p&gt;有了以上思路，让我们看看如何为一个简单的 Vue 应用添加骨架屏。&lt;/p&gt;

&lt;h2 id=&quot;具体实现&quot;&gt;具体实现&lt;/h2&gt;

&lt;p&gt;为此我开发了一个 webpack 插件：&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin&quot;&gt;vue-skeleton-webpack-plugin&lt;/a&gt;。下面将从以下三方面介绍部分实现细节：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用 Vue 预渲染骨架屏&lt;/li&gt;
  &lt;li&gt;将骨架屏渲染结果插入 HTML 模版中&lt;/li&gt;
  &lt;li&gt;开发模式下插入各个骨架屏路由&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用-vue-预渲染骨架屏&quot;&gt;使用 Vue 预渲染骨架屏&lt;/h3&gt;

&lt;p&gt;我们使用 Vue 的&lt;a href=&quot;https://ssr.vuejs.org/zh/&quot;&gt;预渲染&lt;/a&gt;功能渲染骨架屏组件，不熟悉的同学可以先阅读官方文档中的&lt;a href=&quot;https://ssr.vuejs.org/zh/basic.html&quot;&gt;基本用法&lt;/a&gt;一节。&lt;/p&gt;

&lt;p&gt;首先需要创建一个仅使用骨架屏组件的入口文件：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// src/entry-skeleton.js

import Skeleton from &amp;#39;./Skeleton.vue&amp;#39;;
// 创建一个骨架屏 Vue 实例
export default new Vue({
    components: {
        Skeleton
    },
    template: &amp;#39;&amp;lt;skeleton /&amp;gt;&amp;#39;
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来创建一个用于服务端渲染的 webpack 配置对象，将刚创建的入口文件指定为 entry 依赖入口：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack.skeleton.conf.js
{
    target: &amp;#39;node&amp;#39;, // 区别默认的 &amp;#39;web&amp;#39;
    entry: resolve(&amp;#39;./src/entry-skeleton.js&amp;#39;), // 多页传入对象
    output: {
        libraryTarget: &amp;#39;commonjs2&amp;#39;
    },
    externals: nodeExternals({
        whitelist: /\.css$/
    }),
    plugins: []
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里只展示单页应用的情况，在多页应用中，指定 entry 为包含各个页面入口的对象即可。关于多页中的 webpack 配置对象示例，可参考&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/tree/master/examples/multipage&quot;&gt;插件的多页测试用例&lt;/a&gt;或者&lt;a href=&quot;https://github.com/lavas-project/lavas-template-vue-mpa&quot;&gt;Lavas MPA 模版&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后我们将这个 webpack 配置对象通过参数传入骨架屏插件中。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack.dev.conf.js
plugins: [
    new SkeletonWebpackPlugin({ // 我们编写的插件
        webpackConfig: require(&amp;#39;./webpack.skeleton.conf&amp;#39;)
    })
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;骨架屏插件运行时会使用 webpack 编译这个传入的配置对象，得到骨架屏的 bundle 文件。接下来只需要使用这个 bundle 文件内容创建一个 renderer，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;renderToString()&lt;/code&gt;方法就可以得到字符串形式的 HTML 渲染结果了。由于我们不需要将过程中的文件产物保存在硬盘中，使用内存文件系统&lt;a href=&quot;https://github.com/webpack/memory-fs&quot;&gt;memory-fs&lt;/a&gt;即可。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// vue-skeleton-webpack-plugin/src/ssr.js

const createBundleRenderer = require(&amp;#39;vue-server-renderer&amp;#39;).createBundleRenderer;
// 从内存文件系统中读取 bundle 文件
let bundle = mfs.readFileSync(outputPath, &amp;#39;utf-8&amp;#39;);
// 创建 renderer
let renderer = createBundleRenderer(bundle);
// 渲染得到 HTML
renderer.renderToString({}, (err, skeletonHtml) =&amp;gt; {});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认情况下，webpack 模块引用的样式内容是内嵌在 JavaScript bundle 中的。官方插件&lt;a href=&quot;https://github.com/webpack-contrib/extract-text-webpack-plugin&quot;&gt; ExtractTextPlugin&lt;/a&gt;可以进行样式分离。我们也使用这个插件，将骨架屏样式内容输出到单独的 CSS 文件中。
关于插件更多用法，可参考&lt;a href=&quot;https://doc.webpack-china.org/plugins/extract-text-webpack-plugin/&quot;&gt;官方文档&lt;/a&gt;或者&lt;a href=&quot;https://github.com/vuejs-templates/webpack/blob/master/template/build/utils.js&quot;&gt; Vue 基于 webpack 的模版&lt;/a&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// vue-skeleton-webpack-plugin/src/ssr.js

// 加入 ExtractTextPlugin 插件到 webpack 配置对象插件列表中
serverWebpackConfig.plugins.push(new ExtractTextPlugin({
    filename: outputCssBasename // 样式文件名
}));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，我们已经得到了骨架屏的渲染结果 HTML 和样式内容，接下来需要关心如何将结果注入 HTML 页面模版中。&lt;/p&gt;

&lt;h3 id=&quot;注入渲染结果&quot;&gt;注入渲染结果&lt;/h3&gt;

&lt;p&gt;Vue webpack 模版项目使用了&lt;a href=&quot;https://github.com/jantimon/html-webpack-plugin&quot;&gt; HTML Webpack Plugin&lt;/a&gt;生成 HTML 文件。参考该插件的&lt;a href=&quot;https://github.com/jantimon/html-webpack-plugin#events&quot;&gt; 事件说明&lt;/a&gt;，我们选择监听&lt;code class=&quot;highlighter-rouge&quot;&gt;html-webpack-plugin-before-html-processing&lt;/code&gt;事件，在事件的回调函数中，插件会传入当前待处理的 HTML 内容供我们进一步修改。&lt;/p&gt;

&lt;p&gt;我们知道骨架屏组件最终的渲染结果包含 HTML 和样式两部分，样式部分可以直接插入 head 标签內，而 HTML 需要插入挂载点中。插件使用者可以通过参数设置这个挂载点位置，默认将使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;看起来一切都很顺利，但是在多页应用中，情况会变的稍稍复杂。多页项目中通常会引入多个 HTML Webpack Plugin，例如我们在&lt;a href=&quot;https://github.com/lavas-project/lavas-template-vue-mpa&quot;&gt; Lavas MPA 模版&lt;/a&gt;中使用的&lt;a href=&quot;https://github.com/mutualofomaha/multipage-webpack-plugin&quot;&gt; Multipage Webpack 插件&lt;/a&gt;就是如此，这就会导致&lt;code class=&quot;highlighter-rouge&quot;&gt;html-webpack-plugin-before-html-processing&lt;/code&gt;事件被多次触发。&lt;/p&gt;

&lt;p&gt;在多页应用中，我们传给骨架屏插件的 webpack 配置对象是包含多个入口的：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack.skeleton.conf.js
entry: {
    page1: resolve(&amp;#39;./src/pages/page1/entry-skeleton.js&amp;#39;),
    page2: resolve(&amp;#39;./src/pages/page2/entry-skeleton.js&amp;#39;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这就意味着每次&lt;code class=&quot;highlighter-rouge&quot;&gt;html-webpack-plugin-before-html-processing&lt;/code&gt;事件触发时，骨架屏插件都需要识别出当前正在处理的入口文件，执行 webpack 编译当前页面对应的骨架屏入口文件，渲染对应的骨架屏组件。查找当前处理的入口文件过程如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// vue-skeleton-webpack-plugin/src/index.js

// 当前页面使用的所有 chunks
let usedChunks = htmlPluginData.plugin.options.chunks;
let entryKey;
// chunks 和所有入口文件的交集就是当前待处理的入口文件
if (Array.isArray(usedChunks)) {
    entryKey = Object.keys(skeletonEntries);
    entryKey = entryKey.filter(v =&amp;gt; usedChunks.indexOf(v) &amp;gt; -1)[0];
}
// 设置当前的 webpack 配置对象的入口文件和结果输出文件
webpackConfig.entry = skeletonEntries[entryKey];
webpackConfig.output.filename = `skeleton-${entryKey}.js`;
// 使用配置对象进行服务端渲染
ssr(webpackConfig).then(({skeletonHtml, skeletonCss}) =&amp;gt; {
    // 注入骨架屏 HTML 和 CSS 到页面 HTML 中
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，我们已经完成了骨架屏的渲染和注入工作，接下来有一个开发中的小问题需要关注。&lt;/p&gt;

&lt;h3 id=&quot;开发模式下插入路由&quot;&gt;开发模式下插入路由&lt;/h3&gt;

&lt;p&gt;前面说过，由于 Vue 会使用&lt;a href=&quot;https://ssr.vuejs.org/zh/hydration.html&quot;&gt;客户端混合&lt;/a&gt;，骨架屏内容在前端渲染完成后就会被替换，那么如何在开发时方便的查看调试呢？&lt;/p&gt;

&lt;p&gt;使用浏览器开发工具设置断点是一个办法，但如果能在开发模式中向路由文件插入骨架屏组件对应的路由规则，使各个页面的骨架屏能像其他路由组件一样被访问，将使开发调试变得更加方便。向路由文件插入规则代码的工作将在&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/blob/master/src/loader.js&quot;&gt;插件的 loader&lt;/a&gt;中完成。如果您对 webpack loader 还不了解，可以参阅&lt;a href=&quot;https://doc.webpack-china.org/concepts/loaders/&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我们需要向路由文件插入两类代码：引入骨架屏组件的代码和对应的路由规则对象。关于代码插入点，引入组件代码相对简单，放在文件顶部就行了，而路由规则需要插入路由对象数组中，目前我使用的是简单的字符串匹配来查找这个数组的起始位置。例如下面的例子中，需要向 loader 传入&lt;code class=&quot;highlighter-rouge&quot;&gt;routes: [&lt;/code&gt;来确定插入路由的位置。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// router.js

import Skeleton from &amp;#39;@/pages/Skeleton.vue&amp;#39;
routes: [
    { // 插入骨架屏路由
        path: &amp;#39;/skeleton&amp;#39;,
        name: &amp;#39;skeleton&amp;#39;,
        component: Skeleton
    }
    // ...其余路由规则
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在多页应用中，每个页面对应的骨架屏都需要插入代码，使用者可以通过占位符设置引入骨架屏组件语句和路由规则的模版。loader 在运行时会使用这些模版，用真实的骨架屏名称替换掉占位符。在下面的例子中，假设我们有&lt;code class=&quot;highlighter-rouge&quot;&gt;Page1.skeleton.vue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Page2.skeleton.vue&lt;/code&gt;这两个骨架屏，开发模式下可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;/skeleton-page1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/skeleton-page2&lt;/code&gt;访问这两个骨架屏路由。更多参数说明可以参考&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin#参数说明&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack.dev.conf.js

module: {
    rules: [] // 其他规则
        .concat(SkeletonWebpackPlugin.loader({
            resource: resolve(&amp;#39;src/router.js&amp;#39;), // 目标路由文件
            options: {
                entry: [&amp;#39;page1&amp;#39;, &amp;#39;page2&amp;#39;], 
                importTemplate: &amp;#39;import [nameCap] from \&amp;#39;@/pages/[name]/[nameCap].skeleton.vue\&amp;#39;;&amp;#39;,
                routePathTemplate: &amp;#39;/skeleton-[name]&amp;#39;
            }
        }))
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;多页中的具体应用示例，可参考&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/tree/master/examples/multipage&quot;&gt;多页测试用例&lt;/a&gt;或者&lt;a href=&quot;https://github.com/lavas-project/lavas-template-vue-mpa&quot;&gt;Lavas MPA 模版&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;感谢&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/&quot;&gt;饿了么的 PWA 升级实践&lt;/a&gt;一文，提供了解决这个问题的思路。当然文章中包含的远不止骨架屏这方面，相信每个读者都会受益匪浅。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin&quot;&gt;插件&lt;/a&gt;使用中遇到任何问题，都欢迎提出&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/issues&quot;&gt; ISSUE&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;百度&lt;a href=&quot;https://lavas.baidu.com/&quot;&gt; Lavas&lt;/a&gt;是一个基于 Vue 的 PWA 解决方案，帮助开发者轻松搭建 PWA 站点。其中多个模版也使用了这个插件，欢迎大家试用并提出意见。&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/30/%E4%B8%BAvue%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E9%AA%A8%E6%9E%B6%E5%B1%8F.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/30/%E4%B8%BAvue%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E9%AA%A8%E6%9E%B6%E5%B1%8F.html</guid>
        
        <category>vue</category>
        
        <category>webpack</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>无用的keywords</title>
        <description>&lt;p&gt;我在博客中试用了一下&lt;a href=&quot;https://github.com/jekyll/jekyll-seo-tag/&quot;&gt; jekyll-seo-tag 插件&lt;/a&gt;。它会从 jekyll &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;配置文件中提取字段，生成机器可读的元数据，供搜索引擎和社交工具使用。&lt;/p&gt;

&lt;p&gt;包括以下字段，此时打开控制台也能看到本页面中&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!-- Begin Jekyll SEO tag v2.2.3 --&amp;gt;&lt;/code&gt;开始就是这个插件添加的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;title，页面标题加上站点名称&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=description&amp;gt;&lt;/code&gt; 目测是取内容第一段，这就意味着文章不能以&lt;code class=&quot;highlighter-rouge&quot;&gt;## 第一段标题&lt;/code&gt;这样开头了，否则&lt;code class=&quot;highlighter-rouge&quot;&gt;description&lt;/code&gt;中就只有&lt;code class=&quot;highlighter-rouge&quot;&gt;第一段标题&lt;/code&gt;这点内容了&lt;/li&gt;
  &lt;li&gt;Canonical URL 标准格式&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/structured-data/&quot;&gt;JSON-LD&lt;/a&gt;格式的站点数据，供搜索引擎使用&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ogp.me/&quot;&gt;Open Graph&lt;/a&gt;数据，供社交工具使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后我发现这里面居然不包括&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=keywords&amp;gt;&lt;/code&gt;，我之前一直认为这个标签在 SEO 中很重要。&lt;/p&gt;

&lt;p&gt;有相同疑问的肯定不止我一个，有人就对这个问题提出了&lt;a href=&quot;https://github.com/jekyll/jekyll-seo-tag/issues/9&quot;&gt;ISSUE&lt;/a&gt;。插件作者甩出了用 Google 搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;meta tags seo&lt;/code&gt;关键词的前两个链接，然后提问者就默默关闭了 ISSUE。&lt;/p&gt;

&lt;h2 id=&quot;无用的-keywords&quot;&gt;无用的 keywords&lt;/h2&gt;

&lt;p&gt;我看了下搜索结果中的&lt;a href=&quot;http://www.wordstream.com/meta-tags&quot;&gt;第一篇文章&lt;/a&gt;，这才恍然大悟。&lt;/p&gt;

&lt;p&gt;文章指出 Google 在 ranking 时，已经不考虑&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=keywords&amp;gt;&lt;/code&gt;这个标签了。原因是这个标签过去被滥用太多了，而且也很容易被滥用。。。&lt;/p&gt;

&lt;p&gt;但是 meta 家族中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=description&amp;gt;&lt;/code&gt;毕竟会被直接展示在搜索结果中，所以作为页面开发者不能忽略。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.wordstream.com/images/screenshots/meta-description-tag.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那 Baidu 是怎么做的呢？&lt;a href=&quot;https://www.quora.com/Is-the-meta-keyword-tag-a-factor-in-Baidu&quot;&gt;Quora上有相应的一个问题&lt;/a&gt;，里面有答主给出了一份巨详细的&lt;a href=&quot;http://www.dragonmetrics.com/baidu-seo-guide/&quot;&gt;研究报告&lt;/a&gt;，分成10个章节介绍百度的 SEO 问题。&lt;/p&gt;

&lt;p&gt;从&lt;a href=&quot;http://www.dragonmetrics.com/baidu-seo-guide/#ch1&quot;&gt;第一节&lt;/a&gt;的内容来看，Baidu 并没有完全放弃 keywords，并且疑似将 descripton 也纳入 ranking，虽然可能权重不一定很高。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;However, Baidu may still use meta keywords as a ranking signal. There is also some evidence that supports the possibility that meta descriptions may even affect rankings on Baidu, in addition to being used for the SERP snippet.&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 24 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/23/%E6%97%A0%E7%94%A8%E7%9A%84keywords.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/23/%E6%97%A0%E7%94%A8%E7%9A%84keywords.html</guid>
        
        <category>ruby</category>
        
        <category>jekyll</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>在Github Pages中使用第三方插件</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;能够帮助我们托管 jekyll 项目，我们只需要将代码提交到指定分支(master/gh-pages)，github 将自动完成构建。&lt;/p&gt;

&lt;p&gt;jekyll 项目不可避免的会使用各种各样的插件，而 Github Pages 目前仅支持到 jekyll 3.4.5 版本，新版本在&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;中对插件的使用方法发生了变更，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins&lt;/code&gt;代替旧版本的属性&lt;code class=&quot;highlighter-rouge&quot;&gt;gems&lt;/code&gt;。所以为了兼容 Github Pages，本地新版本的警告提示信息只能选择忽略了。&lt;/p&gt;

&lt;p&gt;和在本地构建不同的一点是，github 构建时会加上&lt;code class=&quot;highlighter-rouge&quot;&gt;--save&lt;/code&gt;参数，只运行&lt;a href=&quot;https://pages.github.com/versions/&quot;&gt;信任的插件&lt;/a&gt;。这就导致如果我们的博客使用了不在白名单中的插件，github 构建时就会提示警告（在项目标签页 Setting -&amp;gt; GitHub Pages 中），构建失败也就看不到最新的博客内容了。&lt;/p&gt;

&lt;p&gt;Github Pages 给出一种建议是，让用户在本地构建站点，然后仅将构建结果纳入版本控制，提交到指定分支。避免 github 构建，只需要在根目录下放一个空文件&lt;code class=&quot;highlighter-rouge&quot;&gt;.nojekyll&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;至于本地构建，熟悉 Node.js 的开发者完全可以采用 gulp/grunt 工作流，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt;构建站点，顺便还能做一些静态资源压缩的工作。我在网上找到一种使用 rakefile 的&lt;a href=&quot;https://www.sitepoint.com/jekyll-plugins-github/&quot;&gt;简单方法&lt;/a&gt;，决定一试。&lt;/p&gt;

&lt;h2 id=&quot;使用-rakefile-构建&quot;&gt;使用 Rakefile 构建&lt;/h2&gt;

&lt;p&gt;首先我们需要拷贝原有 repo 内容到一个新文件夹中，以后这个新文件夹将成为我们的工作文件夹。由于以后我们不会再在原有 repo 中进行写作，所以此时可以在 repo 中执行&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm -r ./&lt;/code&gt;清空所有版本控制。&lt;/p&gt;

&lt;p&gt;在新文件夹中增加 Rakefile，进行如下操作：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt;构建站点&lt;/li&gt;
  &lt;li&gt;清空真正的 repo 内容，拷贝&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt;文件夹内容到里面。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;GH_PAGES_DIR = &amp;quot;xiaoiver.github.io&amp;quot;

desc &amp;quot;Build Jekyll site and copy files&amp;quot;
task :build do
  system &amp;quot;jekyll build&amp;quot;
  system &amp;quot;rm -r ../#{GH_PAGES_DIR}/*&amp;quot; unless Dir[&amp;#39;../#{GH_PAGES_DIR}/*&amp;#39;].empty?
  system &amp;quot;cp -r _site/* ../#{GH_PAGES_DIR}/&amp;quot;
end&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Rakefile 只在构建时使用，所以需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;中过滤掉，避免拷贝到结果文件夹中：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-yml&quot;&gt;exclude: [Rakefile]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后回到 repo 中，提交修改即可。&lt;/p&gt;

&lt;h2 id=&quot;使用-gulp-工作流构建&quot;&gt;使用 gulp 工作流构建&lt;/h2&gt;

&lt;p&gt;例如这个基于 yeoman 的&lt;a href=&quot;https://github.com/nirgn975/generator-jekyll-starter-kit&quot;&gt;模版项目&lt;/a&gt;，包含了对 PWA 的支持。&lt;/p&gt;

&lt;p&gt;这个模版在构建时使用 gulp 通过 sw-precache 生成&lt;code class=&quot;highlighter-rouge&quot;&gt;service-worker.js&lt;/code&gt;，缓存&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt;文件夹内全部静态资源。同时也定义了其他 task 用于压缩静态文件。&lt;/p&gt;

&lt;p&gt;我在博客中也使用了这种方式。&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/22/%E5%9C%A8GithubPages%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/22/%E5%9C%A8GithubPages%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6.html</guid>
        
        <category>ruby</category>
        
        <category>jekyll</category>
        
        <category>github-pages</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>为npm包提供多入口</title>
        <description>&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;

&lt;p&gt;之前给&lt;a href=&quot;https://github.com/van-nguyen/webpack-cdn-plugin&quot;&gt;webpack-cdn-plugin&lt;/a&gt;提PR时，遇到这样一个问题，入口文件使用了部分 ES6 特性，而作者不想直接提供转译版本，这就导致在低版本 Node.js 环境无法直接运行。&lt;/p&gt;

&lt;p&gt;首先想到的办法是，能不能提供多个版本。但是&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;只能支持单文件，无法提供多入口供使用者根据自身环境选择。&lt;/p&gt;

&lt;p&gt;后来采用的做法是在入口文件中判断当前运行环境，使用动态&lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;来选择转译或非转译版本。等于说模块开发者需要判断使用者当前的运行环境，总感觉不太优雅。&lt;/p&gt;

&lt;p&gt;前段时间刚好看到&lt;a href=&quot;http://2ality.com/2017/04/setting-up-multi-platform-packages.html&quot;&gt;这一系列文章&lt;/a&gt;，里面针对这个问题给出了较为全面的解决方案。&lt;/p&gt;

&lt;h2 id=&quot;多种模块格式版本&quot;&gt;多种模块格式版本&lt;/h2&gt;

&lt;p&gt;我们都知道模块格式包括了以下几种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AMD 浏览器端异步模块机制&lt;/li&gt;
  &lt;li&gt;CJS Node.js同步模块机制，浏览器端想使用必须先使用类似 webpack 之类的工具编译成异步的&lt;/li&gt;
  &lt;li&gt;ESM ES6提出的内置机制，支持同步和异步，部分浏览器已支持，Node.js 计划2018年实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为模块提供者，我们自然希望兼容更多模块格式，还好 UMD 提供了一系列兼容 AMD 和 CJS 的方案，例如支持&lt;a href=&quot;https://github.com/umdjs/umd/blob/master/templates/nodeAdapter.js&quot;&gt;在 Node.js 中写 AMD 标准的代码&lt;/a&gt;。这些模版范式为模块提供者提供了极大便利。&lt;/p&gt;

&lt;p&gt;是时候说说 ESM 了。它提供了统一的&lt;code class=&quot;highlighter-rouge&quot;&gt;import/export&lt;/code&gt;，真正统一了浏览器和 Node.js 端的模块标准。而且配合 Webpack 和 Rollup 提供的 &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;Tree-shaking&lt;/a&gt; 技术可以最大程度精简代码。那么问题来了，在 ESM 一统天下之前，如何提供使用 ESM 编写的代码给先进的打包工具，同时又不至于完全失去兼容性。换句话说，&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;中真的只有&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;这一个暴露模块入口文件的属性吗？&lt;/p&gt;

&lt;p&gt;显然不是，来看看这两个属性吧：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;module，还&lt;a href=&quot;https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md&quot;&gt;处于提案阶段&lt;/a&gt;，提供使用 ESM 编写的版本&lt;/li&gt;
  &lt;li&gt;browser，提供仅针对浏览器环境版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于打包工具来说，就不能只考虑&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;入口了。
在 webpack 中，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve.mainFields&lt;/code&gt;来指定模块查找优先级。
而这个优先级又是根据目标环境确定的，例如针对浏览器环境，即&lt;code class=&quot;highlighter-rouge&quot;&gt;target: 'web'&lt;/code&gt;，默认的优先级为：&lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;browser&quot;, &quot;module&quot;, &quot;main&quot;]&lt;/code&gt;。而服务端渲染中常用的&lt;code class=&quot;highlighter-rouge&quot;&gt;target: 'node'&lt;/code&gt;查找优先级为&lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;module&quot;, &quot;main&quot;]&lt;/code&gt;。可以看出，webpack 会优先使用 ESM 标准的代码。&lt;/p&gt;

&lt;p&gt;看起来支持不同模块格式的问题解决了。&lt;/p&gt;

&lt;h2 id=&quot;转译和非转译版本&quot;&gt;转译和非转译版本&lt;/h2&gt;

&lt;p&gt;除了支持不同的模块格式，代码中使用了新特性，是否需要转译也是一个问题。&lt;/p&gt;

&lt;p&gt;Angular 提出在&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;中新增&lt;code class=&quot;highlighter-rouge&quot;&gt;es2015&lt;/code&gt;属性，用来指定使用 ES6 的非转译代码入口。&lt;/p&gt;

&lt;p&gt;当然，最好能参考 babel-preset-env 的做法，也根据运行环境决定是否需要使用转译版本的代码。&lt;/p&gt;

&lt;h3 id=&quot;babel-preset-env&quot;&gt;babel-preset-env&lt;/h3&gt;

&lt;p&gt;首先看看&lt;code class=&quot;highlighter-rouge&quot;&gt;babel-preset-env&lt;/code&gt;是如何使用的。针对浏览器环境：&lt;/p&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&amp;quot;babel&amp;quot;: {
    &amp;quot;presets&amp;quot;: [
        [
            &amp;quot;env&amp;quot;,
            {
                &amp;quot;targets&amp;quot;: {
                    &amp;quot;browsers&amp;quot;: [&amp;quot;last 2 versions&amp;quot;, &amp;quot;ie &amp;gt;= 7&amp;quot;]
                }
            }
        ]
    ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;针对 Node.js 环境：&lt;/p&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&amp;quot;babel&amp;quot;: {
    &amp;quot;presets&amp;quot;: [
        [
            &amp;quot;env&amp;quot;,
            {
                &amp;quot;targets&amp;quot;: {
                    &amp;quot;node&amp;quot;: &amp;quot;current&amp;quot;
                }
            }
        ]
    ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他重要的参数包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;modules 默认CJS，不转译&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;useBuiltIns 使用polyfill，注入类似&lt;code class=&quot;highlighter-rouge&quot;&gt;import &quot;core-js/modules/es7.string.pad-start&quot;;&lt;/code&gt;的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;esnext&quot;&gt;esnext&lt;/h3&gt;

&lt;p&gt;增加一个新的入口&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;。直接提供支持 stage4 以上特性的代码，不使用转译，使用ESM：&lt;/p&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    ···
    &amp;quot;main&amp;quot;: &amp;quot;main.js&amp;quot;,
    &amp;quot;esnext&amp;quot;: {
        &amp;quot;main&amp;quot;: &amp;quot;main-esnext.js&amp;quot;,
        &amp;quot;browser&amp;quot;: &amp;quot;browser-specific-main-esnext.js&amp;quot;
    },
    ···
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://2ality.com/2017/06/pkg-esnext.html&quot;&gt;具体做法&lt;/a&gt;是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于模块开发者，提供非转译版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;对于使用者，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve.mainFields&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;加入，赋予最高优先级，同时告知 babel-loader 转译提供&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;的代码。剩下的就交给&lt;a href=&quot;http://2ality.com/2017/02/babel-preset-env.html&quot;&gt;babel-preset-env&lt;/a&gt;根据提供的配置环境自动引入需要的插件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;其他做法&quot;&gt;其他做法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;全部转译，耗时但是配置简单。webpack 插件大多采用这种方式。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/developit/081148d83348ebe9a1bc1ba0707e1bb8&quot;&gt;配置 babel-loader，只转译提供了 module 字段的依赖&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;根据文件后缀决定，&lt;code class=&quot;highlighter-rouge&quot;&gt;.js&lt;/code&gt;不转译，&lt;code class=&quot;highlighter-rouge&quot;&gt;.esm&lt;/code&gt;转译&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;作为模块提供者，我会采用&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;的方式，即额外提供非转译版本。然后让使用者通过配置，根据自身运行环境选择使用不同的版本。&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/17/%E4%B8%BAnpm%E5%8C%85%E6%8F%90%E4%BE%9B%E5%A4%9A%E5%85%A5%E5%8F%A3.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/17/%E4%B8%BAnpm%E5%8C%85%E6%8F%90%E4%BE%9B%E5%A4%9A%E5%85%A5%E5%8F%A3.html</guid>
        
        <category>javascript</category>
        
        <category>nodejs</category>
        
        <category>babel</category>
        
        <category>webpack</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>使用ava和travis-ci</title>
        <description>&lt;p&gt;最近给 &lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin&quot;&gt;skeleton 插件&lt;/a&gt;加上了测试用例，顺便使用了下自动集成工具。&lt;/p&gt;

&lt;h2 id=&quot;ava&quot;&gt;&lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;ava&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;首先配置基本参数：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;// package.json

&amp;quot;ava&amp;quot;: {
    &amp;quot;concurrency&amp;quot;: 5,
    &amp;quot;failFast&amp;quot;: true,
    &amp;quot;files&amp;quot;: [
      &amp;quot;test/*.test.js&amp;quot;
    ],
    &amp;quot;require&amp;quot;: [
      &amp;quot;babel-register&amp;quot;
    ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用方法也很简单：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;import test from &amp;#39;ava&amp;#39;;
test(&amp;#39;it should run successfully&amp;#39;, async t =&amp;gt; {
    let {stats, errors} = webpackBuildStats;
    t.falsy(stats.hasWarnings() &amp;amp;&amp;amp; errors.hasWarnings());
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行时除了会输出测试用例结果，还会输出一张代码覆盖率表格，并标出未覆盖的代码行号。
测试代码覆盖率其实很有用，出现很低的覆盖率要么是代码本身问题，要么是测试用例覆盖不全。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ava-log.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;travis-ci&quot;&gt;travis ci&lt;/h2&gt;

&lt;p&gt;使用持续集成工具，每次提交时自动运行测试脚本。&lt;/p&gt;

&lt;p&gt;首先需要有项目的owner权限，授权给travis。&lt;/p&gt;

&lt;p&gt;然后在配置文件中我们可以：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;设置多个 Node.js 版本环境&lt;/li&gt;
  &lt;li&gt;提供安装依赖和脚本，这里就直接运行测试命令了&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-yml&quot;&gt;//.travis.yml

language: node_js
node_js:
  - &amp;quot;4&amp;quot;
  - &amp;quot;5&amp;quot;
  - &amp;quot;6&amp;quot;
install:
  - npm install
script:
  - npm test&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完成后就可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;README.md&lt;/code&gt;里加上build图标了。&lt;img src=&quot;https://travis-ci.org/lavas-project/vue-skeleton-webpack-plugin.svg?branch=master&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/16/%E4%BD%BF%E7%94%A8ava%E5%92%8Ctravis-ci.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/16/%E4%BD%BF%E7%94%A8ava%E5%92%8Ctravis-ci.html</guid>
        
        <category>ava</category>
        
        <category>travis</category>
        
        
        <category>coding</category>
        
      </item>
    
  </channel>
</rss>
