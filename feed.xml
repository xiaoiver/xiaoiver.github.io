<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xiaOp的博客</title>
    <description>分享写代码，听音乐，看电影的心得
</description>
    <link>https://xiaoiver.github.io/</link>
    <atom:link href="https://xiaoiver.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 16 Oct 2017 19:18:14 +0800</pubDate>
    <lastBuildDate>Mon, 16 Oct 2017 19:18:14 +0800</lastBuildDate>
    <generator>Jekyll v3.4.5</generator>
    
      <item>
        <title>Code + Cartoon</title>
        <description>&lt;p&gt;说实话，第一次在&lt;a href=&quot;https://hacks.mozilla.org/&quot;&gt;Hacks&lt;/a&gt;上看到包含如下图片的文章是很意外的。看过不少技术文章，穿插卡通画的还是头一遭，而且这诡异的画风是咋回事。
&lt;img src=&quot;/img/cartoon.png&quot; alt=&quot;降临中的七肢桶？&quot; /&gt;
&lt;em&gt;降临中的七肢桶？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如果你认为这些图不过是点缀罢了，那么来看看个人看过的对浏览器渲染流程最生动的诠释：
&lt;img src=&quot;/img/webrender.png&quot; alt=&quot;一图胜千言&quot; /&gt;
&lt;em&gt;一图胜千言&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;反正我是被这些图吸引着，读完了 WebAssembly 的&lt;a href=&quot;https://hacks.mozilla.org/author/lclarkmozilla-com/&quot;&gt;系列文章&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/10/15/code+cartoon.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/10/15/code+cartoon.html</guid>
        
        <category>tech-blog</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Webpack代码分割[未完]</title>
        <description>&lt;p&gt;了解 Webpack 的启动代码对于分析模块和 chunk 是非常有帮助的。&lt;/p&gt;

&lt;h2 id=&quot;webpack-启动代码&quot;&gt;Webpack 启动代码&lt;/h2&gt;

&lt;p&gt;首先从最简单的情况入手，在入口文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; 中简单引用了一个模块中的方法：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// index.js
import {func1} from &amp;#39;./module1&amp;#39;;

// module1.js
export function func1() {
    console.log(&amp;#39;func1&amp;#39;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据以上入口文件，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;target: web&lt;/code&gt;（默认情况）下生成的 chunk 文件只有一个。观察其中包含的 Webpack 启动代码，可以发现由一个 IIFE 构成，其中传入的参数是一个方法数组。从其中每个方法的签名可以看出，类似 AMD。很明显，&lt;code class=&quot;highlighter-rouge&quot;&gt;module1.js&lt;/code&gt; 模块的全部代码都在模块1中，而模块0对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt;，引用了模块1。另外有一点值得注意，&lt;code class=&quot;highlighter-rouge&quot;&gt;module1.js&lt;/code&gt; 中的方法并没有被真正使用到，注释 &lt;code class=&quot;highlighter-rouge&quot;&gt;/* unused harmony export func1 */&lt;/code&gt; 也反映了这一点，后续在生产环境配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;UglifyJSPlugin&lt;/code&gt; 插件使用时，依托 &lt;a href=&quot;https://doc.webpack-china.org/guides/tree-shaking/&quot;&gt;TreeShaking 技术&lt;/a&gt;，这段无用代码会被移除。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;(function(modules) { // IIFE
 	// 暂时省略处理模块的逻辑
})
([
/* 模块0 */
(function(module, __webpack_exports__, __webpack_require__) {
    &amp;quot;use strict&amp;quot;;
    Object.defineProperty(__webpack_exports__, &amp;quot;__esModule&amp;quot;, { value: true });
    /* harmony import */
    var __WEBPACK_IMPORTED_MODULE_0__module1__ = __webpack_require__(1);
}),
/* 模块1 */
(function(module, __webpack_exports__, __webpack_require__) {
    &amp;quot;use strict&amp;quot;;
    /* unused harmony export func1 */
    function func1() {
        console.log(&amp;#39;func1&amp;#39;);
    }
})
]);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在可以深入表达式方法细节了。首先定义了 &lt;code class=&quot;highlighter-rouge&quot;&gt;__webpack_require__&lt;/code&gt; 方法，然后在方法上挂了一些属性便于快捷访问，最后调用入口模块也就是模块0。官方的注释非常详细，尤其是 &lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt; 方法的，就不再赘述了。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// The module cache
var installedModules = {};

// The require function
function __webpack_require__(moduleId) {

    // Check if module is in cache
    if(installedModules[moduleId]) {
        return installedModules[moduleId].exports;
    }
    // Create a new module (and put it into the cache)
    var module = installedModules[moduleId] = {
        i: moduleId,
        l: false,
        exports: {}
    };

    // Execute the module function
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    // Flag the module as loaded
    module.l = true;

    // Return the exports of the module
    return module.exports;
}

// 省略挂载属性...

// Load entry module and return exports
return __webpack_require__(__webpack_require__.s = 0);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在方法上挂载的属性中，&lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt; 用来处理常量&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// define getter function for harmony exports
__webpack_require__.d = function(exports, name, getter) {
    if(!__webpack_require__.o(exports, name)) {
        Object.defineProperty(exports, name, {
            configurable: false,
            enumerable: true,
            get: getter
        });
    }
};

// getDefaultExport function for compatibility with non-harmony modules
__webpack_require__.n = function(module) {
    var getter = module &amp;amp;&amp;amp; module.__esModule ?
        function getDefault() { return module[&amp;#39;default&amp;#39;]; } :
        function getModuleExports() { return module; };
    __webpack_require__.d(getter, &amp;#39;a&amp;#39;, getter);
    return getter;
};

// Object.prototype.hasOwnProperty.call
__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

// __webpack_public_path__
__webpack_require__.p = &amp;quot;&amp;quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// index.js

import(/* webpackChunkName: &amp;quot;lodash&amp;quot; */ &amp;#39;lodash&amp;#39;).then(_ =&amp;gt; {
    return _.version();
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 Webpack 中，chunk 一共有&lt;a href=&quot;https://survivejs.com/webpack/building/bundle-splitting/#chunk-types-in-webpack&quot;&gt;三类&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Entry chunk:&lt;/li&gt;
  &lt;li&gt;Normal chunk:&lt;/li&gt;
  &lt;li&gt;Initial chunk:&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://survivejs.com/webpack/building/bundle-splitting/&quot;&gt;SurviveJS Webpack Book&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/TheLarkInn/artsy-webpack-tour&quot;&gt;Webpack 核心开发者基于源码的解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/lcxfs1991/blog/issues/14&quot;&gt;Webpack runtime 代码分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/prpl-pattern/&quot;&gt;PRPL Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 07 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/10/06/Webpack%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/10/06/Webpack%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2.html</guid>
        
        <category>webpack</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>简单生活节</title>
        <description>&lt;p&gt;第一次去音乐节，站了一天真的是累，幸亏没买3天的套票。&lt;/p&gt;

&lt;p&gt;首先这个“Simple Life 简单生活节”的名字我不知道跟热狗的歌有没有关系。但至少 10.4 这场的主基调是嘻哈无疑了，&lt;a href=&quot;http://i.xiami.com/jfever&quot;&gt;小老虎&lt;/a&gt;，&lt;a href=&quot;http://i.xiami.com/luirap&quot;&gt;Lu1&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/artist/bgqsdcca4&quot;&gt;蛋堡&lt;/a&gt;，&lt;a href=&quot;http://i.xiami.com/higherbrothers&quot;&gt;Higher Brothers&lt;/a&gt;和压轴登场的&lt;a href=&quot;http://www.xiami.com/artist/724&quot;&gt;MC Hotdog&lt;/a&gt;都被集中到了大地舞台。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一堆文青 想要过着简单的生活节&lt;/p&gt;

  &lt;p&gt;你想要生活更复杂点 显然你得跟我学
——《贫民百万歌星》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;房东的猫&quot;&gt;房东的猫&lt;/h4&gt;

&lt;p&gt;下午1点多表演从果实舞台首先开始，一个叫&lt;a href=&quot;http://i.xiami.com/fangdongdemao&quot;&gt;房东的猫&lt;/a&gt;的校园乐队，唱了一首&lt;a href=&quot;http://www.xiami.com/song/1796526633&quot;&gt;『你是我最愚蠢的一次浪漫』&lt;/a&gt;，声音很像陈老师，听着很舒服。看看&lt;a href=&quot;http://dashi.streetvoice.cn/article/%E6%88%BF%E4%B8%9C%E7%9A%84%E7%8C%AB%E8%B6%81%E5%B9%B4%E8%BD%BB%E5%8E%BB%E8%BF%87%E5%96%9C%E6%AC%A2%E7%9A%84%E7%94%9F%E6%B4%BB/&quot;&gt;这篇专访&lt;/a&gt;了解更多她们的故事。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/music/mao.jpg&quot; alt=&quot;你是我最愚蠢的一次浪漫&quot; /&gt;
&lt;em&gt;房东的猫&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;小老虎&quot;&gt;小老虎&lt;/h4&gt;

&lt;p&gt;大概一点半，很多人就都开始往大地舞台走，小老虎的表演就要开始了。&lt;a href=&quot;/music/2017/06/03/%E6%9C%80%E8%BF%91%E5%90%AC%E7%9A%84%E8%AF%B4%E5%94%B1.html&quot;&gt;大学里从跑火车电台听到&lt;/a&gt;小老虎，『为你出生入死九十九次』几乎能背出来。看到穿的跟烤串买买提似的小老虎蹦跳着从后台出来，置身欢呼的人群不禁有点激动。可能有些歌不适合现场吧，除了结尾的&lt;a href=&quot;http://www.xiami.com/song/1772491213&quot;&gt;『无人喝彩』&lt;/a&gt;，其他的我都没听过。人群里每一首都能跟唱的也就前两排吧，不过这也不妨碍大家用自己舒服的姿势跟着摇摆。我很喜欢小老虎说的“我不会要求你们把手借给我”。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/jfever.png&quot; alt=&quot;小老虎&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/jfever.png&quot; data-alt=&quot;小老虎&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;小老虎&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;h4 id=&quot;lu1&quot;&gt;Lu1&lt;/h4&gt;

&lt;p&gt;接下来是 Lu1，一个货真价实的学霸，同为程序员有种天生的好感。之前只听过一首他和蛋堡，Cee 合作的&lt;a href=&quot;http://www.xiami.com/song/1776221807&quot;&gt;『Highlight』&lt;/a&gt;，他的那段 verse 用词真的很特别。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;从这里，他们flip a page，对事&lt;/p&gt;

  &lt;p&gt;重新做考估，难免有分歧或对峙
——《Highlight》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/music/lu1.jpg&quot; alt=&quot;Lu1&quot; /&gt;
&lt;em&gt;Lu1&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;蛋堡--李英宏&quot;&gt;蛋堡 &amp;amp; 李英宏&lt;/h4&gt;

&lt;p&gt;蛋堡的歌个人感觉其实不太适合现场，尤其是整体偏燥的氛围下有些昏昏欲睡。但是惊喜的是另一位嘉宾歌手&lt;a href=&quot;http://www.xiami.com/artist/yhD1O0b734b&quot;&gt;李英宏&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/mQXlXIcd689&quot;&gt;『台北直直撞』&lt;/a&gt;如同他的泡面头+大红色一样骚气十足。十分不能理解边上传出的“蛋堡还不上来啊，这谁赶紧下去”之类的声音，个人很喜欢他的风格。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/softlipa.png&quot; alt=&quot;蛋堡&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/softlipa.png&quot; data-alt=&quot;蛋堡&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;蛋堡&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;h4 id=&quot;higher-brothers&quot;&gt;Higher Brothers&lt;/h4&gt;

&lt;p&gt;吃了点东西，就到了海尔兄弟。从每一遍垫场广告里“made in china”都有人跟唱就能看出，他们的人气真的高的恐怖。视野里每个人几乎都处于全程跳跃状态。由于已经是傍晚，在舞台灯光配合下真的有一种迷幻的感觉。海尔兄弟已经走向世界，我还是最喜欢 masiwei 的崂山道士。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/higherbrothers.png&quot; alt=&quot;Higher Brothers: dz &amp;amp; masiwei&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/higherbrothers.png&quot; data-alt=&quot;Higher Brothers: dz &amp;amp; masiwei&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;Higher Brothers: dz &amp;amp; masiwei&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;h4 id=&quot;万芳&quot;&gt;万芳&lt;/h4&gt;

&lt;p&gt;由于热狗迟到一小时，等待的间隙去微风舞台看了&lt;a href=&quot;http://dashi.streetvoice.cn/article/20171002/002/&quot;&gt;万芳&lt;/a&gt;的表演。我就是她说的“只知道我的『新不了情』的新朋友”，听了几首感觉嗓子保养的真好，与之形成鲜明对比的是另一个星空舞台上的高旗，虽然唱摇滚不好这样简单对比，但听着着实感到吃力。推荐一首&lt;a href=&quot;http://www.xiami.com/song/bf0Ho8u305cd&quot;&gt;『落音』&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;mc-hotdog&quot;&gt;MC Hotdog&lt;/h4&gt;

&lt;p&gt;热狗的压轴演出对得起观众老爷们的等待，&lt;a href=&quot;http://www.xiami.com/song/erWf62e123&quot;&gt;『谢谢哑虎』&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/mQC67x9545a&quot;&gt;『贫民百万歌星』&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/8Gi4kAf3809&quot;&gt;『轻熟女』&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/bAgql12f94&quot;&gt;『差不多先生』&lt;/a&gt;，&lt;a href=&quot;http://www.xiami.com/song/mQC67ycfb9a&quot;&gt;『不吃早餐才是一件很嘻哈的事』&lt;/a&gt;应该是很多人的回忆吧。说实话他现在的兄弟本色一首都没听过。。。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/mchotdog.png&quot; alt=&quot;MC Hotdog&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/mchotdog.png&quot; data-alt=&quot;MC Hotdog&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;MC Hotdog&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;部分图片来自&lt;a href=&quot;http://dashi.streetvoice.cn/article/20171012/001/&quot;&gt;图集&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/music/2017/10/05/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%E8%8A%82.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/music/2017/10/05/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%E8%8A%82.html</guid>
        
        <category>hiphop</category>
        
        
        <category>music</category>
        
      </item>
    
      <item>
        <title>火车和出租车</title>
        <description>&lt;p&gt;看着火车这一意象不断出现在一幕幕闪回中，观众们对男主角的唏嘘也愈发被强化。命运是在哪一步被搬了道岔，驶向了万劫不复的终结呢。明明曾经有着美好的初恋，也怀着梦想参军，却莫名地被大事件裹挟，如同粗暴的被上级士官一脚踹飞而散落一地的薄荷糖，被无数慌乱的脚步踩的稀碎。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/mint.jpg&quot; alt=&quot;《薄荷糖》&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/mint.jpg&quot; data-alt=&quot;《薄荷糖》&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;《薄荷糖》&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;谈起韩国的伤痕文学，“光州事件”是永远无法绕开的。《薄荷糖》展现了一个木讷士兵的视角，明明脚中了流弹还以为靴子里灌满了水，慌乱中误杀女学生成了一切悲剧的根源。这是我第一次看薛景求的片子，男主各阶段的状态就如同他的发型，被他演绎的令人无比信服，人物转变没有一丝突兀。结尾处男主独自离开众人潸然泪下的场景，呼应开头又透出浓浓的宿命味道。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/movie/mint2.jpg&quot; alt=&quot;我要回去&quot; /&gt;
&lt;em&gt;薛景求：“我要回去！”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;最近另一部涉及同题材的片子在网络上遭遇大面积封禁。除了都大量出现了交通工具，男主宋康昊也展现了自己的纯熟演技。虽然个人不喜欢大事件之后某些过度煽情的场景，但片子传达出媒体和政府的反思不得不说令人欣羨。&lt;/p&gt;

&lt;p&gt;其实我一直很奇怪的一点是同属文艺作品，相比电影的审查尺度，书却宽松许多。最近看完了冯骥才的《一百个人的十年》，作者一直在思考一个问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么人性的弱点，如人的自私、贪欲、怯弱、妒忌、虚荣等被“文革”利用；人性的优点，如忠诚、勇敢、淳朴、无私、诚实也成为“文革”推波助澜的动力？在人性的两极都被“文革”利用的同时，那些真正属于人性的人道、人权、人的尊严、人的价值等所有人的最高贵的成分，都受到“文革”公开的践踏？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在面对历史的时候我觉得至少要保持自信和诚实。且不说能不能拍和拍好，现在连评论他国的作品都要噤声了，买菜市民真的那么可怕吗？&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Oct 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/movie/2017/10/03/%E7%81%AB%E8%BD%A6%E5%92%8C%E5%87%BA%E7%A7%9F%E8%BD%A6.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/movie/2017/10/03/%E7%81%AB%E8%BD%A6%E5%92%8C%E5%87%BA%E7%A7%9F%E8%BD%A6.html</guid>
        
        <category>movie</category>
        
        
        <category>movie</category>
        
      </item>
    
      <item>
        <title>Webpack 中的 HMR</title>
        <description>&lt;p&gt;在使用 Webpack 构建项目时，开发模式下代码的 hotreload 特性帮助开发者节省了很多手动刷新浏览器的时间。最近在项目中遇到了这方面的问题，决定深入研究一下背后的实现原理。&lt;/p&gt;

&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;

&lt;p&gt;首先需要引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;webpack-hot-middleware&lt;/code&gt; 中间件和 &lt;code class=&quot;highlighter-rouge&quot;&gt;HotModuleReplacementPlugin&lt;/code&gt; 插件。当然开发环境下 &lt;code class=&quot;highlighter-rouge&quot;&gt;webpack-dev-middleware&lt;/code&gt; 肯定也是必不可少的。&lt;/p&gt;

&lt;p&gt;启动项目后打开 Chrome Devtools，这个&lt;code class=&quot;highlighter-rouge&quot;&gt;/__webpack_hmr&lt;/code&gt;请求很明显是实现 hotreload 的关键。可以看出请求一直保持连接，并不断接收到“心跳”事件。
&lt;img src=&quot;/img/hmr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;客户端发起-socket-连接&quot;&gt;客户端发起 socket 连接&lt;/h2&gt;

&lt;p&gt;首先观察一下请求头&lt;code class=&quot;highlighter-rouge&quot;&gt;text/event-stream&lt;/code&gt;，这个请求是由客户端代码通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&quot;&gt;EventSource&lt;/a&gt;创建的：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/client.js

function init() {
    source = new window.EventSource(options.path);
    source.onopen = handleOnline;
    source.onerror = handleDisconnect;
    source.onmessage = handleMessage;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里提到的“客户端代码”是指使用 webpack-hot-middleware 时，除了使用中间件之外，还需要把&lt;a href=&quot;https://github.com/glenjamin/webpack-hot-middleware/blob/master/client.js#L74-L79&quot;&gt;client.js&lt;/a&gt;加入入口依赖，因此这段代码会被打包到客户端代码中。创建完 EventSource 之后，绑定了若干事件处理函数，我们后续会查看这些细节。&lt;/p&gt;

&lt;h2 id=&quot;服务端中间件响应&quot;&gt;服务端中间件响应&lt;/h2&gt;

&lt;p&gt;在收到客户端请求后，中间件需要进行响应，同时需要管理每一个客户端连接，这里将响应对象通过自增的 ID 保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;clients&lt;/code&gt;中，当连接断开时删除。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/middleware.js

function(req, res) {
    req.socket.setKeepAlive(true);
    res.writeHead(200, {
        &amp;#39;Access-Control-Allow-Origin&amp;#39;: &amp;#39;*&amp;#39;,
        &amp;#39;Content-Type&amp;#39;: &amp;#39;text/event-stream;charset=utf-8&amp;#39;,
        &amp;#39;Cache-Control&amp;#39;: &amp;#39;no-cache, no-transform&amp;#39;,
        &amp;#39;Connection&amp;#39;: &amp;#39;keep-alive&amp;#39;,
        &amp;#39;X-Accel-Buffering&amp;#39;: &amp;#39;no&amp;#39;
    });
    res.write(&amp;#39;\n&amp;#39;);
    var id = clientId++;
    clients[id] = res;
    req.on(&amp;quot;close&amp;quot;, function(){
        delete clients[id];
    });
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;向每个连接发送心跳事件是通过定时器完成的。值得一提的是&lt;code class=&quot;highlighter-rouge&quot;&gt;unref()&lt;/code&gt;的用法，使这个定时器不会影响事件循环的退出，如果没有其他事件进入队列，事件循环将结束，进程就退出了。更多关于&lt;code class=&quot;highlighter-rouge&quot;&gt;unref()&lt;/code&gt;的说明，可以参考这个&lt;a href=&quot;https://cnodejs.org/topic/570924d294b38dcb3c09a7a0#5709f1b8bc564eaf3c6a48e1&quot;&gt;回答&lt;/a&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/middleware.js

setInterval(function heartbeatTick() {
    everyClient(function(client) {
        // 向每个 client 发送心跳字符
        client.write(&amp;quot;data: \uD83D\uDC93\n\n&amp;quot;);
    });
}, heartbeat).unref();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么在代码发生变动时，如何通知客户端呢？在创建中间件时，为 webpack 编译器添加了对应编译阶段的监听函数：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/middleware.js

compiler.plugin(&amp;quot;compile&amp;quot;, function() {
    eventStream.publish({action: &amp;quot;building&amp;quot;});
});
compiler.plugin(&amp;quot;done&amp;quot;, function(statsResult) {
    eventStream.publish({
        name: stats.name,
        action: action,
        time: stats.time,
        hash: stats.hash,
        warnings: stats.warnings || [],
        errors: stats.errors || [],
        modules: buildModuleMap(stats.modules)
    });
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;客户端热更新&quot;&gt;客户端热更新&lt;/h2&gt;

&lt;p&gt;在接收到代码变动后服务端发送的事件后，客户端代码需要进行模块热替换处理。客户端在创建 EventSource 时通过&lt;code class=&quot;highlighter-rouge&quot;&gt;onmessage&lt;/code&gt;定义了处理服务端消息的函数。其中&lt;code class=&quot;highlighter-rouge&quot;&gt;building&lt;/code&gt;事件只是简单的输出控制台信息，我们将着重关注&lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt;事件。另外通过&lt;code class=&quot;highlighter-rouge&quot;&gt;customHandler&lt;/code&gt;支持自定义事件，例如可以为 html-webpack-plugin 添加自动刷新页面功能，后续将会介绍具体做法。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/client.js

case &amp;quot;sync&amp;quot;:
    processUpdate(obj.hash, obj.modules, options);
    break;
default:
    if (customHandler) {
        customHandler(obj);
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们通过比对当前代码的 hash 和服务端发来的 hash 判断代码是否发生了更新。当前代码的 hash 是通过 webpack 的&lt;a href=&quot;https://doc.webpack-china.org/api/module-variables/#__webpack_hash__-webpack-specific-&quot;&gt;全局模块变量&lt;/a&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/* global window __webpack_hash__ */&lt;/code&gt;在编译时注入。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack-hot-middleware/process-update.js

/* global window __webpack_hash__ */
function upToDate(hash) {
    if (hash) lastHash = hash;
    return lastHash == __webpack_hash__;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当发现 hash 不匹配，也就是代码发生了更新时，首先需要获取最新的代码，这依赖 webpack 模块的&lt;a href=&quot;https://doc.webpack-china.org/api/hot-module-replacement#check&quot;&gt;hot.check()&lt;/a&gt;接口。调用后将发送一个 HTTP 请求用来获取更新后的模块信息，触发回调函数。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var result = module.hot.check(false, cb);
if (result &amp;amp;&amp;amp; result.then) {
    result.then(function(updatedModules) {
        cb(null, updatedModules);
    });
    result.catch(cb);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在回调函数中，如果没有报错，就调用模块的 &lt;code class=&quot;highlighter-rouge&quot;&gt;hot.apply()&lt;/code&gt; 进行热替换。要注意正常的热替换是不需要触发浏览器刷新页面的，会执行代码中&lt;code class=&quot;highlighter-rouge&quot;&gt;if (module.hot)&lt;/code&gt;条件分支的热替换逻辑。
详细信息可以参考&lt;a href=&quot;https://doc.webpack-china.org/guides/hot-module-replacement&quot;&gt; Webpack 文档的介绍&lt;/a&gt;或者 style-loader 的实现。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var cb = function(err, updatedModules) {
    if (err) return handleError(err);
    var applyResult = module.hot.apply(applyOptions, applyCallback);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此我们了解了代码热更新时，服务端和客户端的整个通信流程。&lt;/p&gt;

&lt;h2 id=&quot;为-html-webpack-plugin-添加自动刷新&quot;&gt;为 html-webpack-plugin 添加自动刷新&lt;/h2&gt;

&lt;p&gt;最后让我们来看一个开发中具体的问题。在使用 html-webpack-plugin 插件生成 HTML 的场景中，我们希望做到修改模版自动刷新页面，节省手动刷新的时间。这里使用到了之前 webpack-hot-middleware 客户端代码接收自定义更新事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;customHandler&lt;/code&gt;。在使用中间件的服务端代码中，每次 HTML 生成后，都会向客户端发送一个自定义事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;reload&lt;/code&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 使用 webpack-hot-middleware 的服务端代码

compiler.plugin(&amp;#39;compilation&amp;#39;, (compilation) =&amp;gt; {
    compilation.plugin(&amp;#39;html-webpack-plugin-after-emit&amp;#39;, (data, cb) =&amp;gt; {
        hotMiddleware.publish({
            action: &amp;#39;reload&amp;#39;
        });
        cb();
    });
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在客户端 entry 代码中，只需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;subscribe&lt;/code&gt; 订阅该自定义事件即可。另外，这里使用到了 Webpack 模块的 query 参数。关于 &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;noInfo&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;reload&lt;/code&gt; 这些客户端参数的含义，可以参考 webpack-hot-middleware 的&lt;a href=&quot;https://github.com/glenjamin/webpack-hot-middleware#config&quot;&gt;文档说明&lt;/a&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 客户端 entry 代码

import &amp;#39;eventsource-polyfill&amp;#39;;
import hotClient from &amp;#39;webpack-hot-middleware/client?name=compilerName&amp;amp;noInfo=true&amp;amp;reload=true&amp;#39;;

hotClient.subscribe(payload =&amp;gt; {
    if (payload.action === &amp;#39;reload&amp;#39; || payload.reload === true) {
        window.location.reload();
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 vuejs-templates 官方 Webpack 模版中，就采用了这种做法。但是其中有一个&lt;a href=&quot;https://github.com/vuejs-templates/webpack/issues/751#issuecomment-309955295&quot;&gt;ISSUE&lt;/a&gt;值得关注，包括我自己在使用时，也遇到了同样的问题。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://doc.webpack-china.org/concepts/hot-module-replacement/&quot;&gt;Webpack HMR 官方介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/vuejs-templates/webpack/issues/751#issuecomment-309955295&quot;&gt;vuejs-templates issue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 30 Sep 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/09/29/Webpack-%E4%B8%AD%E7%9A%84-HMR.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/09/29/Webpack-%E4%B8%AD%E7%9A%84-HMR.html</guid>
        
        <category>javascript</category>
        
        <category>webpack</category>
        
        <category>eventstream</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Node.js 中的消息队列</title>
        <description>&lt;p&gt;在用户注册的场景中，服务端接收到提交的表单内容，将数据写入数据库，随后发送一封注册成功邮件。
通常处理请求参数，操作数据库，调用 STMP 邮件服务器发送邮件都写在一个请求处理函数中。这样的问题是任何一步发生错误，都需要重试。这还只是一个简单场景，如果流程复杂，依赖外部系统众多，显然问题就不可避免了。&lt;/p&gt;

&lt;p&gt;我们引入消息队列，producer 负责向队列中推送消息，而 worker 负责消费。
&lt;img src=&quot;/img/work-queue.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用消息队列的好处是显而易见的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;解耦了 producer 和 worker。尤其是像发送邮件这样对实时性要求不高的步骤，如果这一步操作失败，我们显然不需要回滚之前对数据库的修改，只需要在合适的时间重试就行了。&lt;/li&gt;
  &lt;li&gt;实现重试逻辑变得简单。另外，当进程出现错误，不至于丢失全部状态，甚至可以从错误中恢复。&lt;/li&gt;
  &lt;li&gt;分布式和扩展性。配合 cluster，创建多个 worker 变得简单。&lt;/li&gt;
  &lt;li&gt;让外部系统更容易集成进来，相比在一个请求回调函数中完成所有逻辑处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;简单的内存队列&quot;&gt;简单的内存队列&lt;/h2&gt;

&lt;p&gt;首先实现一个内存中的队列管理，使用 async 创建队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 创建并发度为1的异步队列
const queue = async.queue(work, 1);

function work(item, cb) {
    ensureConnected(function() {
        domotic.command(item.command, item.options, callback);
    });

    function callback(err) {
        // 出错重试
        if (err &amp;amp;&amp;amp; err.code == &amp;#39;ECONN&amp;#39;) {
            connected = false;
            work(item, cb);
        } else cb(err);
    }
}
// 推送消息到队列中
queue.push(work, cb);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样一个简单的 demo 存在的问题就是所有状态存在于内存中，一旦崩溃就无法恢复了。另外内存毕竟有限，对于一个长时间运行的系统，迟早是会超出内存限制的。&lt;/p&gt;

&lt;h2 id=&quot;通过-leveldb-持久化&quot;&gt;通过 LevelDB 持久化&lt;/h2&gt;

&lt;p&gt;持久化队列是个不错的改进方向。LevelDB 是一个键值对数据库，不需要安装，可以在指定目录下创建。另外，使用配套的 &lt;code class=&quot;highlighter-rouge&quot;&gt;level-jobs&lt;/code&gt; 可以快捷的创建队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const level = require(&amp;#39;level&amp;#39;);
// 创建本地数据库
const db = level(&amp;#39;./event/db&amp;#39;);
const Jobs = require(&amp;#39;level-jobs&amp;#39;);
const maxConcurrency = 1;
// 创建队列，并发度1
const queue = Jobs(db, worker, maxConcurrency);

module.exports = queue;

function worker(id, payload, cb) {
    sendEventToRemoteService(payload, (err) =&amp;gt; {
        if (err) {
            console.error(&amp;#39;Error processing event %s: %s&amp;#39;,payload.id, err.message);
        }
        else {
            console.log(&amp;#39;event %s successfully relayed&amp;#39;, payload.id);
        }
        cb(err);
    });
}
// 模拟复杂异步处理流程
function sendEventToRemoteService(payload, cb) {
    setTimeout(() =&amp;gt; {
        let err;
        if (Math.random() &amp;gt; 0.5) {
            err = Error(&amp;#39;something awful has happened&amp;#39;);
        }
        cb(err);
    }, 100);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;queue.push(payload)&lt;/code&gt;可以向队列中推送消息。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const relay = require(&amp;#39;./event_relay&amp;#39;);
for(let i = 0; i &amp;lt; 10; i++) {
    relay.push({
        id: i,
        event: &amp;#39;door opened&amp;#39;
    });
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在我们解决了持久化队列的问题，但是我们的 worker 是单线程运行的。如果任务是 CPU 密集型的，还是需要分配负载到多个线程上。&lt;/p&gt;

&lt;h2 id=&quot;redis-和多线程&quot;&gt;Redis 和多线程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;simple-redis-safe-work-queue&lt;/code&gt; 是一个基于 Redis 的分布式 worker/producer 的队列解决方案。
创建 worker，设置重试次数。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const request = require(&amp;#39;request&amp;#39;);
const Queue = require(&amp;#39;simple-redis-safe-work-queue&amp;#39;)
// 设置重试次数
const workerOptions = {
  maxRetries: 2
};

const worker = Queue.worker(&amp;#39;invoke webhook&amp;#39;, invokeWebhook, workerOptions);

function invokeWebhook(webhook, cb) {
    console.log(&amp;#39;invoke webhook: %j&amp;#39;, webhook);

    request(webhook, done);

    function done(err, res) {
        if (!err &amp;amp;&amp;amp; (res.statusCode &amp;lt; 200 || res.statusCode &amp;gt;= 300)) {
            err = Error(&amp;#39;response status code was &amp;#39; + res.statusCode);
        }
        cb(err);
    }
}

worker.on(&amp;#39;max retries&amp;#39;, function(err, payload) {
    console.error(
        &amp;#39;max retries reached trying to talk to %s.: %s\nrequest params: %j&amp;#39;,
        payload.url, err.stack, payload);
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而对于 producer，在一个实际的例子中，在数据库操作完成后向队列推送消息，并在 server 停止时关闭队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const Queue = require(&amp;#39;simple-redis-safe-work-queue&amp;#39;)
const webhookQueueClient = Queue.client(&amp;#39;invoke webhook&amp;#39;);
const server = Server();
server.listen(8080);
server.post(&amp;#39;/some/important/action&amp;#39;, (req, res, next) =&amp;gt; {
    db.insert(someDoc, err =&amp;gt; {
        if (err) res.send(err);
        else {
            webhookQueueClient.push({
                url: &amp;#39;http://example.com&amp;#39;,
                method: &amp;#39;POST&amp;#39;,
                json: {
                    a: 1,
                    b: 2
                }
            }, pushedWebhookWork);
        }

        function pushedWebhookWork(err) {
            if (err) res.stats(500).send(err);
            else res.stats(201).send({ok: true});
        }
    });
});
// 关闭队列
server.once(&amp;#39;close&amp;#39;, () =&amp;gt; {
    webhookQueueClient.quit();
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们可以启动多个 worker 线程消费队列。Redis 在处理简单的场景中足够了，如果对可扩展性和稳定性有更高要求，就需要更为成熟的平台了。&lt;/p&gt;

&lt;h2 id=&quot;rabbitmq&quot;&gt;RabbitMQ&lt;/h2&gt;

&lt;p&gt;通过 homebrew 安装后。启动服务器：&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/sbin/rabbitmq-server&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;创建 channel，无论成功与否都会触发回调函数。worker 和 producer 都会通过该方法连接队列。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const amqp = require(&amp;#39;amqplib/callback_api&amp;#39;);
const url = process.env.AMQP_URL || &amp;#39;amqp://guest:guest@localhost:5672&amp;#39;;

module.exports = createQueueChannel;

function createQueueChannel(queue, cb) {
    amqp.connect(url, onceConnected);

    function onceConnected(err, conn) {
        if (err) {
            console.error(&amp;#39;Error connecting:&amp;#39;, err.stack);
        }
        else {
            console.log(&amp;#39;connected&amp;#39;);
            conn.createChannel(onceChannelCreated);
        }

        function onceChannelCreated(err, channel) {
            if (err) {
                cb(err);
            }
            else {
                channel.assertQueue(queue, {durable: true}, onceQueueCreated);
            }

            function onceQueueCreated(err) {
                if (err) {
                    cb(err);
                }
                else {
                    cb(null, channel, conn);
                }
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于 producer 而言，需要连接 channel，然后向队列发送消息，随后断开连接：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const Channel = require(&amp;#39;./channel&amp;#39;);
const QUEUE = &amp;#39;queue&amp;#39;;

Channel(QUEUE, (err, channel, conn) =&amp;gt; {
    if (err) {
        console.error(err.stack);
    }
    else {
        console.log(&amp;#39;channel and queue created&amp;#39;);
        let work = &amp;#39;make me a sandwich&amp;#39;;
        channel.sendToQueue(QUEUE, encode(work), {
            persistent: true
        });
        setImmediate(() =&amp;gt; {
            channel.close();
            conn.close();
        });
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而对于每一个 worker，连接成功后，取出队列中的消息内容载荷进行消费，完成后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ack()&lt;/code&gt;通知队列，继续消费下一个消息。而如果队列为空，通过定时器在一定延迟后继续消费。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Channel(QUEUE, (err, channel, conn) =&amp;gt; {
    if (err) {
        console.error(err.stack);
    }
    else {
        console.log(&amp;#39;channel and queue created&amp;#39;);
        consume();
    }

    function consume() {
        channel.get(QUEUE, {}, onConsume);

        function onConsume(err, msg) {
            if (err) {
                console.warn(err.message);
            }
            else if (msg) {
                console.log(&amp;#39;consuming %j&amp;#39;, msg.content.toString());
                setTimeout(() =&amp;gt; {
                    channel.ack(msg);
                    consume();
                }, 1e3);
            }
            else {
                console.log(&amp;#39;no message, waiting...&amp;#39;);
                setTimeout(consume, 1e3);
            }
        }
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.yld.io/2016/05/10/introducing-queues/#.Wb4dqHeg_2Q&quot;&gt;YLD博客的系列文章&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rabbitmq.com/documentation.html&quot;&gt;RabbitMQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 17 Sep 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html</guid>
        
        <category>javascript</category>
        
        <category>nodejs</category>
        
        <category>leveldb</category>
        
        <category>redis</category>
        
        <category>rabbitMQ</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>判断元素是否在视口内</title>
        <description>&lt;p&gt;在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function inViewport( el, h ) {
    var elH = el.offsetHeight, // 元素高度
        scrolled = scrollY(), // 视口顶部距离document顶部的距离
        viewed = scrolled + getViewportH(), // 视口底部距离document的距离
        elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离
        elBottom = elTop + elH, // 元素底部距离document顶部的距离
        h = h || 0; // 高度系数
    return (elTop + elH * h) &amp;lt;= viewed &amp;amp;&amp;amp; (elBottom) &amp;gt;= scrolled;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方法的问题是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;读取元素尺寸数据时，会造成 re-layout，在滚动过程中会导致页面卡顿(jank)。&lt;/p&gt;

&lt;h2 id=&quot;intersectionobserver&quot;&gt;IntersectionObserver&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wicg.github.io/IntersectionObserver/&quot;&gt;IntersectionObserver&lt;/a&gt; 作为新引入的 API，异步查询元素相对于另一个元素（例如视口）的位置，不会影响主线程，可以解决检测方法带来的性能问题。&lt;/p&gt;

&lt;p&gt;首先我们需要创建一个观察对象，构造函数方法签名如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;new IntersectionObserver(entries =&amp;gt; {}, options);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随后将使用这个观察对象对元素的位置变化进行观测：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;io.observe(element);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;观察对象构造函数的第一个参数便是回调函数，这能避免旧方法中轮询带来的性能问题。
在回调函数中，传入的参数是一个数组（可以观测多个元素），每个元素对象包含以下属性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootBounds&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientRect&lt;/code&gt;对象，等同于对根元素（默认值为视口）调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;boundingClientRect&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientRect&lt;/code&gt;对象，等同于对被观测元素调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;intersectionRect&lt;/code&gt;，以上两个矩形的交集&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;intersectionRatio&lt;/code&gt;，被观测元素被覆盖的比例，如下图所示：&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/intersectratio.png&quot; alt=&quot;&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/intersectratio.png&quot; data-alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;现在来看看观察对象的第二个参数，这是一个配置对象，其中包含3个重要的配置项：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;，默认值为视口，在容器内滚动的场景中，我们可以指定根元素为容器&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootMargin&lt;/code&gt;，顾名思义，值的格式与&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;一样&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threshold&lt;/code&gt;，这个阈值甚至可以是一个列表，每次达到其中的一个阈值时都会触发回调函数，取值范围为[0-1]&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;observe()&lt;/code&gt;观测方法，自然也有解除观测方法&lt;code class=&quot;highlighter-rouge&quot;&gt;unobserve()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上就是这个新 API 的全部内容了，下面让我们看看在实际场景中如何应用吧。&lt;/p&gt;

&lt;h2 id=&quot;懒加载图片&quot;&gt;懒加载图片&lt;/h2&gt;

&lt;p&gt;有了这个新的 API，实现滚动到视口内加载图片就十分简单了，其实就是多了新的判断方法，不再需要在滚动事件中获取了。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 创建观测对象
let observer = new IntersectionObserver(entries =&amp;gt; {
    entries.forEach(entry =&amp;gt; {
        // 图片和视口有交集了
        if (entry.intersectionRatio &amp;gt; 0) {
            // 停止继续观测，直接加载
            observer.unobserve(entry.target);
            loadImage(entry.target);
        }
    });
}, {threshold: 0.01});

// 观测所有图片
images.forEach(image =&amp;gt; {
    observer.observe(image);
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，这里还有一些细节，例如：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;考虑浏览器兼容性，目前&lt;a href=&quot;https://caniuse.com/#feat=intersectionobserver&quot;&gt;最新版 Chrome 和 Firefox 支持&lt;/a&gt;良好。&lt;a href=&quot;https://github.com/WICG/IntersectionObserver/tree/gh-pages/polyfill&quot;&gt;polyfill&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;图片的 src 属性存放在例如 data-src 上&lt;/li&gt;
  &lt;li&gt;全部图片加载完毕，调用观测对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;disconnect()&lt;/code&gt;方法彻底关闭&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以参考&lt;a href=&quot;https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163&quot;&gt;这篇文章&lt;/a&gt;的实现。&lt;/p&gt;

&lt;h2 id=&quot;多个容器中-sticky-的场景&quot;&gt;多个容器中 sticky 的场景&lt;/h2&gt;

&lt;p&gt;同样，在 sticky 的场景中，IntersectionObserver 也有很好的应用。&lt;/p&gt;

&lt;p&gt;首先来看看过去的方式有哪有限制：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于开发者而言，通过 CSS 规则&lt;code class=&quot;highlighter-rouge&quot;&gt;position: sticky&lt;/code&gt;将控制行为完全交给浏览器。除了通过手动计算，完全不知道一个元素当前是否处于 sticky 状态，当然这个计算过程，又需要放在滚动事件中重复执行，容易造成 jank。&lt;/li&gt;
  &lt;li&gt;当涉及到多个独立容器的场景，计算过程将变得十分复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/sticky-regions.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于开发者的一种理想状态是，能够监听自定义事件&lt;code class=&quot;highlighter-rouge&quot;&gt;sticky-change&lt;/code&gt;，在元素 sticky 状态发生改变之时进行操作，这样就避免了在滚动事件处理函数中不断轮询。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;document.addEventListener(&amp;#39;sticky-change&amp;#39;, e =&amp;gt; {
    const header = e.detail.target;  // header became sticky or stopped sticking.
    const sticking = e.detail.stuck; // true when header is sticky.
    header.classList.toggle(&amp;#39;shadow&amp;#39;, sticking); // add drop shadow when sticking.
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先我们需要为每一个容器建立首尾两个“哨兵” DOM。IO 需要关注它们和视口容器的重合度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/sentinelanimation.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里以头部的“哨兵”为例，每次一进入视口容器就需要开始计算位置信息。尾部哨兵略有不同，只有全部在容器中才需要开始计算。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const observer = new IntersectionObserver((records, observer) =&amp;gt; {
    for (const record of records) {
        const targetInfo = record.boundingClientRect;
        const stickyTarget = record.target.parentElement.querySelector(&amp;#39;.sticky&amp;#39;);
        const rootBoundsInfo = record.rootBounds;

        // Started sticking.
        if (targetInfo.bottom &amp;lt; rootBoundsInfo.top) {
            fireEvent(true, stickyTarget);
        }

        // Stopped sticking.
        if (targetInfo.bottom &amp;gt;= rootBoundsInfo.top &amp;amp;&amp;amp;
            targetInfo.bottom &amp;lt; rootBoundsInfo.bottom) {
            fireEvent(false, stickyTarget);
        }
    }
}, {threshold: [0], root: container});

// Add the top sentinels to each section and attach an observer.
const sentinels = addSentinels(container, &amp;#39;sticky_sentinel--top&amp;#39;);
sentinels.forEach(el =&amp;gt; observer.observe(el));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发送自定义事件的代码就省略了。完整代码可参考原文中的&lt;a href=&quot;https://ebidel.github.io/demos/sticky-position-event.html&quot;&gt;DEMO 地址&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;现在我们可以做到监听元素 sticky 状态的变动，由此引申到另一个问题，那就是元素其他 CSS 属性的变动也能够检测么？
&lt;code class=&quot;highlighter-rouge&quot;&gt;MutationObserver&lt;/code&gt;可以监听样式类的增减，但是计算出来的样式规则发生变动则不行。未来&lt;a href=&quot;http://xml3d.org/xml3d/specification/styleobserver/&quot;&gt; Style Mutation Observer&lt;/a&gt;将作为一个很好的补充。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;IO 在需要计算两个元素重合状态，尤其是视口元素的场景中，可以完全替代滚动事件轮询的方式。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2016/04/intersectionobserver&quot;&gt;Google Developer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hacks.mozilla.org/2017/08/intersection-observer-comes-to-firefox/&quot;&gt;MDN&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163&quot;&gt;懒加载图片原文&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2017/09/sticky-headers&quot;&gt;sticky场景 原文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html</guid>
        
        <category>javascript</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>在 jekyll 中使用代码高亮</title>
        <description>&lt;p&gt;代码高亮是一个技术博客的重要特性，Jekyll 中默认使用&lt;a href=&quot;http://jekyllrb.com/docs/templates/#code-snippet-highlighting&quot;&gt; Rouge&lt;/a&gt;进行词法分析生成 DOM 结构，搭配自定义样式。使用 Python 编写的&lt;a href=&quot;http://pygments.org/&quot;&gt; Pygments&lt;/a&gt;也是一个可选方案。&lt;/p&gt;

&lt;p&gt;博客作者可以使用如下 markdown 语法插入代码块，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;linenos&lt;/code&gt;表示显示行号：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;\{\% highlight ruby linenos %}
    def foo
      puts &amp;#39;foo&amp;#39;
    end
    \{\% endhighlight %}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本来我是采用默认的 Rouge，但是发现样式有点丑，尤其是行号部分。而且有时我需要高亮显示若干行代码，例如这样：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;\{\% highlight ruby linenos=1-2 %}
    def foo
      puts &amp;#39;foo&amp;#39;
    end
    \{\% endhighlight %}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时 Rouge 就做不到了，而且 Rouge 和 Pygments 似乎很久没有更新了，想找一个漂亮的样式也不容易。&lt;/p&gt;

&lt;p&gt;我在网上搜了一下，发现了&lt;a href=&quot;http://prismjs.com/&quot;&gt; Prism&lt;/a&gt;这样一个库。MDN，Smashing magazine 很多技术网站都在使用，难怪样式看着有点眼熟。那么如何在 jekyll 中使用呢？&lt;/p&gt;

&lt;h2 id=&quot;编写-jekyll-插件&quot;&gt;编写 jekyll 插件&lt;/h2&gt;

&lt;p&gt;参考 Prism 文档，在项目中引入定制后的 JS 和 CSS 文件都很简单。值得一提的是之前提过的高亮特定行数的代码，可以通过&lt;a href=&quot;http://prismjs.com/plugins/line-highlight/&quot;&gt; Prism 插件&lt;/a&gt;实现。所以我们只需要关注如何通过 jekyll 插件将 markdown 代码块转换成对应的 HTML 代码即可。&lt;/p&gt;

&lt;p&gt;之前介绍过如何在&lt;a href=&quot;/coding/2017/07/22/%E5%9C%A8GithubPages%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6.html&quot;&gt; Github Pages 中使用第三方插件&lt;/a&gt;。由于我的博客在本地进行编译，所以只需要将插件放在&lt;code class=&quot;highlighter-rouge&quot;&gt;_plugins&lt;/code&gt;文件夹下即可。&lt;/p&gt;

&lt;p&gt;我搜索到一个&lt;a href=&quot;https://github.com/gmurphey/jekyll-prism-plugin&quot;&gt; jekyll 插件&lt;/a&gt;，已经很久没有维护了，ISSUE 也很久没有回复。看了代码后决定在此基础上进行修改，顺便学习一下自定义插件的相关知识。&lt;/p&gt;

&lt;h3 id=&quot;liquid&quot;&gt;Liquid&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; 是使用 Ruby 编写的模版引擎。jekyll 使用它进行 markdown 语法的解析。通过继承 Liquid 内部封装的类，可以自定义我们的语法块。&lt;/p&gt;

&lt;p&gt;以下是声明和注册代码，继承&lt;a href=&quot;http://www.rubydoc.info/gems/liquid/Liquid/Block&quot;&gt; Block&lt;/a&gt;而非 Tag 的原因很简单，我们需要使用闭合标签，类似&lt;code class=&quot;highlighter-rouge&quot;&gt;\{\% endprism %}&lt;/code&gt;，否则一旦解析到闭合标签就会报错了。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;2,11&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Jekyll
  class PrismBlock &amp;lt; Liquid::Block
    include Liquid::StandardFilters
    def initialize(tag_name, markup, tokens)
        super
    end

    def render(context)
    end
end
Liquid::Template.register_tag(&amp;#39;prism&amp;#39;, Jekyll::PrismBlock)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码中还引入了&lt;code class=&quot;highlighter-rouge&quot;&gt;StandardFilters&lt;/code&gt;，这个后续在输出 HTML 时会使用。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;3&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Jekyll
  class PrismBlock &amp;lt; Liquid::Block
    include Liquid::StandardFilters
end
Liquid::Template.register_tag(&amp;#39;prism&amp;#39;, Jekyll::PrismBlock)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;真正的处理逻辑将在两个方法：构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;initialize()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt;中完成。&lt;/p&gt;

&lt;h3 id=&quot;解析行号&quot;&gt;解析行号&lt;/h3&gt;

&lt;p&gt;通过方法签名&lt;code class=&quot;highlighter-rouge&quot;&gt;initialize(tag_name, markup, tokens)&lt;/code&gt;可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;markup&lt;/code&gt;包含了代码语言和行号的声明。解析工作交给正则完成：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;`OPTIONS_SYNTAX = %r{^([a-zA-Z0-9.+#-]+)((\s+\w+(=[0-9,-]+)?)*)$}`
markup.strip =~ OPTIONS_SYNTAX&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以对于&lt;code class=&quot;highlighter-rouge&quot;&gt;\{\% prism ruby linenos=2,11-13 %}&lt;/code&gt;这样的代码块声明，我们能够得到语言&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby&lt;/code&gt;，行号&lt;code class=&quot;highlighter-rouge&quot;&gt;linenos=2,11-13&lt;/code&gt;。这部分基本不需要做修改，相关代码就不贴了。&lt;/p&gt;

&lt;h3 id=&quot;输出-html&quot;&gt;输出 HTML&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt;函数十分简单，我们按照 Prism 接受的 HTML 结构输出即可，这里我根据&lt;code class=&quot;highlighter-rouge&quot;&gt;linenos&lt;/code&gt;决定是否展示全部行号，另外通过&lt;code class=&quot;highlighter-rouge&quot;&gt;data-line&lt;/code&gt;配合 Prism 插件实现高亮特定行：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;# 转义内容
code = h(super).strip
linenos = &amp;#39;&amp;#39;
linenos_content = @options[&amp;quot;linenos&amp;quot;]
if !linenos_content.nil?
    linenos = &amp;quot;class=&amp;#39;line-numbers&amp;#39; data-line=&amp;#39;#{linenos_content}&amp;#39;&amp;quot;
end
# 返回 HTML 内容
&amp;lt;&amp;lt;-HTML
    &amp;lt;div&amp;gt;
      &amp;lt;pre #{linenos}&amp;gt;&amp;lt;code class=&amp;#39;language-#{@lang}&amp;#39;&amp;gt;#{code}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
    &amp;lt;/div&amp;gt;
HTML&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上代码有两点需要注意：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;类似 JS 中的字符串模版功能，Ruby 中也有类似的语法，在上面最终输出 HTML 内容中有使用，但是必须使用双引号包裹。&lt;/li&gt;
  &lt;li&gt;转义标签內的代码内容使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;h()&lt;/code&gt;函数，还记得开头引入的 StandardFilters 嘛，&lt;code class=&quot;highlighter-rouge&quot;&gt;h()&lt;/code&gt;是里面&lt;code class=&quot;highlighter-rouge&quot;&gt;escape()&lt;/code&gt;的&lt;a href=&quot;https://github.com/Shopify/liquid/blob/master/lib/liquid/standardfilters.rb#L35-L38&quot;&gt;同名函数&lt;/a&gt;。这个函数接受输入流（这里就是代码块内容），返回解析后的 HTML 字符串。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;深刻感觉到 jekyll 用的人真的不多了，很多插件都处于无人维护的状态。&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/08/10/%E5%9C%A8jekyll%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/08/10/%E5%9C%A8jekyll%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.html</guid>
        
        <category>ruby</category>
        
        <category>jekyll</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>垃圾围城</title>
        <description>&lt;p&gt;前两天听《反派影评》，节目里说到西宁 FIRST 电影展播放了纪录片《塑料王国》完整版。很早之前我看过半小时的&lt;a href=&quot;https://www.youtube.com/watch?v=TUmuOmEqXZQ&quot;&gt;媒体版本&lt;/a&gt;，但现在豆瓣此片的页面已经没了，据说影展结束后也不允许媒体再提这部片子。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/plastic-china-post.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/plastic-china-post.jpg&quot; data-alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;在我看的半小时版本中，影片讲述了大量“洋垃圾”漂洋过海来到中国某个小山村，村民们在及其恶劣的环境中，使用及其原始的方式手工进行分拣。整个村子的环境也被破坏。最震撼的一幕就是孩子们在垃圾堆中玩耍，其中一个随手捡起一个注射器就吸里面的水。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/plastic-china.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/plastic-china.jpg&quot; data-alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;这个版本并没有类似抨击政府不作为这样的激进作者表达，只是希望唤起社会对这些分拣垃圾村民的关注，而且国家已经出台法律禁止进口这些“洋垃圾”，所以被禁播很让人费解，到底在担心什么呢？&lt;/p&gt;

&lt;p&gt;不过相比《塑料王国》，导演王久良之前的另一部&lt;a href=&quot;https://www.youtube.com/watch?v=7zZ2K1rrqpE&quot;&gt;《垃圾围城》&lt;/a&gt;就没有这么克制了，直接将矛头对准了北京的垃圾处理机制。&lt;/p&gt;

&lt;p&gt;北京被周边的几百个垃圾处理场包围。人们从大山中开采城市化需要的砂石，挖出一个个大坑，然后将城市产生的垃圾回填。垃圾填埋场周边的地下地上水源都遭到了不同程度的污染。&lt;/p&gt;

&lt;p class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/garbage.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/garbage.jpg&quot; data-alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;em&gt;&lt;/em&gt;
&lt;/p&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
&lt;/script&gt;

&lt;p&gt;随着城市的不断扩张，终于需要在垃圾场上建起学校，廉租房。看着挖开地基后，显露出的一层层厚厚的垃圾，不禁让人感慨，曾经被我们丢弃的垃圾，换了一种面目又回到了我们身边。&lt;/p&gt;

&lt;p&gt;在影片中，作者看着被严重污染的通榆河，感慨为了解决北京的缺水问题，我们实现了南水北调，却对身边的水源毫不珍惜。从谷歌地图的历史照片中可以发现短短几年间，几片水域的颜色就由绿变黑。&lt;/p&gt;

&lt;p&gt;有一群人不得不终日与垃圾为邻，那就是来自全国各地的拾荒者。他们用垃圾中的建筑材料盖起了简易窝棚，从中获取衣物甚至是食物，将手工分拣出来的材料低价卖给回收站。&lt;/p&gt;

&lt;p&gt;我其实很好奇，对于这些垃圾，国际上先进的方法到底是什么，难道只有填埋这一种么。&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/movie/2017/08/05/%E5%9E%83%E5%9C%BE%E5%9B%B4%E5%9F%8E.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/movie/2017/08/05/%E5%9E%83%E5%9C%BE%E5%9B%B4%E5%9F%8E.html</guid>
        
        <category>movie</category>
        
        
        <category>movie</category>
        
      </item>
    
      <item>
        <title>浏览器的恢复滚动行为</title>
        <description>&lt;p&gt;平常使用浏览器的后退功能时，常常会发现返回的页面滚动到了之前的位置，而不是简单的回到顶部。这是由于浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。值得一提的是，在&lt;a href=&quot;http://www.w3.org/TR/html51/browsers.html#history&quot;&gt; HTML History Spec&lt;/a&gt;中并没有强制要求浏览器记录与恢复滚动距离。在传统的页面中，这一默认行为非常贴心，但是在 SPA 中存在以下问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;浏览器试图恢复滚动距离时，页面可能还没有加载完毕，可能存在异步加载的部分。这样恢复之后，页面会出现跳动。&lt;/li&gt;
  &lt;li&gt;点击链接进入页面就不会应用恢复滚动这一行为。对于开发者而言，希望提供统一的恢复滚动实现，而不是后退等历史记录这部分依赖浏览器。&lt;/li&gt;
  &lt;li&gt;浏览器的滚动行为让开发者无法实现滚动过程的动画。而且对于容器内滚动的设计，浏览器是无法帮助恢复的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;按照&lt;a href=&quot;https://majido.github.io/scroll-restoration-proposal/&quot;&gt;《浏览器恢复滚动提案》&lt;/a&gt;的介绍，针对这一问题，现在常见的解决方案包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不使用 body 滚动，采用容器内滚动的方式。但显然，这样会丢失一部分浏览器默认行为，例如滑动隐藏顶部地址栏。&lt;/li&gt;
  &lt;li&gt;在浏览器恢复滚动行为之后，进行第二次滚动。缺点是会有明显的用户感知。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;疑似方案&quot;&gt;疑似方案？&lt;/h2&gt;

&lt;p&gt;话说我们能监听到浏览器恢复滚动的行为么？&lt;/p&gt;

&lt;p&gt;浏览器恢复滚动时会触发 scroll 事件。但这里涉及到 scroll 和 popState 事件的触发顺序。Chrome 在恢复滚动之前会先触发 popState 事件，这就意味着我们可以在此时记录下页面的滚动距离，然后触发 scroll 时我们就能使用类似&lt;code class=&quot;highlighter-rouge&quot;&gt;window.scrollTo&lt;/code&gt;来手动恢复了。但是 Firefox 刚好相反，这样在 popState 中我们已经无法获取旧的滚动距离了，因为浏览器已经自动恢复了。&lt;/p&gt;

&lt;p&gt;事实上，在前端路由的设计中，通常都包含 hash 和 History 模式。在&lt;a href=&quot;https://github.com/ReactTraining/react-router/issues/707&quot;&gt; react-router的这个 ISSUE&lt;/a&gt;中，列举了 hashchange/popState 与 scroll 事件在 Chrome/Firefox 中的触发顺序，可以看出并不统一。
所以这个方案至少在兼容性上并不可行。&lt;/p&gt;

&lt;h2 id=&quot;引入新的-api&quot;&gt;引入新的 API&lt;/h2&gt;

&lt;p&gt;为了让开发者能够通过编程方式关闭这一浏览器行为，&lt;a href=&quot;https://majido.github.io/scroll-restoration-proposal/&quot;&gt;《浏览器恢复滚动提案》&lt;/a&gt;引入了新的 API：&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;if (&amp;#39;scrollRestoration&amp;#39; in history) {
    // 默认值为&amp;#39;auto&amp;#39;
    history.scrollRestoration = &amp;#39;manual&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据&lt;a href=&quot;https://developers.google.com/web/updates/2015/09/history-api-scroll-restoration&quot;&gt; Google 开发者文档&lt;/a&gt;，Chrome 46 以上已经实装。&lt;/p&gt;

&lt;p&gt;我自己也写了一个 demo 测试了一下确实可行，这或许才是最好的解决方案，等待其他浏览器厂商支持吧。&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%81%A2%E5%A4%8D%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%81%A2%E5%A4%8D%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA.html</guid>
        
        <category>browser</category>
        
        
        <category>coding</category>
        
      </item>
    
  </channel>
</rss>
