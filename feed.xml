<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xiaOp的博客</title>
    <description>分享写代码，听音乐，看电影的心得
</description>
    <link>https://xiaoiver.github.io/</link>
    <atom:link href="https://xiaoiver.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 25 Aug 2017 10:15:49 +0800</pubDate>
    <lastBuildDate>Fri, 25 Aug 2017 10:15:49 +0800</lastBuildDate>
    <generator>Jekyll v3.4.5</generator>
    
      <item>
        <title>判断元素是否在视口内</title>
        <description>&lt;p&gt;在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function inViewport( el, h ) {
    var elH = el.offsetHeight, // 元素高度
        scrolled = scrollY(), // 视口顶部距离document顶部的距离
        viewed = scrolled + getViewportH(), // 视口底部距离document的距离
        elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离
        elBottom = elTop + elH, // 元素底部距离document顶部的距离
        h = h || 0; // 高度系数
    return (elTop + elH * h) &amp;lt;= viewed &amp;amp;&amp;amp; (elBottom) &amp;gt;= scrolled;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方法的问题是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;读取元素尺寸数据时，会造成 re-layout，在滚动过程中会导致页面卡顿(jank)。&lt;/p&gt;

&lt;h2 id=&quot;intersectionobserver&quot;&gt;IntersectionObserver&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wicg.github.io/IntersectionObserver/&quot;&gt;IntersectionObserver&lt;/a&gt; 作为新引入的 API，异步查询元素相对于另一个元素（例如视口）的位置，不会影响主线程，可以解决检测方法带来的性能问题。&lt;/p&gt;

&lt;p&gt;首先我们需要创建一个观察对象，构造函数方法签名如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;new IntersectionObserver(entries =&amp;gt; {}, options);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随后将使用这个观察对象对元素的位置变化进行观测：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;io.observe(element);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;观察对象构造函数的第一个参数便是回调函数，这能避免旧方法中轮询带来的性能问题。
在回调函数中，传入的参数是一个数组（可以观测多个元素），每个元素对象包含以下属性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootBounds&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientRect&lt;/code&gt;对象，等同于对根元素（默认值为视口）调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;boundingClientRect&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientRect&lt;/code&gt;对象，等同于对被观测元素调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getBoundingClientRect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;intersectionRect&lt;/code&gt;，以上两个矩形的交集&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;intersectionRatio&lt;/code&gt;，被观测元素被覆盖的比例，如下图所示：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/intersectratio.png&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/intersectratio.png&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();
        }
    });
&lt;/script&gt;

&lt;p&gt;现在来看看观察对象的第二个参数，这是一个配置对象，其中包含3个重要的配置项：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;，默认值为视口，在容器内滚动的场景中，我们可以指定根元素为容器&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootMargin&lt;/code&gt;，顾名思义，值的格式与&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;一样&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;threshold&lt;/code&gt;，这个阈值甚至可以是一个列表，每次达到其中的一个阈值时都会触发回调函数，取值范围为[0-1]&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;observe()&lt;/code&gt;观测方法，自然也有解除观测方法&lt;code class=&quot;highlighter-rouge&quot;&gt;unobserve()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上就是这个新 API 的全部内容了，下面让我们看看在实际场景中如何应用吧。&lt;/p&gt;

&lt;h2 id=&quot;懒加载图片&quot;&gt;懒加载图片&lt;/h2&gt;

&lt;p&gt;有了这个新的 API，实现滚动到视口内加载图片就十分简单了，其实就是多了新的判断方法，不再需要在滚动事件中获取了。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 创建观测对象
let observer = new IntersectionObserver(entries =&amp;gt; {
    entries.forEach(entry =&amp;gt; {
        // 图片和视口有交集了
        if (entry.intersectionRatio &amp;gt; 0) {
            // 停止继续观测，直接加载
            observer.unobserve(entry.target);
            loadImage(entry.target);
        }
    });
}, {threshold: 0.01});

// 观测所有图片
images.forEach(image =&amp;gt; {
    observer.observe(image);
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，这里还有一些细节，例如：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;考虑浏览器兼容性，目前&lt;a href=&quot;https://caniuse.com/#feat=intersectionobserver&quot;&gt;最新版 Chrome 和 Firefox 支持&lt;/a&gt;良好。&lt;a href=&quot;https://github.com/WICG/IntersectionObserver/tree/gh-pages/polyfill&quot;&gt;polyfill&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;图片的 src 属性存放在例如 data-src 上&lt;/li&gt;
  &lt;li&gt;全部图片加载完毕，调用观测对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;disconnect()&lt;/code&gt;方法彻底关闭&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以参考&lt;a href=&quot;https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163&quot;&gt;这篇文章&lt;/a&gt;的实现。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2016/04/intersectionobserver&quot;&gt;Google Developer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hacks.mozilla.org/2017/08/intersection-observer-comes-to-firefox/&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163&quot;&gt;懒加载图片文章&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html</guid>
        
        <category>javascript</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>在 jekyll 中使用代码高亮</title>
        <description>&lt;p&gt;代码高亮是一个技术博客的重要特性，Jekyll 中默认使用&lt;a href=&quot;http://jekyllrb.com/docs/templates/#code-snippet-highlighting&quot;&gt; Rouge&lt;/a&gt;进行词法分析生成 DOM 结构，搭配自定义样式。使用 Python 编写的&lt;a href=&quot;http://pygments.org/&quot;&gt; Pygments&lt;/a&gt;也是一个可选方案。&lt;/p&gt;

&lt;p&gt;博客作者可以使用如下 markdown 语法插入代码块，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;linenos&lt;/code&gt;表示显示行号：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;\{\% highlight ruby linenos %}
    def foo
      puts &amp;#39;foo&amp;#39;
    end
    \{\% endhighlight %}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本来我是采用默认的 Rouge，但是发现样式有点丑，尤其是行号部分。而且有时我需要高亮显示若干行代码，例如这样：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;\{\% highlight ruby linenos=1-2 %}
    def foo
      puts &amp;#39;foo&amp;#39;
    end
    \{\% endhighlight %}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时 Rouge 就做不到了，而且 Rouge 和 Pygments 似乎很久没有更新了，想找一个漂亮的样式也不容易。&lt;/p&gt;

&lt;p&gt;我在网上搜了一下，发现了&lt;a href=&quot;http://prismjs.com/&quot;&gt; Prism&lt;/a&gt;这样一个库。MDN，Smashing magazine 很多技术网站都在使用，难怪样式看着有点眼熟。那么如何在 jekyll 中使用呢？&lt;/p&gt;

&lt;h2 id=&quot;编写-jekyll-插件&quot;&gt;编写 jekyll 插件&lt;/h2&gt;

&lt;p&gt;参考 Prism 文档，在项目中引入定制后的 JS 和 CSS 文件都很简单。值得一提的是之前提过的高亮特定行数的代码，可以通过&lt;a href=&quot;http://prismjs.com/plugins/line-highlight/&quot;&gt; Prism 插件&lt;/a&gt;实现。所以我们只需要关注如何通过 jekyll 插件将 markdown 代码块转换成对应的 HTML 代码即可。&lt;/p&gt;

&lt;p&gt;之前介绍过如何在&lt;a href=&quot;/coding/2017/07/22/%E5%9C%A8GithubPages%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6.html&quot;&gt; Github Pages 中使用第三方插件&lt;/a&gt;。由于我的博客在本地进行编译，所以只需要将插件放在&lt;code class=&quot;highlighter-rouge&quot;&gt;_plugins&lt;/code&gt;文件夹下即可。&lt;/p&gt;

&lt;p&gt;我搜索到一个&lt;a href=&quot;https://github.com/gmurphey/jekyll-prism-plugin&quot;&gt; jekyll 插件&lt;/a&gt;，已经很久没有维护了，ISSUE 也很久没有回复。看了代码后决定在此基础上进行修改，顺便学习一下自定义插件的相关知识。&lt;/p&gt;

&lt;h3 id=&quot;liquid&quot;&gt;Liquid&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; 是使用 Ruby 编写的模版引擎。jekyll 使用它进行 markdown 语法的解析。通过继承 Liquid 内部封装的类，可以自定义我们的语法块。&lt;/p&gt;

&lt;p&gt;以下是声明和注册代码，继承&lt;a href=&quot;http://www.rubydoc.info/gems/liquid/Liquid/Block&quot;&gt; Block&lt;/a&gt;而非 Tag 的原因很简单，我们需要使用闭合标签，类似&lt;code class=&quot;highlighter-rouge&quot;&gt;\{\% endprism %}&lt;/code&gt;，否则一旦解析到闭合标签就会报错了。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;2,11&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Jekyll
  class PrismBlock &amp;lt; Liquid::Block
    include Liquid::StandardFilters
    def initialize(tag_name, markup, tokens)
        super
    end

    def render(context)
    end
end
Liquid::Template.register_tag(&amp;#39;prism&amp;#39;, Jekyll::PrismBlock)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码中还引入了&lt;code class=&quot;highlighter-rouge&quot;&gt;StandardFilters&lt;/code&gt;，这个后续在输出 HTML 时会使用。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;3&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Jekyll
  class PrismBlock &amp;lt; Liquid::Block
    include Liquid::StandardFilters
end
Liquid::Template.register_tag(&amp;#39;prism&amp;#39;, Jekyll::PrismBlock)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;真正的处理逻辑将在两个方法：构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;initialize()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt;中完成。&lt;/p&gt;

&lt;h3 id=&quot;解析行号&quot;&gt;解析行号&lt;/h3&gt;

&lt;p&gt;通过方法签名&lt;code class=&quot;highlighter-rouge&quot;&gt;initialize(tag_name, markup, tokens)&lt;/code&gt;可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;markup&lt;/code&gt;包含了代码语言和行号的声明。解析工作交给正则完成：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;`OPTIONS_SYNTAX = %r{^([a-zA-Z0-9.+#-]+)((\s+\w+(=[0-9,-]+)?)*)$}`
markup.strip =~ OPTIONS_SYNTAX&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以对于&lt;code class=&quot;highlighter-rouge&quot;&gt;\{\% prism ruby linenos=2,11-13 %}&lt;/code&gt;这样的代码块声明，我们能够得到语言&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby&lt;/code&gt;，行号&lt;code class=&quot;highlighter-rouge&quot;&gt;linenos=2,11-13&lt;/code&gt;。这部分基本不需要做修改，相关代码就不贴了。&lt;/p&gt;

&lt;h3 id=&quot;输出-html&quot;&gt;输出 HTML&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt;函数十分简单，我们按照 Prism 接受的 HTML 结构输出即可，这里我根据&lt;code class=&quot;highlighter-rouge&quot;&gt;linenos&lt;/code&gt;决定是否展示全部行号，另外通过&lt;code class=&quot;highlighter-rouge&quot;&gt;data-line&lt;/code&gt;配合 Prism 插件实现高亮特定行：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;# 转义内容
code = h(super).strip
linenos = &amp;#39;&amp;#39;
linenos_content = @options[&amp;quot;linenos&amp;quot;]
if !linenos_content.nil?
    linenos = &amp;quot;class=&amp;#39;line-numbers&amp;#39; data-line=&amp;#39;#{linenos_content}&amp;#39;&amp;quot;
end
# 返回 HTML 内容
&amp;lt;&amp;lt;-HTML
    &amp;lt;div&amp;gt;
      &amp;lt;pre #{linenos}&amp;gt;&amp;lt;code class=&amp;#39;language-#{@lang}&amp;#39;&amp;gt;#{code}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
    &amp;lt;/div&amp;gt;
HTML&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上代码有两点需要注意：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;类似 JS 中的字符串模版功能，Ruby 中也有类似的语法，在上面最终输出 HTML 内容中有使用，但是必须使用双引号包裹。&lt;/li&gt;
  &lt;li&gt;转义标签內的代码内容使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;h()&lt;/code&gt;函数，还记得开头引入的 StandardFilters 嘛，&lt;code class=&quot;highlighter-rouge&quot;&gt;h()&lt;/code&gt;是里面&lt;code class=&quot;highlighter-rouge&quot;&gt;escape()&lt;/code&gt;的&lt;a href=&quot;https://github.com/Shopify/liquid/blob/master/lib/liquid/standardfilters.rb#L35-L38&quot;&gt;同名函数&lt;/a&gt;。这个函数接受输入流（这里就是代码块内容），返回解析后的 HTML 字符串。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;深刻感觉到 jekyll 用的人真的不多了，很多插件都处于无人维护的状态。&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/08/10/%E5%9C%A8jekyll%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/08/10/%E5%9C%A8jekyll%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.html</guid>
        
        <category>ruby</category>
        
        <category>jekyll</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>垃圾围城</title>
        <description>&lt;p&gt;前两天听《反派影评》，节目里说到西宁 FIRST 电影展播放了纪录片《塑料王国》完整版。很早之前我看过半小时的&lt;a href=&quot;https://www.youtube.com/watch?v=TUmuOmEqXZQ&quot;&gt;媒体版本&lt;/a&gt;，但现在豆瓣此片的页面已经没了，据说影展结束后也不允许媒体再提这部片子。&lt;/p&gt;

&lt;div class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/plastic-china-post.jpg&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/plastic-china-post.jpg&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();
        }
    });
&lt;/script&gt;

&lt;p&gt;在我看的半小时版本中，影片讲述了大量“洋垃圾”漂洋过海来到中国某个小山村，村民们在及其恶劣的环境中，使用及其原始的方式手工进行分拣。整个村子的环境也被破坏。最震撼的一幕就是孩子们在垃圾堆中玩耍，其中一个随手捡起一个注射器就吸里面的水。&lt;/p&gt;

&lt;div class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/plastic-china.jpg&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/plastic-china.jpg&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();
        }
    });
&lt;/script&gt;

&lt;p&gt;这个版本并没有类似抨击政府不作为这样的激进作者表达，只是希望唤起社会对这些分拣垃圾村民的关注，而且国家已经出台法律禁止进口这些“洋垃圾”，所以被禁播很让人费解，到底在担心什么呢？&lt;/p&gt;

&lt;p&gt;不过相比《塑料王国》，导演王久良之前的另一部&lt;a href=&quot;https://www.youtube.com/watch?v=7zZ2K1rrqpE&quot;&gt;《垃圾围城》&lt;/a&gt;就没有这么克制了，直接将矛头对准了北京的垃圾处理机制。&lt;/p&gt;

&lt;p&gt;北京被周边的几百个垃圾处理场包围。人们从大山中开采城市化需要的砂石，挖出一个个大坑，然后将城市产生的垃圾回填。垃圾填埋场周边的地下地上水源都遭到了不同程度的污染。&lt;/p&gt;

&lt;div class=&quot;responsive-image&quot;&gt;
    &lt;img class=&quot;responsive-image__placeholder&quot; src=&quot;/img/resized/480/garbage.jpg&quot; /&gt;
    &lt;div class=&quot;responsive-image__delayed&quot; data-src=&quot;/img/resized/{width}/garbage.jpg&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    new Imager('.responsive-image__delayed', {
        availableWidths: [480],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();
        }
    });
&lt;/script&gt;

&lt;p&gt;随着城市的不断扩张，终于需要在垃圾场上建起学校，廉租房。看着挖开地基后，显露出的一层层厚厚的垃圾，不禁让人感慨，曾经被我们丢弃的垃圾，换了一种面目又回到了我们身边。&lt;/p&gt;

&lt;p&gt;在影片中，作者看着被严重污染的通榆河，感慨为了解决北京的缺水问题，我们实现了南水北调，却对身边的水源毫不珍惜。从谷歌地图的历史照片中可以发现短短几年间，几片水域的颜色就由绿变黑。&lt;/p&gt;

&lt;p&gt;有一群人不得不终日与垃圾为邻，那就是来自全国各地的拾荒者。他们用垃圾中的建筑材料盖起了简易窝棚，从中获取衣物甚至是食物，将手工分拣出来的材料低价卖给回收站。&lt;/p&gt;

&lt;p&gt;我其实很好奇，对于这些垃圾，国际上先进的方法到底是什么，难道只有填埋这一种么。&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/movie/2017/08/05/%E5%9E%83%E5%9C%BE%E5%9B%B4%E5%9F%8E.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/movie/2017/08/05/%E5%9E%83%E5%9C%BE%E5%9B%B4%E5%9F%8E.html</guid>
        
        <category>movie</category>
        
        
        <category>movie</category>
        
      </item>
    
      <item>
        <title>浏览器的恢复滚动行为</title>
        <description>&lt;p&gt;平常使用浏览器的后退功能时，常常会发现返回的页面滚动到了之前的位置，而不是简单的回到顶部。这是由于浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。值得一提的是，在&lt;a href=&quot;http://www.w3.org/TR/html51/browsers.html#history&quot;&gt; HTML History Spec&lt;/a&gt;中并没有强制要求浏览器记录与恢复滚动距离。在传统的页面中，这一默认行为非常贴心，但是在 SPA 中存在以下问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;浏览器试图恢复滚动距离时，页面可能还没有加载完毕，可能存在异步加载的部分。这样恢复之后，页面会出现跳动。&lt;/li&gt;
  &lt;li&gt;点击链接进入页面就不会应用恢复滚动这一行为。对于开发者而言，希望提供统一的恢复滚动实现，而不是后退等历史记录这部分依赖浏览器。&lt;/li&gt;
  &lt;li&gt;浏览器的滚动行为让开发者无法实现滚动过程的动画。而且对于容器内滚动的设计，浏览器是无法帮助恢复的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;按照&lt;a href=&quot;https://majido.github.io/scroll-restoration-proposal/&quot;&gt;《浏览器恢复滚动提案》&lt;/a&gt;的介绍，针对这一问题，现在常见的解决方案包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不使用 body 滚动，采用容器内滚动的方式。但显然，这样会丢失一部分浏览器默认行为，例如滑动隐藏顶部地址栏。&lt;/li&gt;
  &lt;li&gt;在浏览器恢复滚动行为之后，进行第二次滚动。缺点是会有明显的用户感知。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;疑似方案&quot;&gt;疑似方案？&lt;/h2&gt;

&lt;p&gt;话说我们能监听到浏览器恢复滚动的行为么？&lt;/p&gt;

&lt;p&gt;浏览器恢复滚动时会触发 scroll 事件。但这里涉及到 scroll 和 popState 事件的触发顺序。Chrome 在恢复滚动之前会先触发 popState 事件，这就意味着我们可以在此时记录下页面的滚动距离，然后触发 scroll 时我们就能使用类似&lt;code class=&quot;highlighter-rouge&quot;&gt;window.scrollTo&lt;/code&gt;来手动恢复了。但是 Firefox 刚好相反，这样在 popState 中我们已经无法获取旧的滚动距离了，因为浏览器已经自动恢复了。&lt;/p&gt;

&lt;p&gt;事实上，在前端路由的设计中，通常都包含 hash 和 History 模式。在&lt;a href=&quot;https://github.com/ReactTraining/react-router/issues/707&quot;&gt; react-router的这个 ISSUE&lt;/a&gt;中，列举了 hashchange/popState 与 scroll 事件在 Chrome/Firefox 中的触发顺序，可以看出并不统一。
所以这个方案至少在兼容性上并不可行。&lt;/p&gt;

&lt;h2 id=&quot;引入新的-api&quot;&gt;引入新的 API&lt;/h2&gt;

&lt;p&gt;为了让开发者能够通过编程方式关闭这一浏览器行为，&lt;a href=&quot;https://majido.github.io/scroll-restoration-proposal/&quot;&gt;《浏览器恢复滚动提案》&lt;/a&gt;引入了新的 API：&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;if (&amp;#39;scrollRestoration&amp;#39; in history) {
    // 默认值为&amp;#39;auto&amp;#39;
    history.scrollRestoration = &amp;#39;manual&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据&lt;a href=&quot;https://developers.google.com/web/updates/2015/09/history-api-scroll-restoration&quot;&gt; Google 开发者文档&lt;/a&gt;，Chrome 46 以上已经实装。&lt;/p&gt;

&lt;p&gt;我自己也写了一个 demo 测试了一下确实可行，这或许才是最好的解决方案，等待其他浏览器厂商支持吧。&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Aug 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%81%A2%E5%A4%8D%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/08/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%81%A2%E5%A4%8D%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA.html</guid>
        
        <category>browser</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>为vue项目添加骨架屏</title>
        <description>&lt;p&gt;前段时间阅读了&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/&quot;&gt;饿了么的 PWA 升级实践&lt;/a&gt;一文，受益匪浅。其中&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/#在构建时使用-vue-预渲染骨架屏&quot;&gt;构建时使用 Vue 预渲染骨架屏&lt;/a&gt;一节，为开发者提供了减少白屏时间，提升用户感知体验的新思路。本文将借鉴这一思路，尝试为 Vue 项目添加骨架屏。&lt;/p&gt;

&lt;h2 id=&quot;骨架屏是什么&quot;&gt;骨架屏是什么？&lt;/h2&gt;

&lt;p&gt;在 Google 提出的&lt;a href=&quot;https://developers.google.com/web/updates/2017/06/user-centric-performance-metrics&quot;&gt;以用户为中心&lt;/a&gt;的四个页面性能衡量指标中，FP/FCP(首屏渲染)可能是开发者最熟悉的了。下图来自&lt;a href=&quot;https://developers.google.com/web/updates/2017/06/user-centric-performance-metrics&quot;&gt;原文&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://developers.google.com/web/updates/images/2017/06/perf-metrics-load-timeline.png&quot; alt=&quot;google页面在各个阶段的截屏&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于尽快渲染出首屏，减少白屏时间，我能想到的优化方式大致有以下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优化 &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/&quot;&gt;Critical Rendering Path(关键渲染路径)&lt;/a&gt;，尽可能减少阻塞渲染的 JavaScript 和 CSS。常见做法包括使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;async/defer&lt;/code&gt; 让浏览器下载 JavaScript 的同时不阻塞 HTML 解析，内联页面关键部分的样式到 HTML 中等。&lt;/li&gt;
  &lt;li&gt;使用 Service Worker 缓存&lt;a href=&quot;https://developers.google.com/web/updates/2015/11/app-shell&quot;&gt; AppShell&lt;/a&gt;，加快后续访问速度。&lt;/li&gt;
  &lt;li&gt;使用 HTTP/2 Server Push，帮助浏览器尽早发现静态资源，减少请求数。&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26757514&quot;&gt;浅谈 HTTP/2 Server Push&lt;/a&gt;一文介绍了 Ele.me 在这方面的实践，推送 API 请求而非静态资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;骨架屏充分利用了前两点。下图来自原文&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/#为感知体验奋斗&quot;&gt;为感知体验奋斗&lt;/a&gt;一节。从图中的 Skeleton Screen (骨架屏)中可以看出，在页面完全渲染完成之前，用户会看到一个样式简单，描绘了当前页面的大致框架，感知到页面正在逐步加载，最终骨架屏中各个占位部分被完全替换，体验良好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://huangxuan.me/img/in-post/post-eleme-pwa/after-skeleton.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;骨架屏可以看成一个简单的关键渲染路径，由于只是页面的大致框架，样式不会太复杂，内联在 HTML 中体积很小。使用 Service Worker 缓存包含骨架屏的 HTML 页面之后，从缓存中取出展示速度更快。&lt;/p&gt;

&lt;h2 id=&quot;实现思路&quot;&gt;实现思路&lt;/h2&gt;

&lt;p&gt;参考原文中&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/#在构建时使用-vue-预渲染骨架屏&quot;&gt;在构建时使用 Vue 预渲染骨架屏&lt;/a&gt;一节介绍的思路，我将骨架屏也看成路由组件，在构建时使用 Vue 预渲染功能，将骨架屏组件的渲染结果 HTML 片段插入 HTML 页面模版的挂载点中，将样式内联到 head 标签中。这样等前端渲染完成时，Vue 将使用&lt;a href=&quot;https://ssr.vuejs.org/zh/hydration.html&quot;&gt;客户端混合&lt;/a&gt;，把挂载点中的骨架屏内容替换成真正的页面内容。&lt;/p&gt;

&lt;p&gt;有了以上思路，让我们看看如何为一个简单的 Vue 应用添加骨架屏。&lt;/p&gt;

&lt;h2 id=&quot;具体实现&quot;&gt;具体实现&lt;/h2&gt;

&lt;p&gt;为此我开发了一个 webpack 插件：&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin&quot;&gt;vue-skeleton-webpack-plugin&lt;/a&gt;。下面将从以下三方面介绍部分实现细节：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用 Vue 预渲染骨架屏&lt;/li&gt;
  &lt;li&gt;将骨架屏渲染结果插入 HTML 模版中&lt;/li&gt;
  &lt;li&gt;开发模式下插入各个骨架屏路由&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用-vue-预渲染骨架屏&quot;&gt;使用 Vue 预渲染骨架屏&lt;/h3&gt;

&lt;p&gt;我们使用 Vue 的&lt;a href=&quot;https://ssr.vuejs.org/zh/&quot;&gt;预渲染&lt;/a&gt;功能渲染骨架屏组件，不熟悉的同学可以先阅读官方文档中的&lt;a href=&quot;https://ssr.vuejs.org/zh/basic.html&quot;&gt;基本用法&lt;/a&gt;一节。&lt;/p&gt;

&lt;p&gt;首先需要创建一个仅使用骨架屏组件的入口文件：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// src/entry-skeleton.js

import Skeleton from &amp;#39;./Skeleton.vue&amp;#39;;
// 创建一个骨架屏 Vue 实例
export default new Vue({
    components: {
        Skeleton
    },
    template: &amp;#39;&amp;lt;skeleton /&amp;gt;&amp;#39;
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来创建一个用于服务端渲染的 webpack 配置对象，将刚创建的入口文件指定为 entry 依赖入口：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack.skeleton.conf.js
{
    target: &amp;#39;node&amp;#39;, // 区别默认的 &amp;#39;web&amp;#39;
    entry: resolve(&amp;#39;./src/entry-skeleton.js&amp;#39;), // 多页传入对象
    output: {
        libraryTarget: &amp;#39;commonjs2&amp;#39;
    },
    externals: nodeExternals({
        whitelist: /\.css$/
    }),
    plugins: []
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里只展示单页应用的情况，在多页应用中，指定 entry 为包含各个页面入口的对象即可。关于多页中的 webpack 配置对象示例，可参考&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/tree/master/examples/multipage&quot;&gt;插件的多页测试用例&lt;/a&gt;或者&lt;a href=&quot;https://github.com/lavas-project/lavas-template-vue-mpa&quot;&gt;Lavas MPA 模版&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后我们将这个 webpack 配置对象通过参数传入骨架屏插件中。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack.dev.conf.js
plugins: [
    new SkeletonWebpackPlugin({ // 我们编写的插件
        webpackConfig: require(&amp;#39;./webpack.skeleton.conf&amp;#39;)
    })
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;骨架屏插件运行时会使用 webpack 编译这个传入的配置对象，得到骨架屏的 bundle 文件。接下来只需要使用这个 bundle 文件内容创建一个 renderer，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;renderToString()&lt;/code&gt;方法就可以得到字符串形式的 HTML 渲染结果了。由于我们不需要将过程中的文件产物保存在硬盘中，使用内存文件系统&lt;a href=&quot;https://github.com/webpack/memory-fs&quot;&gt;memory-fs&lt;/a&gt;即可。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// vue-skeleton-webpack-plugin/src/ssr.js

const createBundleRenderer = require(&amp;#39;vue-server-renderer&amp;#39;).createBundleRenderer;
// 从内存文件系统中读取 bundle 文件
let bundle = mfs.readFileSync(outputPath, &amp;#39;utf-8&amp;#39;);
// 创建 renderer
let renderer = createBundleRenderer(bundle);
// 渲染得到 HTML
renderer.renderToString({}, (err, skeletonHtml) =&amp;gt; {});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认情况下，webpack 模块引用的样式内容是内嵌在 JavaScript bundle 中的。官方插件&lt;a href=&quot;https://github.com/webpack-contrib/extract-text-webpack-plugin&quot;&gt; ExtractTextPlugin&lt;/a&gt;可以进行样式分离。我们也使用这个插件，将骨架屏样式内容输出到单独的 CSS 文件中。
关于插件更多用法，可参考&lt;a href=&quot;https://doc.webpack-china.org/plugins/extract-text-webpack-plugin/&quot;&gt;官方文档&lt;/a&gt;或者&lt;a href=&quot;https://github.com/vuejs-templates/webpack/blob/master/template/build/utils.js&quot;&gt; Vue 基于 webpack 的模版&lt;/a&gt;。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// vue-skeleton-webpack-plugin/src/ssr.js

// 加入 ExtractTextPlugin 插件到 webpack 配置对象插件列表中
serverWebpackConfig.plugins.push(new ExtractTextPlugin({
    filename: outputCssBasename // 样式文件名
}));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，我们已经得到了骨架屏的渲染结果 HTML 和样式内容，接下来需要关心如何将结果注入 HTML 页面模版中。&lt;/p&gt;

&lt;h3 id=&quot;注入渲染结果&quot;&gt;注入渲染结果&lt;/h3&gt;

&lt;p&gt;Vue webpack 模版项目使用了&lt;a href=&quot;https://github.com/jantimon/html-webpack-plugin&quot;&gt; HTML Webpack Plugin&lt;/a&gt;生成 HTML 文件。参考该插件的&lt;a href=&quot;https://github.com/jantimon/html-webpack-plugin#events&quot;&gt; 事件说明&lt;/a&gt;，我们选择监听&lt;code class=&quot;highlighter-rouge&quot;&gt;html-webpack-plugin-before-html-processing&lt;/code&gt;事件，在事件的回调函数中，插件会传入当前待处理的 HTML 内容供我们进一步修改。&lt;/p&gt;

&lt;p&gt;我们知道骨架屏组件最终的渲染结果包含 HTML 和样式两部分，样式部分可以直接插入 head 标签內，而 HTML 需要插入挂载点中。插件使用者可以通过参数设置这个挂载点位置，默认将使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;看起来一切都很顺利，但是在多页应用中，情况会变的稍稍复杂。多页项目中通常会引入多个 HTML Webpack Plugin，例如我们在&lt;a href=&quot;https://github.com/lavas-project/lavas-template-vue-mpa&quot;&gt; Lavas MPA 模版&lt;/a&gt;中使用的&lt;a href=&quot;https://github.com/mutualofomaha/multipage-webpack-plugin&quot;&gt; Multipage Webpack 插件&lt;/a&gt;就是如此，这就会导致&lt;code class=&quot;highlighter-rouge&quot;&gt;html-webpack-plugin-before-html-processing&lt;/code&gt;事件被多次触发。&lt;/p&gt;

&lt;p&gt;在多页应用中，我们传给骨架屏插件的 webpack 配置对象是包含多个入口的：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack.skeleton.conf.js
entry: {
    page1: resolve(&amp;#39;./src/pages/page1/entry-skeleton.js&amp;#39;),
    page2: resolve(&amp;#39;./src/pages/page2/entry-skeleton.js&amp;#39;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这就意味着每次&lt;code class=&quot;highlighter-rouge&quot;&gt;html-webpack-plugin-before-html-processing&lt;/code&gt;事件触发时，骨架屏插件都需要识别出当前正在处理的入口文件，执行 webpack 编译当前页面对应的骨架屏入口文件，渲染对应的骨架屏组件。查找当前处理的入口文件过程如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// vue-skeleton-webpack-plugin/src/index.js

// 当前页面使用的所有 chunks
let usedChunks = htmlPluginData.plugin.options.chunks;
let entryKey;
// chunks 和所有入口文件的交集就是当前待处理的入口文件
if (Array.isArray(usedChunks)) {
    entryKey = Object.keys(skeletonEntries);
    entryKey = entryKey.filter(v =&amp;gt; usedChunks.indexOf(v) &amp;gt; -1)[0];
}
// 设置当前的 webpack 配置对象的入口文件和结果输出文件
webpackConfig.entry = skeletonEntries[entryKey];
webpackConfig.output.filename = `skeleton-${entryKey}.js`;
// 使用配置对象进行服务端渲染
ssr(webpackConfig).then(({skeletonHtml, skeletonCss}) =&amp;gt; {
    // 注入骨架屏 HTML 和 CSS 到页面 HTML 中
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，我们已经完成了骨架屏的渲染和注入工作，接下来有一个开发中的小问题需要关注。&lt;/p&gt;

&lt;h3 id=&quot;开发模式下插入路由&quot;&gt;开发模式下插入路由&lt;/h3&gt;

&lt;p&gt;前面说过，由于 Vue 会使用&lt;a href=&quot;https://ssr.vuejs.org/zh/hydration.html&quot;&gt;客户端混合&lt;/a&gt;，骨架屏内容在前端渲染完成后就会被替换，那么如何在开发时方便的查看调试呢？&lt;/p&gt;

&lt;p&gt;使用浏览器开发工具设置断点是一个办法，但如果能在开发模式中向路由文件插入骨架屏组件对应的路由规则，使各个页面的骨架屏能像其他路由组件一样被访问，将使开发调试变得更加方便。向路由文件插入规则代码的工作将在&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/blob/master/src/loader.js&quot;&gt;插件的 loader&lt;/a&gt;中完成。如果您对 webpack loader 还不了解，可以参阅&lt;a href=&quot;https://doc.webpack-china.org/concepts/loaders/&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我们需要向路由文件插入两类代码：引入骨架屏组件的代码和对应的路由规则对象。关于代码插入点，引入组件代码相对简单，放在文件顶部就行了，而路由规则需要插入路由对象数组中，目前我使用的是简单的字符串匹配来查找这个数组的起始位置。例如下面的例子中，需要向 loader 传入&lt;code class=&quot;highlighter-rouge&quot;&gt;routes: [&lt;/code&gt;来确定插入路由的位置。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// router.js

import Skeleton from &amp;#39;@/pages/Skeleton.vue&amp;#39;
routes: [
    { // 插入骨架屏路由
        path: &amp;#39;/skeleton&amp;#39;,
        name: &amp;#39;skeleton&amp;#39;,
        component: Skeleton
    }
    // ...其余路由规则
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在多页应用中，每个页面对应的骨架屏都需要插入代码，使用者可以通过占位符设置引入骨架屏组件语句和路由规则的模版。loader 在运行时会使用这些模版，用真实的骨架屏名称替换掉占位符。在下面的例子中，假设我们有&lt;code class=&quot;highlighter-rouge&quot;&gt;Page1.skeleton.vue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Page2.skeleton.vue&lt;/code&gt;这两个骨架屏，开发模式下可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;/skeleton-page1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/skeleton-page2&lt;/code&gt;访问这两个骨架屏路由。更多参数说明可以参考&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin#参数说明&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// webpack.dev.conf.js

module: {
    rules: [] // 其他规则
        .concat(SkeletonWebpackPlugin.loader({
            resource: resolve(&amp;#39;src/router.js&amp;#39;), // 目标路由文件
            options: {
                entry: [&amp;#39;page1&amp;#39;, &amp;#39;page2&amp;#39;], 
                importTemplate: &amp;#39;import [nameCap] from \&amp;#39;@/pages/[name]/[nameCap].skeleton.vue\&amp;#39;;&amp;#39;,
                routePathTemplate: &amp;#39;/skeleton-[name]&amp;#39;
            }
        }))
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;多页中的具体应用示例，可参考&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/tree/master/examples/multipage&quot;&gt;多页测试用例&lt;/a&gt;或者&lt;a href=&quot;https://github.com/lavas-project/lavas-template-vue-mpa&quot;&gt;Lavas MPA 模版&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;感谢&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/&quot;&gt;饿了么的 PWA 升级实践&lt;/a&gt;一文，提供了解决这个问题的思路。当然文章中包含的远不止骨架屏这方面，相信每个读者都会受益匪浅。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin&quot;&gt;插件&lt;/a&gt;使用中遇到任何问题，都欢迎提出&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/issues&quot;&gt; ISSUE&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;百度&lt;a href=&quot;https://lavas.baidu.com/&quot;&gt; Lavas&lt;/a&gt;是一个基于 Vue 的 PWA 解决方案，帮助开发者轻松搭建 PWA 站点。其中多个模版也使用了这个插件，欢迎大家试用并提出意见。&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/30/%E4%B8%BAvue%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E9%AA%A8%E6%9E%B6%E5%B1%8F.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/30/%E4%B8%BAvue%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E9%AA%A8%E6%9E%B6%E5%B1%8F.html</guid>
        
        <category>vue</category>
        
        <category>webpack</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>无用的keywords</title>
        <description>&lt;p&gt;我在博客中试用了一下&lt;a href=&quot;https://github.com/jekyll/jekyll-seo-tag/&quot;&gt; jekyll-seo-tag 插件&lt;/a&gt;。它会从 jekyll &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;配置文件中提取字段，生成机器可读的元数据，供搜索引擎和社交工具使用。&lt;/p&gt;

&lt;p&gt;包括以下字段，此时打开控制台也能看到本页面中&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!-- Begin Jekyll SEO tag v2.2.3 --&amp;gt;&lt;/code&gt;开始就是这个插件添加的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;title，页面标题加上站点名称&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=description&amp;gt;&lt;/code&gt; 目测是取内容第一段，这就意味着文章不能以&lt;code class=&quot;highlighter-rouge&quot;&gt;## 第一段标题&lt;/code&gt;这样开头了，否则&lt;code class=&quot;highlighter-rouge&quot;&gt;description&lt;/code&gt;中就只有&lt;code class=&quot;highlighter-rouge&quot;&gt;第一段标题&lt;/code&gt;这点内容了&lt;/li&gt;
  &lt;li&gt;Canonical URL 标准格式&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/structured-data/&quot;&gt;JSON-LD&lt;/a&gt;格式的站点数据，供搜索引擎使用&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ogp.me/&quot;&gt;Open Graph&lt;/a&gt;数据，供社交工具使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后我发现这里面居然不包括&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=keywords&amp;gt;&lt;/code&gt;，我之前一直认为这个标签在 SEO 中很重要。&lt;/p&gt;

&lt;p&gt;有相同疑问的肯定不止我一个，有人就对这个问题提出了&lt;a href=&quot;https://github.com/jekyll/jekyll-seo-tag/issues/9&quot;&gt;ISSUE&lt;/a&gt;。插件作者甩出了用 Google 搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;meta tags seo&lt;/code&gt;关键词的前两个链接，然后提问者就默默关闭了 ISSUE。&lt;/p&gt;

&lt;h2 id=&quot;无用的-keywords&quot;&gt;无用的 keywords&lt;/h2&gt;

&lt;p&gt;我看了下搜索结果中的&lt;a href=&quot;http://www.wordstream.com/meta-tags&quot;&gt;第一篇文章&lt;/a&gt;，这才恍然大悟。&lt;/p&gt;

&lt;p&gt;文章指出 Google 在 ranking 时，已经不考虑&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=keywords&amp;gt;&lt;/code&gt;这个标签了。原因是这个标签过去被滥用太多了，而且也很容易被滥用。。。&lt;/p&gt;

&lt;p&gt;但是 meta 家族中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=description&amp;gt;&lt;/code&gt;毕竟会被直接展示在搜索结果中，所以作为页面开发者不能忽略。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.wordstream.com/images/screenshots/meta-description-tag.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那 Baidu 是怎么做的呢？&lt;a href=&quot;https://www.quora.com/Is-the-meta-keyword-tag-a-factor-in-Baidu&quot;&gt;Quora上有相应的一个问题&lt;/a&gt;，里面有答主给出了一份巨详细的&lt;a href=&quot;http://www.dragonmetrics.com/baidu-seo-guide/&quot;&gt;研究报告&lt;/a&gt;，分成10个章节介绍百度的 SEO 问题。&lt;/p&gt;

&lt;p&gt;从&lt;a href=&quot;http://www.dragonmetrics.com/baidu-seo-guide/#ch1&quot;&gt;第一节&lt;/a&gt;的内容来看，Baidu 并没有完全放弃 keywords，并且疑似将 descripton 也纳入 ranking，虽然可能权重不一定很高。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;However, Baidu may still use meta keywords as a ranking signal. There is also some evidence that supports the possibility that meta descriptions may even affect rankings on Baidu, in addition to being used for the SERP snippet.&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 24 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/23/%E6%97%A0%E7%94%A8%E7%9A%84keywords.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/23/%E6%97%A0%E7%94%A8%E7%9A%84keywords.html</guid>
        
        <category>ruby</category>
        
        <category>jekyll</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>在Github Pages中使用第三方插件</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;能够帮助我们托管 jekyll 项目，我们只需要将代码提交到指定分支(master/gh-pages)，github 将自动完成构建。&lt;/p&gt;

&lt;p&gt;jekyll 项目不可避免的会使用各种各样的插件，而 Github Pages 目前仅支持到 jekyll 3.4.5 版本，新版本在&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;中对插件的使用方法发生了变更，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins&lt;/code&gt;代替旧版本的属性&lt;code class=&quot;highlighter-rouge&quot;&gt;gems&lt;/code&gt;。所以为了兼容 Github Pages，本地新版本的警告提示信息只能选择忽略了。&lt;/p&gt;

&lt;p&gt;和在本地构建不同的一点是，github 构建时会加上&lt;code class=&quot;highlighter-rouge&quot;&gt;--save&lt;/code&gt;参数，只运行&lt;a href=&quot;https://pages.github.com/versions/&quot;&gt;信任的插件&lt;/a&gt;。这就导致如果我们的博客使用了不在白名单中的插件，github 构建时就会提示警告（在项目标签页 Setting -&amp;gt; GitHub Pages 中），构建失败也就看不到最新的博客内容了。&lt;/p&gt;

&lt;p&gt;Github Pages 给出一种建议是，让用户在本地构建站点，然后仅将构建结果纳入版本控制，提交到指定分支。避免 github 构建，只需要在根目录下放一个空文件&lt;code class=&quot;highlighter-rouge&quot;&gt;.nojekyll&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;至于本地构建，熟悉 Node.js 的开发者完全可以采用 gulp/grunt 工作流，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt;构建站点，顺便还能做一些静态资源压缩的工作。我在网上找到一种使用 rakefile 的&lt;a href=&quot;https://www.sitepoint.com/jekyll-plugins-github/&quot;&gt;简单方法&lt;/a&gt;，决定一试。&lt;/p&gt;

&lt;h2 id=&quot;使用-rakefile-构建&quot;&gt;使用 Rakefile 构建&lt;/h2&gt;

&lt;p&gt;首先我们需要拷贝原有 repo 内容到一个新文件夹中，以后这个新文件夹将成为我们的工作文件夹。由于以后我们不会再在原有 repo 中进行写作，所以此时可以在 repo 中执行&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm -r ./&lt;/code&gt;清空所有版本控制。&lt;/p&gt;

&lt;p&gt;在新文件夹中增加 Rakefile，进行如下操作：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt;构建站点&lt;/li&gt;
  &lt;li&gt;清空真正的 repo 内容，拷贝&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt;文件夹内容到里面。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;GH_PAGES_DIR = &amp;quot;xiaoiver.github.io&amp;quot;

desc &amp;quot;Build Jekyll site and copy files&amp;quot;
task :build do
  system &amp;quot;jekyll build&amp;quot;
  system &amp;quot;rm -r ../#{GH_PAGES_DIR}/*&amp;quot; unless Dir[&amp;#39;../#{GH_PAGES_DIR}/*&amp;#39;].empty?
  system &amp;quot;cp -r _site/* ../#{GH_PAGES_DIR}/&amp;quot;
end&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Rakefile 只在构建时使用，所以需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;中过滤掉，避免拷贝到结果文件夹中：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-yml&quot;&gt;exclude: [Rakefile]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后回到 repo 中，提交修改即可。&lt;/p&gt;

&lt;h2 id=&quot;使用-gulp-工作流构建&quot;&gt;使用 gulp 工作流构建&lt;/h2&gt;

&lt;p&gt;例如这个基于 yeoman 的&lt;a href=&quot;https://github.com/nirgn975/generator-jekyll-starter-kit&quot;&gt;模版项目&lt;/a&gt;，包含了对 PWA 的支持。&lt;/p&gt;

&lt;p&gt;这个模版在构建时使用 gulp 通过 sw-precache 生成&lt;code class=&quot;highlighter-rouge&quot;&gt;service-worker.js&lt;/code&gt;，缓存&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt;文件夹内全部静态资源。同时也定义了其他 task 用于压缩静态文件。&lt;/p&gt;

&lt;p&gt;我在博客中也使用了这种方式。&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/22/%E5%9C%A8GithubPages%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/22/%E5%9C%A8GithubPages%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6.html</guid>
        
        <category>ruby</category>
        
        <category>jekyll</category>
        
        <category>github-pages</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>为npm包提供多入口</title>
        <description>&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;

&lt;p&gt;之前给&lt;a href=&quot;https://github.com/van-nguyen/webpack-cdn-plugin&quot;&gt;webpack-cdn-plugin&lt;/a&gt;提PR时，遇到这样一个问题，入口文件使用了部分 ES6 特性，而作者不想直接提供转译版本，这就导致在低版本 Node.js 环境无法直接运行。&lt;/p&gt;

&lt;p&gt;首先想到的办法是，能不能提供多个版本。但是&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;只能支持单文件，无法提供多入口供使用者根据自身环境选择。&lt;/p&gt;

&lt;p&gt;后来采用的做法是在入口文件中判断当前运行环境，使用动态&lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;来选择转译或非转译版本。等于说模块开发者需要判断使用者当前的运行环境，总感觉不太优雅。&lt;/p&gt;

&lt;p&gt;前段时间刚好看到&lt;a href=&quot;http://2ality.com/2017/04/setting-up-multi-platform-packages.html&quot;&gt;这一系列文章&lt;/a&gt;，里面针对这个问题给出了较为全面的解决方案。&lt;/p&gt;

&lt;h2 id=&quot;多种模块格式版本&quot;&gt;多种模块格式版本&lt;/h2&gt;

&lt;p&gt;我们都知道模块格式包括了以下几种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AMD 浏览器端异步模块机制&lt;/li&gt;
  &lt;li&gt;CJS Node.js同步模块机制，浏览器端想使用必须先使用类似 webpack 之类的工具编译成异步的&lt;/li&gt;
  &lt;li&gt;ESM ES6提出的内置机制，支持同步和异步，部分浏览器已支持，Node.js 计划2018年实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为模块提供者，我们自然希望兼容更多模块格式，还好 UMD 提供了一系列兼容 AMD 和 CJS 的方案，例如支持&lt;a href=&quot;https://github.com/umdjs/umd/blob/master/templates/nodeAdapter.js&quot;&gt;在 Node.js 中写 AMD 标准的代码&lt;/a&gt;。这些模版范式为模块提供者提供了极大便利。&lt;/p&gt;

&lt;p&gt;是时候说说 ESM 了。它提供了统一的&lt;code class=&quot;highlighter-rouge&quot;&gt;import/export&lt;/code&gt;，真正统一了浏览器和 Node.js 端的模块标准。而且配合 Webpack 和 Rollup 提供的 &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;Tree-shaking&lt;/a&gt; 技术可以最大程度精简代码。那么问题来了，在 ESM 一统天下之前，如何提供使用 ESM 编写的代码给先进的打包工具，同时又不至于完全失去兼容性。换句话说，&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;中真的只有&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;这一个暴露模块入口文件的属性吗？&lt;/p&gt;

&lt;p&gt;显然不是，来看看这两个属性吧：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;module，还&lt;a href=&quot;https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md&quot;&gt;处于提案阶段&lt;/a&gt;，提供使用 ESM 编写的版本&lt;/li&gt;
  &lt;li&gt;browser，提供仅针对浏览器环境版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于打包工具来说，就不能只考虑&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;入口了。
在 webpack 中，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve.mainFields&lt;/code&gt;来指定模块查找优先级。
而这个优先级又是根据目标环境确定的，例如针对浏览器环境，即&lt;code class=&quot;highlighter-rouge&quot;&gt;target: 'web'&lt;/code&gt;，默认的优先级为：&lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;browser&quot;, &quot;module&quot;, &quot;main&quot;]&lt;/code&gt;。而服务端渲染中常用的&lt;code class=&quot;highlighter-rouge&quot;&gt;target: 'node'&lt;/code&gt;查找优先级为&lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;module&quot;, &quot;main&quot;]&lt;/code&gt;。可以看出，webpack 会优先使用 ESM 标准的代码。&lt;/p&gt;

&lt;p&gt;看起来支持不同模块格式的问题解决了。&lt;/p&gt;

&lt;h2 id=&quot;转译和非转译版本&quot;&gt;转译和非转译版本&lt;/h2&gt;

&lt;p&gt;除了支持不同的模块格式，代码中使用了新特性，是否需要转译也是一个问题。&lt;/p&gt;

&lt;p&gt;Angular 提出在&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;中新增&lt;code class=&quot;highlighter-rouge&quot;&gt;es2015&lt;/code&gt;属性，用来指定使用 ES6 的非转译代码入口。&lt;/p&gt;

&lt;p&gt;当然，最好能参考 babel-preset-env 的做法，也根据运行环境决定是否需要使用转译版本的代码。&lt;/p&gt;

&lt;h3 id=&quot;babel-preset-env&quot;&gt;babel-preset-env&lt;/h3&gt;

&lt;p&gt;首先看看&lt;code class=&quot;highlighter-rouge&quot;&gt;babel-preset-env&lt;/code&gt;是如何使用的。针对浏览器环境：&lt;/p&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&amp;quot;babel&amp;quot;: {
    &amp;quot;presets&amp;quot;: [
        [
            &amp;quot;env&amp;quot;,
            {
                &amp;quot;targets&amp;quot;: {
                    &amp;quot;browsers&amp;quot;: [&amp;quot;last 2 versions&amp;quot;, &amp;quot;ie &amp;gt;= 7&amp;quot;]
                }
            }
        ]
    ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;针对 Node.js 环境：&lt;/p&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&amp;quot;babel&amp;quot;: {
    &amp;quot;presets&amp;quot;: [
        [
            &amp;quot;env&amp;quot;,
            {
                &amp;quot;targets&amp;quot;: {
                    &amp;quot;node&amp;quot;: &amp;quot;current&amp;quot;
                }
            }
        ]
    ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他重要的参数包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;modules 默认CJS，不转译&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;useBuiltIns 使用polyfill，注入类似&lt;code class=&quot;highlighter-rouge&quot;&gt;import &quot;core-js/modules/es7.string.pad-start&quot;;&lt;/code&gt;的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;esnext&quot;&gt;esnext&lt;/h3&gt;

&lt;p&gt;增加一个新的入口&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;。直接提供支持 stage4 以上特性的代码，不使用转译，使用ESM：&lt;/p&gt;
&lt;div&gt;
  &lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    ···
    &amp;quot;main&amp;quot;: &amp;quot;main.js&amp;quot;,
    &amp;quot;esnext&amp;quot;: {
        &amp;quot;main&amp;quot;: &amp;quot;main-esnext.js&amp;quot;,
        &amp;quot;browser&amp;quot;: &amp;quot;browser-specific-main-esnext.js&amp;quot;
    },
    ···
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://2ality.com/2017/06/pkg-esnext.html&quot;&gt;具体做法&lt;/a&gt;是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于模块开发者，提供非转译版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;对于使用者，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve.mainFields&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;加入，赋予最高优先级，同时告知 babel-loader 转译提供&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;的代码。剩下的就交给&lt;a href=&quot;http://2ality.com/2017/02/babel-preset-env.html&quot;&gt;babel-preset-env&lt;/a&gt;根据提供的配置环境自动引入需要的插件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;其他做法&quot;&gt;其他做法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;全部转译，耗时但是配置简单。webpack 插件大多采用这种方式。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/developit/081148d83348ebe9a1bc1ba0707e1bb8&quot;&gt;配置 babel-loader，只转译提供了 module 字段的依赖&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;根据文件后缀决定，&lt;code class=&quot;highlighter-rouge&quot;&gt;.js&lt;/code&gt;不转译，&lt;code class=&quot;highlighter-rouge&quot;&gt;.esm&lt;/code&gt;转译&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;作为模块提供者，我会采用&lt;code class=&quot;highlighter-rouge&quot;&gt;esnext&lt;/code&gt;的方式，即额外提供非转译版本。然后让使用者通过配置，根据自身运行环境选择使用不同的版本。&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/17/%E4%B8%BAnpm%E5%8C%85%E6%8F%90%E4%BE%9B%E5%A4%9A%E5%85%A5%E5%8F%A3.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/17/%E4%B8%BAnpm%E5%8C%85%E6%8F%90%E4%BE%9B%E5%A4%9A%E5%85%A5%E5%8F%A3.html</guid>
        
        <category>javascript</category>
        
        <category>nodejs</category>
        
        <category>babel</category>
        
        <category>webpack</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>使用ava和travis-ci</title>
        <description>&lt;p&gt;最近给 &lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin&quot;&gt;skeleton 插件&lt;/a&gt;加上了测试用例，顺便使用了下自动集成工具。&lt;/p&gt;

&lt;h2 id=&quot;ava&quot;&gt;&lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;ava&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;首先配置基本参数：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;// package.json

&amp;quot;ava&amp;quot;: {
    &amp;quot;concurrency&amp;quot;: 5,
    &amp;quot;failFast&amp;quot;: true,
    &amp;quot;files&amp;quot;: [
      &amp;quot;test/*.test.js&amp;quot;
    ],
    &amp;quot;require&amp;quot;: [
      &amp;quot;babel-register&amp;quot;
    ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用方法也很简单：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;import test from &amp;#39;ava&amp;#39;;
test(&amp;#39;it should run successfully&amp;#39;, async t =&amp;gt; {
    let {stats, errors} = webpackBuildStats;
    t.falsy(stats.hasWarnings() &amp;amp;&amp;amp; errors.hasWarnings());
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行时除了会输出测试用例结果，还会输出一张代码覆盖率表格，并标出未覆盖的代码行号。
测试代码覆盖率其实很有用，出现很低的覆盖率要么是代码本身问题，要么是测试用例覆盖不全。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ava-log.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;travis-ci&quot;&gt;travis ci&lt;/h2&gt;

&lt;p&gt;使用持续集成工具，每次提交时自动运行测试脚本。&lt;/p&gt;

&lt;p&gt;首先需要有项目的owner权限，授权给travis。&lt;/p&gt;

&lt;p&gt;然后在配置文件中我们可以：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;设置多个 Node.js 版本环境&lt;/li&gt;
  &lt;li&gt;提供安装依赖和脚本，这里就直接运行测试命令了&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-yml&quot;&gt;//.travis.yml

language: node_js
node_js:
  - &amp;quot;4&amp;quot;
  - &amp;quot;5&amp;quot;
  - &amp;quot;6&amp;quot;
install:
  - npm install
script:
  - npm test&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完成后就可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;README.md&lt;/code&gt;里加上build图标了。&lt;img src=&quot;https://travis-ci.org/lavas-project/vue-skeleton-webpack-plugin.svg?branch=master&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/16/%E4%BD%BF%E7%94%A8ava%E5%92%8Ctravis-ci.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/16/%E4%BD%BF%E7%94%A8ava%E5%92%8Ctravis-ci.html</guid>
        
        <category>ava</category>
        
        <category>travis</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>基于vue和webpack的skeleton插件</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这是一个基于 vue 的 webpack 插件，为单页和多页应用生成 skeleton，提升首屏展示体验。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果您还不了解 skeleton，可以参考&lt;a href=&quot;https://lavas.baidu.com/guide/vue/doc/vue/advanced/skeleton&quot;&gt;App Skeleton 介绍&lt;/a&gt;一文。&lt;/p&gt;

&lt;p&gt;github 地址：&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin&quot;&gt;https://github.com/lavas-project/vue-skeleton-webpack-plugin&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;

&lt;p&gt;参考&lt;a href=&quot;https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/#在构建时使用-vue-预渲染骨架屏&quot;&gt;饿了么的 PWA 升级实践&lt;/a&gt;一文，我们希望在构建时渲染 skeleton 组件，将渲染 DOM 插入 html 的挂载点中，同时将使用的样式通过 style 标签内联。这样在前端 JS 渲染完成之前，用户将看到页面的大致骨架，感知到页面是正在加载的。&lt;/p&gt;

&lt;p&gt;我们当然可以选择在开发时直接将页面骨架内容写入 html 模版中，但是这会带来两个问题：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;开发 skeleton 与其他组件体验不一致。&lt;/li&gt;
  &lt;li&gt;多页应用中多个页面可能共用同一个 html 模版，而又有独立的 skeleton。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们将看看插件在具体实现中是如何解决这两个问题的。&lt;/p&gt;

&lt;h2 id=&quot;实现思路&quot;&gt;实现思路&lt;/h2&gt;

&lt;p&gt;我们希望能够保证一致的开发体验，开发 skeleton 和其他组件没有任何不同。而且开发者不需要关心渲染结果是如何被注入 html 的。
下面我们将从渲染和注入这两方面展开介绍。&lt;/p&gt;

&lt;h3 id=&quot;渲染组件&quot;&gt;渲染组件&lt;/h3&gt;

&lt;p&gt;我们使用 vue 的&lt;a href=&quot;https://ssr.vuejs.org/zh/&quot;&gt;服务端渲染&lt;/a&gt;功能，接受 webpack 配置对象作为输入，输出渲染的 DOM 和样式。&lt;/p&gt;

&lt;p&gt;一个典型的用于服务端渲染的 webpack 配置对象如下，其中 entry 入口文件中使用了 skeleton 组件：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
    target: &amp;#39;node&amp;#39;,
    devtool: false,
    entry: resolve(&amp;#39;./src/entry-skeleton.js&amp;#39;), // 多页应用中传入数组
    output: Object.assign({}, baseWebpackConfig.output, {
        libraryTarget: &amp;#39;commonjs2&amp;#39;
    }),
    externals: nodeExternals({
        whitelist: /\.css$/
    }),
    plugins: []
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;多页中的 webpack 配置对象示例，可参考&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/tree/master/examples/multipage&quot;&gt;多页测试用例&lt;/a&gt;或者&lt;a href=&quot;https://github.com/lavas-project/lavas-template-vue-mpa&quot;&gt;Lavas MPA 模版&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;webpack 将使用传入的配置对象进行编译，由于我们不需要将最终产物保存在硬盘中，使用内存文件系统&lt;a href=&quot;https://github.com/webpack/memory-fs&quot;&gt;memory-fs&lt;/a&gt;能够减少不必要的I/O开销。最终会生成一个 bundle 文件，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;createBundleRenderer&lt;/code&gt;创建一个 renderer，就可以在 Node.js 环境得到渲染结果了。&lt;/p&gt;

&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const createBundleRenderer = require(&amp;#39;vue-server-renderer&amp;#39;).createBundleRenderer;
let bundle = mfs.readFileSync(outputPath, &amp;#39;utf-8&amp;#39;);
// 创建 renderer
let renderer = createBundleRenderer(bundle);
// 渲染得到 html
renderer.renderToString({}, (err, skeletonHtml) =&amp;gt; {
    if (err) {
        reject(err);
    }
    else {
        resolve({skeletonHtml, skeletonCss});
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，为了将样式从 JS 文件中分离，我们使用了&lt;a href=&quot;https://github.com/webpack-contrib/extract-text-webpack-plugin&quot;&gt; ExtractTextPlugin&lt;/a&gt;插件，将样式内容输出到单独的文件中。与 bundle 文件一样，输出样式文件也在内存文件系统中。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// vue-skeleton-webpack-plugin/src/ssr.js

// 加入 ExtractTextPlugin 插件到 webpack 配置对象中
serverWebpackConfig.plugins.push(new ExtractTextPlugin({
    filename: outputCssBasename
}));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，我们已经得到了全部渲染结果，接下来需要关心注入时机。&lt;/p&gt;

&lt;h3 id=&quot;注入渲染结果&quot;&gt;注入渲染结果&lt;/h3&gt;

&lt;p&gt;关于渲染结果的注入时机，我们参考&lt;a href=&quot;https://github.com/jantimon/html-webpack-plugin#events&quot;&gt;html-webpack-plugin的事件说明&lt;/a&gt;，选择在&lt;code class=&quot;highlighter-rouge&quot;&gt;html-webpack-plugin-before-html-processing&lt;/code&gt;事件回调函数中进行。在该回调函数中，插件除了能取得当前的 webpack 编译对象之外，当前处理的 html 内容也作为参数传入，便于插件进行修改。&lt;/p&gt;

&lt;p&gt;那么我们需要对 html 内容做哪些修改呢？skeleton 组件最终的渲染结果应该包含 DOM 结构和样式两部分，样式可以直接插入&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;/head&amp;gt;&lt;/code&gt;之前，而 DOM 的插入与挂载点相关（浏览器端渲染完毕后将替换 skeleton 内容），默认使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;&lt;/code&gt;，当然插件使用者可以通过参数传入。&lt;/p&gt;

&lt;p&gt;在多页应用中，相比单页情况会变的稍稍复杂。多页项目中通常会引入多个 html-webpack-plugin，例如我们在&lt;a href=&quot;https://github.com/lavas-project/lavas-template-vue-mpa&quot;&gt;Lavas MPA 模版&lt;/a&gt;中使用的&lt;a href=&quot;https://github.com/mutualofomaha/multipage-webpack-plugin&quot;&gt; multipage插件&lt;/a&gt;就是如此，这就会导致&lt;code class=&quot;highlighter-rouge&quot;&gt;html-webpack-plugin-before-html-processing&lt;/code&gt;事件被多次触发。我们需要在每次事件触发时识别出当前处理的入口文件，执行 webpack 编译当前页面对应的入口文件，渲染对应的 skeleton 组件。&lt;/p&gt;

&lt;p&gt;查找当前处理的入口文件过程如下：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// vue-skeleton-webpack-plugin/src/index.js

// 当前页面使用的所有 chunks
let usedChunks = htmlPluginData.plugin.options.chunks;
let entryKey;
// chunks 和所有入口文件的交集就是当前待处理的入口文件
if (Array.isArray(usedChunks)) {
    entryKey = Object.keys(skeletonEntries);
    entryKey = entryKey.filter(v =&amp;gt; usedChunks.indexOf(v) &amp;gt; -1)[0];
}
// 设置当前的 webpack 配置对象的入口文件和结果输出文件
webpackConfig.entry = skeletonEntries[entryKey];
webpackConfig.output.filename = `skeleton-${entryKey}.js`;
// 使用配置对象进行服务端渲染
ssr(webpackConfig).then(({skeletonHtml, skeletonCss}) =&amp;gt; {});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就完成了对多页面入口 skeleton 组件的渲染工作了。&lt;/p&gt;

&lt;h3 id=&quot;开发模式下插入路由&quot;&gt;开发模式下插入路由&lt;/h3&gt;

&lt;p&gt;由于 skeleton 的渲染结果在 JS 前端渲染完成后就会被替换，如何在开发时方便的查看呢？
使用浏览器开发工具设置断点，阻塞前端渲染可以做到，但如果能在开发模式中插入 skeleton 对应的路由规则，使多个页面的 skeleton 能像其他路由组件一样被访问，将使开发调试变得更加方便。&lt;/p&gt;

&lt;p&gt;向路由文件中注入代码的工作将在&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/blob/master/src/loader.js&quot;&gt; loader&lt;/a&gt;中完成。&lt;/p&gt;

&lt;p&gt;首先明确注入内容，我们希望通过路由组件的形式访问 skeleton，那么首先需要引入各个 skeleton 组件，然后增加对应的路由规则。具体到注入的代码，类似这样：&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;// router.js

// 引入 skeleton 组件
import Skeleton from &amp;#39;@/pages/Skeleton.vue&amp;#39;

// 插入routes
routes: [
    {
        path: &amp;#39;/skeleton&amp;#39;,
        name: &amp;#39;skeleton&amp;#39;,
        component: Skeleton
    }
    // ...其余路由规则
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在多页应用中，使用者可以通过占位符设置依赖语句和路由规则的模版，loader 在运行时会使用这些模版，用真实的 skeleton 名称替换掉占位符，&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/blob/master/src/loader.js#L27-L39&quot;&gt;插入多条语句&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多页中的具体应用示例，可参考&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/tree/master/examples/multipage&quot;&gt;多页测试用例&lt;/a&gt;或者&lt;a href=&quot;https://github.com/lavas-project/lavas-template-vue-mpa&quot;&gt;Lavas MPA 模版&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;参数说明&quot;&gt;参数说明&lt;/h2&gt;

&lt;p&gt;插件和 loader 使用的参数如下：&lt;/p&gt;

&lt;h3 id=&quot;skeletonwebpackplugin&quot;&gt;SkeletonWebpackPlugin&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;webpackConfig &lt;em&gt;必填&lt;/em&gt;，渲染 skeleton 的 webpack 配置对象&lt;/li&gt;
  &lt;li&gt;insertAfter &lt;em&gt;选填&lt;/em&gt;，渲染 DOM 结果插入位置，默认值为&lt;code class=&quot;highlighter-rouge&quot;&gt;'&amp;lt;div id=&quot;app&quot;&amp;gt;'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;skeletonwebpackpluginloader&quot;&gt;SkeletonWebpackPlugin.loader&lt;/h3&gt;

&lt;p&gt;参数分为两类：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://doc.webpack-china.org/configuration/module/#rule&quot;&gt; webpack模块规则&lt;/a&gt;，skeleton 对应的路由将被插入路由文件中，所以需要指定一个或多个路由文件，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;resource/include/test&lt;/code&gt;皆可指定 loader 应用的文件。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;options&lt;/code&gt; 将被传入 loader 中的参数对象，包含以下属性：
    &lt;ul&gt;
      &lt;li&gt;entry &lt;em&gt;必填&lt;/em&gt;，支持字符串和数组类型，对应页面入口的名称&lt;/li&gt;
      &lt;li&gt;importTemplate &lt;em&gt;选填&lt;/em&gt;，引入 skeleton 组件的表达式，默认值为&lt;code class=&quot;highlighter-rouge&quot;&gt;'import [nameCap] from \'@/pages/[nameCap].vue\';'&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;routePathTemplate &lt;em&gt;选填&lt;/em&gt;，路由路径，默认值为&lt;code class=&quot;highlighter-rouge&quot;&gt;'/skeleton-[name]'&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;insertAfter &lt;em&gt;选填&lt;/em&gt;，路由插入位置，默认值为&lt;code class=&quot;highlighter-rouge&quot;&gt;'routes: ['&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;importTemplate&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;routePathTemplate&lt;/code&gt;中可以使用以下占位符：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[name]&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;entry&lt;/code&gt;保持一致&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[nameCap]&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;entry&lt;/code&gt;首字母大写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如使用以下配置，将向路由文件&lt;code class=&quot;highlighter-rouge&quot;&gt;router.js&lt;/code&gt;中插入&lt;code class=&quot;highlighter-rouge&quot;&gt;'import Page1 from \'@/pages/Page1.vue\';'&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;'import Page2 from \'@/pages/Page2.vue\';'&lt;/code&gt;两条语句。
同时生成&lt;code class=&quot;highlighter-rouge&quot;&gt;/skeleton-page1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/skeleton-page2&lt;/code&gt;两条路由规则。&lt;/p&gt;
&lt;div&gt;
  &lt;pre class=&quot;line-numbers&quot; data-line=&quot;&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
    resource: &amp;#39;router.js&amp;#39;,
    options: {
        entry: [&amp;#39;page1&amp;#39;, &amp;#39;page2&amp;#39;],
        importTemplate: &amp;#39;import [nameCap] from \&amp;#39;@/pages/[nameCap].vue\&amp;#39;;&amp;#39;,
        routePathTemplate: &amp;#39;/skeleton-[name]&amp;#39;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更多详细说明可参考&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin#参数说明&quot;&gt; github上插件的参数说明部分&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;贡献代码&quot;&gt;贡献代码&lt;/h2&gt;

&lt;p&gt;在开发中遇到任何问题，都欢迎提出&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/issues&quot;&gt; ISSUE&lt;/a&gt;讨论。&lt;/p&gt;

&lt;p&gt;您也可以帮助我们完善&lt;a href=&quot;https://github.com/lavas-project/vue-skeleton-webpack-plugin/tree/master/examples&quot;&gt;测试用例&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Jul 2017 03:21:32 +0800</pubDate>
        <link>https://xiaoiver.github.io/coding/2017/07/15/%E5%9F%BA%E4%BA%8Evue%E5%92%8Cwebpack%E7%9A%84skeleton%E6%8F%92%E4%BB%B6.html</link>
        <guid isPermaLink="true">https://xiaoiver.github.io/coding/2017/07/15/%E5%9F%BA%E4%BA%8Evue%E5%92%8Cwebpack%E7%9A%84skeleton%E6%8F%92%E4%BB%B6.html</guid>
        
        <category>vue</category>
        
        <category>webpack</category>
        
        
        <category>coding</category>
        
      </item>
    
  </channel>
</rss>
