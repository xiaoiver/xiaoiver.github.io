<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>《Web Development With Node And Express》读书笔记</title>
    <meta name="description" content="读书笔记，碰到的问题
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://yourdomain.com/nodejs/express/2014/09/11/web-development-with-express-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">xiaOp写东西的地方</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">关于xiaOp</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">《Web Development With Node And Express》读书笔记</h1>
    <p class="post-meta">Sep 11, 2014</p>
  </header>

  <article class="post-content">
    <h2 id="ch3-start">ch3 start</h2>
<p>express中路由的顺序很重要，如果404handler放在routes之前，都会指向404页面。</p>

<p>配置静态资源目录
<code>app.use(express.static(__dirname + '/public'));</code>
使用时，路径相对于public</p>

<p><code>git init</code>创建一个新的repo
.gitignore中的条目也适用于子目录，所以*~将忽略所有备份文件</p>

<p><code>git add</code>命令只是增加改变而不是文件。<code>git add -A</code>增加全部。
<code>git commit -m "message"</code>提交改变
<code>git remote add origin git@github.com:xiaoiver/meadowlark.git</code>
<code>git push -u origin master</code></p>

<p>package.json包含了依赖。npm install进行安装
<code>javascript
{
    "dependencies": {
    "express": "^4.0.0",
    "express3-handlebars": "^0.5.0"
    }
}
</code>
exports可以封装方法供外界调用。</p>

<p>require加载路径<code>./</code>告诉node不去node_modules目录下查找</p>

<h2 id="ch5-qa">ch5 qa</h2>
<p>测试框架mocha，第三方js和css放在public/vendor下
assertion库chai</p>

<p>app.use中next()</p>

<h3 id="section">页面跳转测试</h3>
<p>headless browser PhantomJs,Zombie</p>

<p>zombie暂时还不支持windows平台</p>

<h3 id="section-1">两个错误</h3>
<ul>
  <li>mocha默认时间太短导致测试出错，通过<code>--timeout 15000</code><a href="http://stackoverflow.com/questions/16607039/in-mocha-testing-while-calling-asynchronous-function-how-to-avoid-the-timeout-er">增加时间</a>，Gruntfile.js中添加在option属性中</li>
  <li>done()的位置，通知mocha我们的工作已经完成，否则会报timeout error</li>
</ul>

<h3 id="section-2">逻辑测试</h3>
<p><code>npm install -g mocha</code>全局安装</p>

<p><code>mocha -u tdd -R spec qa/tests-unit.js</code>单元测试</p>

<h3 id="section-3">检验框架</h3>
<p><code>npm install -g jshint</code></p>

<p><code>jshint meadowlark.js</code></p>

<p><code>if( app.thing == null ) console.log( 'bleat!' );</code>会提示使用===代替==</p>

<h3 id="section-4">链接检测</h3>
<p>检测死链接，循环链接<a href="http://wummel.github.io/linkchecker">linkchecker</a></p>

<p><code>python setup.py build</code>需要安装request</p>

<ul>
  <li>首先安装pip<code>sudo apt-get install python-pip</code></li>
  <li>通过pip安装<code>pip install requests</code></li>
</ul>

<p><code>python setup.py install</code>时报错“python.h 没有那个文件或目录”</p>

<p>原因是没有安装Python的头文件和静态库包<code>sudo apt-get install python-dev</code></p>

<p><code>linkchecker http://localhost:3000</code>检查</p>

<h3 id="grunt">Grunt自动运行测试任务</h3>
<p>安装grunt命令行<code>sudo npm install -g grunt-cli</code></p>

<p>安装grunt<code>npm install --save-dev grunt</code></p>

<p>Grunt依赖插件完成工作如mocha,jshint和linkchecker。由于linkchecker没有对应插件
使用通用插件exec执行命令行。</p>

<p><code>npm install --save-dev grunt-cafe-mocha</code></p>

<p><code>npm install --save-dev grunt-contrib-jshint</code></p>

<p><code>npm install --save-dev grunt-exec</code></p>

<h3 id="section-5">注意</h3>
<ul>
  <li>grunt-contrib-jshint只允许包含文件，不想包含node_modules和public/vendor下的文件</li>
  <li><code>/**/</code>表示所有子文件夹下的文件</li>
  <li><code>grunt.option()</code>可以接收命令行传递的参数<code>grunt deploy --target=staging</code></li>
  <li>grunt –force强制执行所有测试，不会中断</li>
</ul>

<h3 id="section-6">持续集成</h3>
<p>Travis CI</p>

<h2 id="ch6-req-res">ch6 req res</h2>
<p>### 请求体
get请求没有请求体，post请求有</p>

<ul>
  <li>application/x-www-form-urlencoded 编码后的键值对</li>
  <li>multipart/form-data 支持文件上传</li>
  <li>application/json ajax请求</li>
</ul>

<h3 id="request">Request对象</h3>
<ul>
  <li>req.query 包含querystring(GET参数)中的键值对。</li>
  <li>req.body 包含POST参数，之所以叫”body”是因为POST参数包含在请求体中。</li>
  <li>req.cookies/req.signedCookies 从客户端传来的cookie，需要中间件支持</li>
  <li>req.headers 请求头</li>
  <li>req.xhr 来自ajax请求就返回true</li>
</ul>

<h3 id="response">Response对象</h3>
<ul>
  <li>res.status(code) 状态码</li>
  <li>res.cookie(name, value, [options]), res.clearCookie(name, [options])</li>
  <li>res.redirect([status], url) 状态码默认302，永久转移301</li>
  <li>res.send(body), res.send(status, body)</li>
  <li>res.json(json), res.json(status, json)</li>
  <li>res.jsonp(json), res.jsonp(status, json)</li>
  <li>res.format(object) 根据请求头中Accept返回不同内容，通常用在API中</li>
  <li>res.attachment([filename]), res.download(path, [filename], [callback])两个方法都将响应头Content-Disposition设置成attachment，浏览器会下载而不是展示内容。两个方法区别是前者只是设置响应头，还需要继续发送内容到客户端</li>
  <li>res.locals, res.render(view, [locals], callback) ch7</li>
</ul>

<h3 id="express">Express源码</h3>
<p>p61</p>

<h3 id="section-7">展示内容</h3>
<p>即使没有用到next()，也要显式写出告诉Express这是错误处理
<code>javascript
app.use(function(err, req, res, next){
    console.error(err.stack);
    res.status(500).render('error');
});
</code></p>

<h3 id="section-8">处理表单</h3>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/process-contact&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Received contact from &#39;</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span>
        <span class="s1">&#39; &lt;&#39;</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">email</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">);</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// save to database....</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">xhr</span> <span class="o">?</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span> <span class="nx">success</span><span class="o">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="o">:</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">redirect</span><span class="p">(</span><span class="mi">303</span><span class="p">,</span> <span class="s1">&#39;/thank-you&#39;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">ex</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">xhr</span> <span class="o">?</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="nx">error</span><span class="o">:</span> <span class="s1">&#39;Database error.&#39;</span> <span class="p">})</span> <span class="o">:</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">redirect</span><span class="p">(</span><span class="mi">303</span><span class="p">,</span> <span class="s1">&#39;/database-error&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span></code></pre></div>

<h3 id="api">提供api</h3>
<p>Restful GET,POST,PUT,DELETE，类似rails</p>

<p>app.get/post/put/del</p>

<h2 id="ch7-handlebars">ch7 handlebars</h2>
<p>js通过document.write生成html代码，但是存在问题
* 字符转意问题
* html代码中可能还包含js，让人抓狂
* 编辑中代码高亮等功能无效
* 可读性差</p>

<h3 id="jade">Jade</h3>
<p>Express<a href="http://jade-lang.com">作者</a></p>

<p>不需要闭合标签</p>

<h3 id="handlebars">Handlebars基础</h3>
<p>上下文对象<code>{ name: 'Buttercup' }</code>，在模板中通过``就能得到值</p>

<p>如果想要传递的是html代码，需要使用<code>}</code></p>

<h3 id="section-9">注释</h3>
<p>``和<!-- not-so-secret comment -->的区别就是后者能通过查看源码看到。</p>

<h3 id="section-10">块</h3>

<p><code>javascript
{
    currency: {
        name: 'United States dollars',
        abbrev: 'USD',
    },
    tours: [
        { name: 'Hood River', price: '$99.95' },
        { name: 'Oregon Coast', price, '$159.95' },
    ],
    specialsUrl: '/january-specials',
    currencies: [ 'USD', 'GBP', 'BTC' ],
}
</code>
使用<code>../</code>退回上一层上下文，``代表当前的上下文</p>

<p>```javascript</p>
<ul>
    
        
        <li>
             - 
            
                ()
            
        </li>
    
</ul>
<p>```
if和each都有可选的else块。</p>

<p>如果有一个helper叫foo，<code>指向它，而</code>指向当前上下文的同名属性。</p>

<h3 id="section-11">服务端模板</h3>

<p>安装handlebars<code>npm install --save express3-handlebars</code></p>

<p>改变扩展名<code>require('express3-handlebars').create({ extname: '.hbs' })</code></p>

<p>默认view cache只在生产模式下打开，在开发模式下打开<code>app.set('view cache', true);</code></p>

<h3 id="partials">partials</h3>
<p>和rails中一样，存放在views/partials/文件夹下，也可以建立子文件夹。 </p>

<p><code></code> ch10</p>

<h3 id="sections">sections</h3>
<p>handlebars中没有直接实现，但可以通过使用helper</p>

<p><code>javascript
var handlebars = require('express3-handlebars').create({
    defaultLayout:'main',
    helpers: {
        section: function(name, options){
            if(!this._sections) this._sections = {};
            this._sections[name] = options.fn(this);
            return null;
        }
    }
});
</code></p>

<h3 id="section-12">完善模板</h3>
<p>使用html5boilerplate</p>

<h3 id="handlebars-1">客户端handlebars</h3>
<p>Handlebars.compile()将模板编译返回一个function，接受传入的参数</p>

<h2 id="ch8-">ch8 表单处理</h2>
<p>推荐使用303重定向而不是302响应表单提交</p>

<p>重定向到
* 成功/失败页面，优点是易于统计，缺点是需要分配额外的url，用户需要导航到之前的页面
* 当前页面，带有flash信息作为反馈
* 新的页面，带有flash信息作为反馈</p>

<h3 id="express-1">使用Express处理表单</h3>
<p>安装<code>npm install --save body-parser</code>来处理POST请求体</p>

<p>在这种情况下使用303（302），不能使用301永久。否则浏览器会缓存重定向目的地。当第二次提交表单时，浏览器会直接访问目的地，表单就得不到处理。</p>

<h3 id="ajax">处理ajax表单</h3>
<p>通过<code>req.xhr || req.accepts('json,html')==='json'</code>判断ajax请求</p>

<p><code>res.send({success: true});</code>返回信息</p>

<h3 id="section-13">文件上传</h3>
<p>#### 使用Formidable，也可以使用ajax
<code>npm install --save formidable</code></p>

<p>files就是上传文件数组，fields是参数数组
<code>javascript
var form = new formidable.IncomingForm();
form.parse(req, function(err, fields, files){});
</code>
#### 使用jquery-file-upload上传
依赖ImageMagick<code>apt-get install imagemagick</code></p>

<p><a href="https://github.com/blueimp/jQuery-File-Upload/releases">下载</a></p>

<p><a href="https://github.com/blueimp/jQuery-File-Upload/wiki">更多配置</a></p>

<p><code>javascript
jqupload.fileHandler({
    uploadDir: function(){
        return __dirname + '/public/uploads/' + now;
    },
    uploadUrl: function(){
        return '/uploads/' + now;
    },
})(req, res, next);
</code></p>

<h2 id="ch9-cookiessessions">ch9 cookies&amp;sessions</h2>

<p><code>npm install --save cookie-parser</code></p>

<p><code>res.cookie('signed_monster', 'nom nom', { signed: true });</code>
options包括domain,path(包括子路径),maxAge(默认浏览器关闭就过期),secure(通过https发送),httpOnly(只允许server修改cookie，防止xss攻击)</p>

<p>实现session两种方式
* 都存放在cookie中
* cookie中只存唯一的标识，其他存在服务端</p>

<h3 id="session">内存session</h3>
<p>简单但是缺点是服务器重启则丢失，多个服务器session存放位置不确定。ch13</p>

<p><code>npm install --save express-session</code></p>

<p>接受options包括key(存放标识符的cookie名，默认是connect.sid),store(默认是MemoryStore),cookie</p>

<p><code>req.session.userName</code>，通过delete删除，置为null并不会删除</p>

<h3 id="sessionflash--message">使用session实现flash  message</h3>
<p>通过在url中加入querystring也可以实现，但是丑陋而且会被加入书签保存。</p>

<h2 id="ch10-">ch10 中间件</h2>

<ul>
  <li>app.VERB这样的路由处理器可以看成只处理一种http动词的中间件，反过来中间件也可以看成处理全部动词的处理器</li>
  <li>路由处理器需要path作为第一个参数，/*匹配全部path</li>
  <li>中间件可选path作为第一个参数，默认/*</li>
  <li>2参数req,res 3参数req,res,next 4参数error,req,res,next</li>
  <li>如果不调用next()，请求就会终止在这个中间件里，其他中间件和处理器不会得到调用。如果不通过res.send等方法返回客户端就会hang直到超时。</li>
</ul>

<p>app.use接受function作为参数，js中function返回一个function是很常见的
<code>app.use(express.static(...));</code></p>

<h3 id="section-14">常用中间件</h3>
<p>Connect中body-parser被移出了，需要单独安装
<code>npm install --save connect</code>
<code>var connect = require(connect);</code></p>

<p>body-parser包含json和urlencoded</p>

<h2 id="ch11-email">ch11 email</h2>
<p>### 接收邮件
<a href="http://bit.ly/simplesmtp">SimpleSMTP</a> <a href="http://haraka.github.com">Haraka</a></p>

<h3 id="html">html邮件</h3>
<p>阅读<a href="http://bit.ly/writing_html_email">html-email</a></p>

<p>简单<a href="http://htmlemailboilerplate.com">HTML Email Boilerplate</a></p>

<h3 id="nodemailer">Nodemailer</h3>
<p><code>npm install --save nodemailer</code></p>

<p>默认使用smtp
<code>npm install nodemailer-smtp-transport</code></p>

<p>Error: Greeting never received</p>

<h2 id="ch12-">ch12 生产环境</h2>

<h3 id="section-15">日志</h3>
<p>开发阶段使用Morgan，色彩化输出<code>npm install --save morgan</code></p>

<p>生产环境使用express-logger，周期性记录日志<code>npm install --save express-logger</code></p>

<p>修改<code>node_modules/express-logger/logger.js</code>中变量<code>defaultInterval</code>改变日志周期</p>

<p><code>NODE_ENV=production node meadowlark.js</code>启动时改变生产环境</p>

<h3 id="app-clusterscaling-out">使用app cluster进行scaling out</h3>
<p>每个cpu创建一个独立的server</p>

<p>如果script独立运行，<code>require.main === module</code>返回true，如果被其他脚本文件通过require加载，则返回false</p>

<p>书中验证当前响应请求worker的代码有错误，缺少next()导致浏览器hang</p>

<h3 id="section-16">异常处理</h3>
<p>简单的异常可以通过定义在所有路由之后的中间件处理：</p>

<p>```javascript
app.get(‘/fail’, function(req, res){
    throw new Error(‘Nope!’);
});
app.use(function(err, req, res, next){
    console.error(err.stack);
    app.status(500).render(‘500’);</p>

<p>});
```</p>

<p>但是异步抛出的异常如setTimeout(nextTick就是第二个参数为0的定时器)，当Node在空闲的时候才会处理。
但是问题是此时该请求的上下文环境都没了，服务器只能关闭。</p>

<p><code>javascript
app.get('/epic-fail', function(req, res){
    process.nextTick(function(){
        throw new Error('Kaboom!');
    });
});
</code></p>

<p>使用cluster能解决这个问题，关闭一个worker会重启一个新的worker。</p>

<h4 id="uncaughtexceptiondomains">如何优雅地关闭？uncaughtException和domains</h4>
<p>推荐使用domains，位于所有路由和中间件之前</p>

<p><code>javascript
app.use(function(req, res, next){
    // 创建domain
    var domain = require('domain').create();
    domain.on('error', function(err){
        console.error('DOMAIN ERROR CAUGHT\n', err.stack);
        try {
            // 给服务器最后5秒钟响应正在处理的请求，然后关闭
            setTimeout(function(){
                console.error('Failsafe shutdown.');
                process.exit(1);
            }, 5000);
            // 如果在集群中，退出，集群将不会分配请求
            var worker = require('cluster').worker;
            if(worker) worker.disconnect();
            // 服务器不接受请求
            server.close();
            try {
                // 使用错误处理器响应出错的请求
                next(err);
            } catch(err){
                // 如果处理器抛出异常，使用Node的api响应
                console.error('Express error mechanism failed.\n', err.stack);
                res.statusCode = 500;
                res.setHeader('content-type', 'text/plain');
                res.end('Server error.');
            }
        } catch(err){
            // 如果都没法处理，客户端最终超时，记录日志
            console.error('Unable to send 500 response.\n', err.stack);
        }
    });
    // 添加res和req到domain中，两个对象任何方法抛出的异常都会被domain捕获
    domain.add(req);
    domain.add(res);
    // 在domain上下文中执行下一个中间件
    domain.run(next);
});
// 其余中间件和路由
var server = http.createServer(app).listen(app.get('port'), function(){
    console.log('Listening on port %d.', app.get('port'));
});
</code></p>

<h3 id="section-17">压力测试</h3>

<p><code>npm install --save loadtest</code></p>

<p>p136</p>

<h2 id="ch13-">ch13 持久化</h2>

<h3 id="section-18">文件系统持久化</h3>

<p><code>javascript
fs.mkdirSync(dir); //创建文件夹
fs.renameSync(photo.path, path); //就是移动，formidable会将临时路径放在path中
</code>
### 数据库持久化</p>

<p>NOSQL类型：文档，键值对</p>

<p>使用MongoDB</p>

<h4 id="mongoosehttpmongoosejscom"><a href="http://mongoosejs.com/">Mongoose</a></h4>
<p>ODM 对象文档映射，类似ORM</p>

<p><code>npm install --save mongoose</code></p>

<p>之前rails时配置的mongodb，默认的journal有2-3G
<code>mongod --config /usr/local/MongoDB/mongod.conf --smallfiles</code></p>

<h4 id="section-19">数据库连接</h4>
<p><code>mongoose.connect()</code></p>

<h4 id="modelschema">创建Model和Schema</h4>
<p>view model将model提炼转换成更适合view展示的对象</p>

<p>find查询条件
```javascript
Vacation.find({ available: true }, function(err, vacations){</p>

<p>});
```</p>

<p>update()
<code>{ upsert: true }</code>当文档存在时，就更新，不然就创建。</p>

<p><code>{ $push: {}}</code>表示添加进array</p>

<h3 id="mongodbsession">使用MongoDB存储session</h3>
<p>放弃使用session-mongoose</p>

<p><code>npm install --save session-mongoose</code></p>

<p>使用<a href="https://github.com/TheRealCharDev/mongoose-session">mongoose-session</a></p>

<p><code>npm install --save mongoose-session</code></p>

<p>在数据库中：
update test.sessions query: { sid: “WNBIQ-sJoUbiJ0rt1UDfu_hUJwb6ZFso” }</p>

<p>使用Redis</p>

<h2 id="ch14-">ch14 路由</h2>

<p>路由中的路径会被转化成正则表达式</p>

<p><code>app.get('/staff/:city/:name', function(req, res){}）;</code></p>

<h3 id="section-20">组织路由规则</h3>

<ul>
  <li>给路由处理器命名，不用inline的方式</li>
  <li>全写在一个文件中，不断增长</li>
</ul>

<h3 id="module">在module中生命路由</h3>
<p>返回由包含method和handler属性的对象组成的数组</p>

<p><code>javascript
var routes = require('./routes.js')();
routes.forEach(function(route){
    app[route.method](route.handler);
})
</code></p>

<p>将所有路由移动到routes.js中</p>

<p><code>javascript
module.exports = function(app){
    app.get('/', function(req,res){
        app.render('home');
    }))
    //...
};
</code></p>

<p>在主文件中引入<code>require('./routes.js')(app);</code></p>

<p>进一步拆分，<code>/handlers/main.js</code>
<code>javascript
var fortune = require('../lib/fortune.js');
exports.home = function(req, res){
    res.render('home');
};
exports.about = function(req, res){
    res.render('about', {
        fortune: fortune.getFortune(),
        pageTestScript: '/qa/tests-about.js'
    } );
};
</code>
routes.js中引入
<code>javascript
var main = require('./handlers/main.js');
module.exports = function(app){
    app.get('/', main.home);
    app.get('/about', main.about);
    //...
};
</code></p>

<h3 id="view">自动显示view</h3>

<p><code>javascript
// 缓存
var autoViews = {};
var fs = require('fs');
app.use(function(req,res,next){
    var path = req.path.toLowerCase();
    // 查看缓存
    if(autoViews[path]) return res.render(autoViews[path]);
    if(fs.existsSync(__dirname + '/views' + path + '.handlebars')){
        autoViews[path] = path.replace(/^\//, ''); //去除头部的'/'
        return res.render(autoViews[path]);
    }
    next();
});
</code></p>

<h3 id="section-21">其他组织路由的方法</h3>

<blockquote>
  <p>The two most popular approaches to route organization are 
namespaced routing and resourceful routing.</p>
</blockquote>

<p>express-namespace express-resource</p>

<h2 id="ch15-rest-api--json">ch15 REST API &amp; JSON</h2>

<p><code>mocha -u tdd -R spec qa/tests-api.js</code></p>

<h3 id="corshttpsgithubcomtroygoodenode-cors"><a href="https://github.com/troygoode/node-cors">CORS</a></h3>
<p>通过Access-Control-Allow-Origin请求头实现</p>

<p><code>npm install --save cors</code></p>

<p>暴露api，
<code>app.use('/api', require('cors')());</code></p>

<h3 id="restler">restler</h3>
<p>浏览器只知道如何处理get/post请求，在测试中使用，发出get/post请求
<code>npm install --save-dev restler</code></p>

<h3 id="expressapi">使用Express提供api</h3>
<p>我放在<code>/handlers/attraction</code>中</p>

<h3 id="restapi">使用REST插件提供api</h3>
<p><code>npm install --save connect-rest</code></p>

<p>api配置代码的位置要在rest.VERB之前，不然context不起作用
<code>javascript
var apiOptions = {
    context: '/api',
    domain: require('domain').create(),
};
</code></p>

<p>p177这里代码有点小错误
* findById回调函数中应为”a”而不是”attraction”
* 返回的对象中加入<code>id: a._id</code>，测试时要对比id</p>

<h3 id="section-22">使用子域名</h3>
<p>使用子域名api.example.com最大程度区别站点和api</p>

<p><code>npm install --save vhost</code></p>

<p>在/etc/hosts中增加
<code>127.0.1.2 api.xiaop</code></p>

<p>http://api.xiaop:3000/attraction/5405333a7e3566640f560f78</p>

<h2 id="ch16-">ch16 静态内容</h2>
<ul>
  <li>多媒体内容，包括图片，音频/视频文件</li>
  <li>css</li>
  <li>js</li>
  <li>二进制文件下载</li>
</ul>

<h3 id="section-23">性能考虑</h3>
<p>减少请求次数或者减少内容大小，前者更关键，包括组合资源和浏览器缓存。</p>

<p>组合资源：小的图片组合成单独的sprite，通过css设置展示的偏移。</p>

<p><a href="http://wearekiss.com/spritepad">创建sprite</a></p>

<h3 id="view-1">在view中使用静态资源</h3>

<p>在handlebars中添加helpers，view中使用``</p>

<p>将来这些静态资源可以移到CDN上，只要在static.js中配置baseUrl即可</p>

<h3 id="css">在css中使用静态资源</h3>
<p>css预处理器 less</p>

<p>使用grunt自动运行任务，将less编译成css，运行<code>grunt less</code>编译</p>

<p><code>npm install --save-dev grunt-contrib-less</code></p>

<p>在less中使用自定义函数static
<code>css
body {
    background-image: static("/img/background.png");
}
</code></p>

<p>需要在Gruntfile.js中配置less插件，增加自定义函数
<code>javascript
less: {
    development: {
        options: {
            customFunctions: {
                static: function(lessObject, name) {
                    return 'url("' +
                        require('./lib/static.js').map(name.value) +
                        '")';
                }
            }
        },
        files: {
            'public/css/main.css': 'less/main.less',
        }
    }
}
</code></p>

<h3 id="section-24">在服务端脚本使中用静态资源</h3>
<p><code>var static = require('./lib/static.js').map;</code></p>

<h3 id="section-25">在客户端脚本中使用静态资源</h3>
<p><code>javascript
var IMG_CART_EMPTY = '';
var IMG_CART_FULL = '';
</code></p>

<h3 id="section-26">浏览器缓存  请求头</h3>
<p>Expires/Cache-Control：缓存最大时间，前者更好。浏览器发现缓存中有并且还没过期的资源，是不会发送Get请求的。这大大提高了性能尤其在移动端。</p>

<p>Last-Modified/ETag：浏览器发送get请求，如果etag不变则不会下载资源。</p>

<h3 id="section-27">改变静态内容</h3>
<p>使用版本号表示变更，即使浏览器缓存，也会强制下载新资源。</p>

<h3 id="bundling-minification">bundling minification</h3>

<p>合并压缩js<code>npm install --save-dev grunt-contrib-uglify</code>，生成meadowlark.min.js</p>

<p>合并压缩css<code>npm install --save-dev grunt-contrib-cssmin</code>，生成meadowlark.min.css</p>

<p>用于生成fingerprint<code>npm install --save-dev grunt-hashres</code>，在meadowlark.min.js/css后增加一个版本号，并且会自动去main.handlebars中替换，这样浏览器就会强制下载新文件。</p>

<p>grunt中任务是有顺序的，定义一个新任务处理静态资源
<code>grunt.registerTask('static', ['less', 'cssmin', 'uglify', 'hashres']);</code></p>

<p>运行<code>grunt static</code>即可</p>

<h3 id="bundlingminification">在开发中跳过bundling和minification</h3>
<p>由于所有js和css文件都被压缩到了一个文件中，给debug带来不便。</p>

<p>使用<a href="https://github.com/Jammerwoch/connect-bundle">connect-bundle</a></p>

<p><code>npm install connect-bundle --save</code></p>

<p>在主文件中设置js/css打包，可以增加属性<code>contextProperty = 'myBundles'</code>，默认在view中通过_bundles访问
<code>javascript
var bundler = require('connect-bundle')(require('./config.js'));
app.use(bundler);
</code></p>

<p>css文件都放在<code>&lt;head&gt;</code>中，不用指定位置，js要，包括head，afterBodyOpen，afterBodyClose。</p>

<p>修改Gruntfile.js中hashres的目的地指向config.js，这样每次执行static任务，替换的是config.js中的文件名。</p>

<p>这样在开发模式下，view不会使用压缩的文件，只有在生产模式下会使用带版本号的js/css文件
<code>NODE_ENV=production node meadowlark.js</code></p>

<h3 id="qa-">QA 检查未映射的静态资源</h3>
<p>在Gruntfile.js中注册插件，定义规则
<code>npm install --save-dev grunt-lint-pattern</code></p>

<h2 id="ch17-express-mvc">ch17 Express MVC</h2>

<h3 id="view-model">view model</h3>
<p>使用underscore方便地从model转换到view model，删除不想暴露的属性(omit)，进行扩展(extend)</p>

<p><code>npm install --save underscore</code></p>

<p>array.map()映射</p>

<h3 id="controller">controller</h3>
<p>和router的区别就是controller会分类相似的功能，其实前面将功能放在handlers文件夹下，routers.js负责路由就是做这样一件事。</p>

<h2 id="ch18-">ch18 安全性</h2>

<h3 id="https">使用https保证通信安全</h3>
<p>通过openssl生成私钥(pem)和认证(会被发送到客户端用于建立安全连接)
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout meadowlark.pem -out meadowlark.crt</p>

<h3 id="express-2">在express中使用</h3>
<p><code>javascript
var https = require('https');
var options = {
    key: fs.readFileSync(__dirname + '/ssl/meadowlark.pem');
    cert: fs.readFileSync(__dirname + '/ssl/meadowlark.crt');
};
https.createServer(options, app).listen(app.get('port'), function(){
    console.log('Express started in ' + app.get('env') +
    ' mode on port ' + app.get('port') + '.');
});
</code></p>

<h3 id="csrf">CSRF跨站请求伪造</h3>
<p>确保请求来自自己的网站。通过向浏览器传递一个token，当提交表单时，服务端进行验证。</p>

<p>使用csurf<code>npm install --save csurf</code>，必须在cookie-parser和connect-session这两个中间件引入之后</p>

<p><code>javascript
app.use(require('csurf')());
app.use(function(req, res, next){
    res.locals._csrfToken = req.csrfToken();
    next();
});
</code></p>

<p>在表单或者ajax请求中，增加一个字段<code>_csrf</code>，中间件会验证，验证失败会抛出异常
<code>html
&lt;input type="hidden" name="_csrf" value=""&gt;
</code></p>

<p>如果有api，不希望被csrf中间件干扰，可以将api在csrf中间件之前引入。</p>

<h3 id="passport">Passport</h3>

<p><code>npm install --save passport passport-github</code></p>

<p>本地验证策略</p>

<p>定义好serializeUser和deserializeUser方法，
只要通过验证，在session中就能通过req.session.passport.user访问对应的User对象
<code>javascript
var User = require('../models/user.js'),
    passport = require('passport'),
    FacebookStrategy = require('passport-facebook').Strategy;
passport.serializeUser(function(user, done){
    done(null, user._id);//将mongodb分配的'_id'保存在session中
});
passport.deserializeUser(function(id, done){
    User.findById(id, function(err, user){
        if(err || !user) return done(err, null);
        done(null, user);
    });
});
</code></p>

<p>两个错误：
* p225解序列化的user通过req.user访问，原文中req.session.passport.user只能访问到之前序列化存储的id
* <code>callbackURL: '/auth/facebook/callback?redirect=' + encodeURIComponent(req.query.redirect)</code>此处有问题，当queryString中没有redirect时，encodeURIComponent会将undefined编码成“undefined”，这样验证通过重定向时会404。</p>

<h3 id="section-28">基于角色的认证</h3>

<p><code>next('route');</code>和<code>next()</code>的区别：
一个route可以包含多个中间件：middleware1通过调用<code>next()</code>将控制权交给middleware2，而<code>next('route')</code>寻找下一个route</p>

<p><code>javascript
app.get('',middleware1,middleware2,function(req,res,next){});
</code></p>

<h2 id="ch19-api">ch19 集成第三方api</h2>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">xiaOp写东西的地方</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>xiaOp写东西的地方</li>
          <li><a href="mailto:pyqiverson@gmail.com">pyqiverson@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/xiaoiver">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">xiaoiver</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/jekyllrb">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">jekyllrb</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">读书笔记，碰到的问题
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
