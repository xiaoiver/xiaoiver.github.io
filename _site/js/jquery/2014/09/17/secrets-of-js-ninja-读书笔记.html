<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>《Secrets of JS Ninja》读书笔记</title>
    <meta name="description" content="读书笔记，碰到的问题
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://yourdomain.com/js/jquery/2014/09/17/secrets-of-js-ninja-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">xiaOp写东西的地方</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">关于xiaOp</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">《Secrets of JS Ninja》读书笔记</h1>
    <p class="post-meta">Sep 17, 2014</p>
  </header>

  <article class="post-content">
    <h2 id="ch3">ch3</h2>

<h3 id="first-class">函数作为first-class对象</h3>

<p>对象有以下能力：
* 可以被分配给变量，数组的成员，其他对象的属性
* 当做参数传给函数
* 当做函数返回值
* 拥有可以被动态创建和分配的属性</p>

<p>function都有，所以first-class object</p>

<h3 id="section">浏览器事件循环</h3>

<p>程序中编写事件处理器，但是事件出现的时间和顺序都是不确定的，所以叫做“异步”调用处理器。</p>

<p>事件类型：</p>

<ul>
  <li>浏览器事件，例如页面加载完成</li>
  <li>网络事件，例如ajax请求的响应</li>
  <li>用户事件，鼠标点击，移动，按键</li>
  <li>定时器事件，定时到期，间隔时间触发</li>
</ul>

<p><code>window.onload = function() { /* do something wonderful */ };</code>
当然也可以使用<code>&lt;body&gt;</code>的onload属性，但是这样违背了非侵入式js的原则。</p>

<h3 id="section-1">作用域和函数</h3>

<p>function可以在声明前引用,变量不可以</p>

<p>scope是由function定义的，而不是诸如if block
<code>javascript
if (window) {
    var x = 213;
}
alert(x); //213
</code></p>

<p>调用function的四种方式：</p>

<ol>
  <li>直接调用function</li>
  <li>对象中的method</li>
  <li>作为对象的构造函数当对象被创建时调用</li>
  <li>apply,call</li>
</ol>

<p>向function传参数时，不足的参数赋值undefined，多余的不会报错，也不会赋值。</p>

<p>所有对function的调用都会传递两个隐式变量arguments 和 this</p>

<p>arguments变量有length属性，能通过下标取得某一个参数，但是它并不是一个array，不能通过array的方法使用它。</p>

<p>this是java中的概念，但是指向的对象根据调用function方法的不同</p>

<p>function的调用方法：</p>

<ol>
  <li>直接调用中function的上下文是全局上下文window对象</li>
  <li>通过对象method使用时，上下文是owner对象，通过this指向
<code>javascript
var o = {};
o.whatever = function(){};
o.whatever();
</code></li>
  <li>constructor:通过new调用构造函数。
<code>function creep(){ return this; }</code></li>
</ol>

<p><code>new creep();</code>虽然能用，但是这样不合适，因为有显式的返回值，我们想得到对象本身</p>

<p>当对象的构造函数被调用后，发生3件事：
1. 一个空的对象被创建了
2. 这个对象被传递给了构造函数，通过this指向，成为构造函数的上下文
3. 如果没有显式的返回值，这个对象将作为构造函数的返回值</p>

<p>直接通过function调用一个对象的构造函数是不好的，虽然合法
<code>var whatever = Ninja();</code> this指向的是window对象而非创建的对象
<code>javascript
function Ninja() {
    this.skulk = function() { return this; };
}
var ninja1 = new Ninja();
var ninja2 = new Ninja();
assert(ninja1.skulk() === ninja1,
    "The 1st ninja is skulking");
assert(ninja2.skulk() === ninja2,
    "The 2nd ninja is skulking");
</code>
为了区分，一般构造方法首字母大写</p>

<ol>
  <li>apply和call
目的：向方法传递任意上下文。
apply两个参数，上下文对象和array参数列表，call直接传递参数，没有列表。
常用在callback函数中。</li>
</ol>

<h2 id="ch4-function">ch4 function</h2>
<p>### 匿名函数
#### 使用场景</p>

<ol>
  <li>用作event handler：不需要再次引用<code>window.onload = function(){ assert(true, 'power!'); };</code></li>
  <li>对象的属性方法，这里的shout并不是函数的名字，只是对匿名函数的引用
<code>javascript
var ninja = {
 shout: function(){
     assert(true,"Ninja");
 }
};
</code></li>
  <li>回调函数
<code>javascript
setTimeout(
 function(){ assert(true,'Forever!'); },
500);
</code></li>
</ol>

<h4 id="section-2">解决问题</h4>
<p>1.递归</p>

<p>通过命名函数实现：
a) 判断一个string是否是回文的
<code>javascript
function isPalindrome(text) {
    if (text.length &lt;= 1) return true;
    if (text.charAt(0) != text.charAt(text.length - 1)) return false;
    return isPalindrome(text.substr(1,text.length - 2));
}
</code></p>

<p>b) 重复一定次数
<code>javascript
function chirp(n) {
    return n &gt; 1 ? chirp(n - 1) + "-chirp" : "chirp";
}
</code></p>

<p>通过匿名函数实现：
<code>javascript
var ninja = {
    chirp: function(n) {
        return n &gt; 1 ? ninja.chirp(n - 1) + "-chirp" : "chirp";
    }
};
</code></p>

<p>存在问题，ninja.chirp写成this更好，防止ninja对象清空后，匿名函数无法执行</p>

<p>匿名函数也可以有name，inline function
<code>javascript
var ninja = {
    chirp: function signal(n) {
    return n &gt; 1 ? signal(n - 1) + "-chirp" : "chirp";
    }
};
</code></p>

<p>但是inline function的name只在function内部可见，
和function内部声明变量的scope一样</p>

<p>这也是顶级function为什么被创建为window对象的方法，不然我们无法引用</p>

<ol>
  <li>arguments.callee
可以得到函数本身</li>
</ol>

<h3 id="function">function本身也是对象</h3>
<p><code>javascript
var store = {
    nextId: 1,
    cache: {},
    add: function(fn) {
        if (!fn.id) {
            fn.id = store.nextId++;
            return !!(store.cache[fn.id] = fn);// !!将js表达式转换成等价的布尔值
        }
    }
};
function ninja(){}
assert(store.add(ninja),
    "Function was safely added.");
assert(!store.add(ninja),
    "But it was only added once.");
</code></p>

<h3 id="memoizing-function">memoizing function</h3>
<p>判断质数，将过往记录保存在answer中
<code>javascript
function isPrime(value) {
    if (!isPrime.answers) isPrime.answers = {};
    if (isPrime.answers[value] != null) {
        return isPrime.answers[value];
    }
    var prime = value != 1; // 1 can never be prime
    for (var i = 2; i &lt; value; i++) {
        if (value % i == 0) {
            prime = false;
            break;
        }
    }
    return isPrime.answers[value] = prime;
}
assert(isPrime(5), "5 is prime!" );
assert(isPrime.answers[5], "The answer was cached!" );
</code></p>

<h3 id="dom-elements">保存查询的DOM elements</h3>
<p><code>javascript
function getElements(name) {
    if (!getElements.cache) getElements.cache = {};
    return getElements.cache[name] =
        getElements.cache[name] ||
        document.getElementsByTagName(name);
}
</code></p>

<h3 id="faking-array-method">faking array method</h3>
<p>利用call将elems作为上下文传递给Array的push方法，增长length属性
<code>javascript
var elems = {
    length: 0,
    add: function(elem){
        Array.prototype.push.call(this, elem);
    },
    gather: function(id){
        this.add(document.getElementById(id));
    }
};
elems.gather("first");
assert(elems.length == 1 &amp;&amp; elems[0].nodeType,
    "Verify that we have an element in our stash");
elems.gather("second");
assert(elems.length == 2 &amp;&amp; elems[1].nodeType,
    "Verify the other insertion");
</code></p>

<h3 id="section-3">变长参数列表</h3>
<p>js中没有面向对象语言中的重载特性，参数列表可以做到</p>

<p><code>Math.max/min</code>不接受array参数，所以需要知道array长度，但这样也不够优雅：
<code>var biggest = Math.max(list[0],list[1],list[2]);</code></p>

<p>使用apply()：传递参数列表，无须显式传递
<code>javascript
function smallest(array){
    return Math.min.apply(Math, array);
}
</code></p>

<p>将第一个参数之后的对象合并进第一个对象中
<code>javascript
function merge(root){
    for (var i = 1; i &lt; arguments.length; i++) {
        for (var key in arguments[i]) {
            root[key] = arguments[i][key];
        }
    }
    return root;
}
var merged = merge(
    {name: "Batou"},
    {city: "Niihama"});
</code></p>

<p>一个jquery-ui中的例子：
<code>$("#myDialog").dialog({ caption: "This is a dialog" });$("#myDialog").dialog("open");</code>
通过判断传入的参数类型，属性赋值和具体操作。</p>

<p>由于arguments并不是一个array对象，诸如slice之类的方法没有，可以通过call
欺骗slice方法，传入一个非array对象的上下文。
<code>javascript
function multiMax(multi){
    return multi * Math.max.apply(Math,
        Array.prototype.slice.call(arguments, 1));
}
assert(multiMax(3, 1, 2, 3) == 9,
    "3*3=9 (First arg, by largest.)");
</code></p>

<p>function的length属性值是声明的参数个数，
arguments.length不一样，是调用函数时传入参数的个数。</p>

<h3 id="section-4">函数重载</h3>
<p>像洋葱，每一层的方法检查传入的参数个数和自己定义的是否一致，
一致就执行，不一致传给下一层。内部的匿名函数对old和fn的引用通过closure
<code>javascript
function addMethod(object, name, fn) {
    var old = object[name];
    object[name] = function(){
        if (fn.length == arguments.length)
            return fn.apply(this, arguments)
        else if (typeof old == 'function')
            return old.apply(this, arguments);
    };
}
var ninja = {};
addMethod(ninja,'whatever',function(){ /* do something */ });
addMethod(ninja,'whatever',function(a){ /* do something else */ });
addMethod(ninja,'whatever',function(a,b){ /* yet something else */ });
</code></p>

<h3 id="function-1">判断一个对象是不是function</h3>
<p><code>javascript
function ninja(){}
assert(typeof ninja == "function",
    "Functions have a type of function");
</code>
一些特例p87，不同浏览器</p>

<p>较好的实现
<code>javascript
function isFunction(fn) {
    return Object.prototype.toString.call(fn) === "[object Function]";
}
</code>
为何不直接调用fn.toString:</p>

<ol>
  <li>对象可能有自己的toString实现</li>
  <li>js中大多数类型覆盖了Object.prototype提供的toString方法</li>
</ol>

<h2 id="ch5-closure">ch5 closure</h2>
<p>当innerFunction在outerFunction内部声明时，一个闭包就被创建了。
```javascript
var outerValue = ‘ninja’;
var later;
function outerFunction() {
    var innerValue = ‘samurai’;</p>

<pre><code>function innerFunction() {
    assert(outerValue,"I can see the ninja.");
    assert(innerValue,"I can see the samurai.");
}
later = innerFunction; } outerFunction(); later(); ```
</code></pre>

<p>closure还包含了传入的参数，甚至是在function定义后声明的变量，
而在同一个scope中，是不能提前引用还未定义的变量的，undefined。</p>

<h3 id="closure">closure的应用</h3>
<p>#### private 变量</p>

<p>feint方法能访问feints变量是因为feints处在其closure中。而closure阻止了外面对feints的直接访问。外面要想访问，要通过ninja引用。
<code>javascript
function Ninja() {
    var feints = 0;
    this.getFeints = function(){
        return feints;
    };
    this.feint = function(){
        feints++;
    };
}
var ninja = new Ninja();
ninja.feint();
assert(ninja.getFeints() == 1,
    "We're able to access the internal feint count.");
assert(ninja.feints === undefined,
    "And the private data is inaccessible to us.");
</code></p>

<h4 id="callback--timer">callback &amp; timer</h4>

<p>将$作为变量的前缀/后缀可以表示这是一个jquery对象的引用。
success回调函数通过closure引用elem$变量。
<code>javascript
jQuery('#testButton').click(function(){
    var elem$ = jQuery("#testSubject");
    elem$.html("Loading...");
    jQuery.ajax({
        url: "test.html",
        success: function(html){
            assert(elem$,
                "We can see elem$, via the closure for this callback.");
            elem$.html(html);
        }
    });
});
</code></p>

<p>如果将变量elem,tick放在全局scope中，多个实例会发生干扰。每个handler的closure保证了其中的变量不会被其他实例访问到。而且closure不只是变量当前状态的快照，是一个动态的封装，只要closure存在就能修改变量。
<code>javascript
function animateIt(elementId) {
    var elem = document.getElementById(elementId);
    var tick = 0;
    var timer = setInterval(function(){
        if (tick &lt; 100) {
            elem.style.left = elem.style.top = tick + "px";
            tick++;
        }
        else {
            clearInterval(timer);
            assert(tick == 100,
                "Tick accessed via a closure.");
            assert(elem,
                "Element also accessed via a closure.");
            assert(timer,
                "Timer reference also obtained via a closure." );
        }
    }, 10);
}
animateIt('box');
</code></p>

<h4 id="section-5">绑定函数上下文</h4>

<p>测试未通过的原因是addEventListener会将click处理函数的上下文设置成elem而不是我们
期待的button对象
<code>javascript
var button = {
    clicked: false,
    click: function(){
        this.clicked = true;
        assert(button.clicked,"The button has been clicked");
    }
};
var elem = document.getElementById("test");
elem.addEventListener("click",button.click,false);
</code></p>

<p>解决办法：通过apply指定上下文
<code>javascript
function bind(context,name){
    return function(){
        return context[name].apply(context,arguments);
    };
}
var button = {
    clicked: false,
    click: function(){
        this.clicked = true;
        assert(button.clicked,"The button has been clicked");
        console.log(this);
    }
};
var elem = document.getElementById("test");
elem.addEventListener("click",bind(button,"click"),false);
</code>
bind方法返回的匿名函数的closure包含了context，name。</p>

<p>Prototype类库中的bind实现：
<code>javascript
Function.prototype.bind = function(){
    var fn = this, args = Array.prototype.slice.call(arguments),
    object = args.shift();
    return function(){
        return fn.apply(object,
            args.concat(Array.prototype.slice.call(arguments)));
    };
};
var myObject = {};
function myFunction(){
    return this == myObject;
}
assert( !myFunction(), "Context is not set yet" );
var aFunction = myFunction.bind(myObject)
assert( aFunction(), "Context is set properly" );
</code></p>

<h4 id="partialcurry-function">partial/curry function</h4>
<p>在调用函数之前传递特定参数，proxy
Prototype中的curry实现：注意两个arguments是不同的
<code>javascript
Function.prototype.curry = function() {
    var fn = this,
        args = Array.prototype.slice.call(arguments);
    return function() {
        return fn.apply(this, args.concat(
            Array.prototype.slice.call(arguments)));
    };
};
</code></p>

<p>使用undefined占位
<code>javascript
Function.prototype.partial = function() {
    var fn = this, args = Array.prototype.slice.call(arguments);
    return function() {
        var arg = 0;
        for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++) {
            if (args[i] === undefined) {
                args[i] = arguments[arg++];
            }
        }
        return fn.apply(this, args);
    };
};
</code></p>

<p>使用：
<code>javascript
var bindClick = document.body.addEventListener
    .partial("click", undefined, false);
bindClick(function(){
    assert(true, "Click event bound via curried function.");
});
</code></p>

<h4 id="memoization-method">memoization method</h4>
<p>这种方法的坏处是isPrime方法必须显式调用memoized方法才能存储之前的结果。
<code>javascript
Function.prototype.memoized = function(key){
    this._values = this._values || {};
    return this._values[key] !== undefined ?
        this._values[key] :
        this._values[key] = this.apply(this, arguments);
};
function isPrime(num) {
    var prime = num != 1;
    for (var i = 2; i &lt; num; i++) {
        if (num % i == 0) {
            prime = false;
            break;
        }
    }
    return prime;
}
assert(isPrime.memoized(5),
    "The function works; 5 is prime.");
assert(isPrime._values[5],
    "The answer has been cached.");
</code></p>

<p>改进：
<code>javascript
Function.prototype.memoize = function(){
    var fn = this;
    return function(){
        return fn.memoized.apply( fn, arguments );
    };
};
var isPrime = (function(num) {
    var prime = num != 1;
    for (var i = 2; i &lt; num; i++) {
        if (num % i == 0) {
            prime = false;
            break;
        }
    }
    return prime;
}).memoize();
assert(isPrime(17),"17 is prime");
</code>
在memoize中创建了一个closure，由于每个函数都有上下文，所以上下文不能是closure的一部分。
但是context的值可以通过一个变量引用它包含在closure中，如fn。</p>

<h4 id="wrapper-function">wrapper function</h4>
<p>重载函数但保持对原函数的引用
<code>javascript
function wrap(object, method, wrapper) {
    var fn = object[method];
    return object[method] = function() {//匿名函数可以通过closure访问fn和wrapper变量
        return wrapper.apply(this, [fn.bind(this)].concat(//fn 作为参数列表的第一个
            Array.prototype.slice.call(arguments)));
    };
}
if (Prototype.Browser.Opera) {
    wrap(Element.Methods, "readAttribute",
    function(original, elem, attr) {
        return attr == "title" ?
            elem.title :
            original(elem, attr);
    });
}
</code></p>

<h4 id="immediate-function">immediate function</h4>
<p><code>(function(){})()</code>第一组()只是表达式，第二组()才是函数调用符</p>

<p>这样做了3件事：</p>

<ol>
  <li>创建了一个function实例</li>
  <li>执行了function</li>
  <li>废弃了function因为没有引用</li>
</ol>

<p>closure起类似命名空间的作用，$被包含在任何创建在function内部的function的closure中，如handler。</p>

<p>传入jQuery变量。这种用法在plugin中十分常见，能避免变量的命名冲突。
<code>javascript
$ = function(){ alert('not jQuery!'); };
(function($){
    $('img').on('click',function(event){
        $(event.target).addClass('clickedOn');
    })
})(jQuery);
</code></p>

<p>以下是Prototype中的例子。通过简短的变量名代替长的。
<code>javascript
(function(v) {
    Object.extend(v, {
        href: v._getAttr,
        src: v._getAttr,
        type: v._getAttr,
        action: v._getAttrNode,
        disabled: v._flag,
        checked: v._flag,
        readonly: v._flag,
        multiple: v._flag,
        onload: v._getEv,
        onunload: v._getEv,
        onclick: v._getEv,
        ...
    });
})(Element.attributeTranslations.read.values);
</code></p>

<p>循环中的问题：
```javascript</p>
<body>
<div>DIV 0</div>
<div>DIV 1</div>
<script type="text/javascript">
    var divs = document.getElementsByTagName("div");
    for (var i = 0; i < divs.length; i++) {
        divs[i].addEventListener("click", function() {
            alert("divs #" + i + " was clicked.");
        }, false);
    }
</script>
</body>
<p>```
这里的i会等于最终的值就是2。因为closure并不是只记录变量的当前值，会保持对它的引用。</p>

<p>解决办法：使用immediate function，在for循环的每次循环中，i都被重新定义为n，closure中n的值是正确的。
<code>javascript
for (var i = 0; i &lt; div.length; i++) (function(n){
    div[n].addEventListener("click", function(){
        alert("div #" + n + " was clicked.");
    }, false);
})(i);
</code></p>

<p>window.jQuery作为全局变量。但是有可能被修改，所以在immediate function
的scope中声明了一个局部变量jQuery。
<code>javascript
(function(){
    var jQuery = window.jQuery = function(){
        // Initialize
    };
    // ...
})();
</code></p>

<p>另一种方法：
<code>javascript
var jQuery = (function(){
    function jQuery(){
        // Initialize
    }
    // ...
    return jQuery;
})();
</code></p>

<h2 id="ch6-oo-prototype">ch6 OO prototype</h2>
<p>p122
初始化步骤首先从prototype中绑定属性，再从构造函数中添加。
并不是简单的拷贝prototype，是attach。
<code>javascript
function Ninja(){
    this.swung = true;
}
var ninja = new Ninja();
Ninja.prototype.swingSword = function(){
    return this.swung;
};
assert(ninja.swingSword(),
    "Method exists, even out of order.");
</code>
这里在对象创建之后加入prototype依然能引用到。</p>

<p>每个对象有一个隐式的属性constructor引用对象的构造方法，而prototype是构造方法的一个属性，所以每个对象的实例都能找到自己的prototype。</p>

<p>所以访问一个对象的属性时，优先级是首先检查property，如果没有定义过，继续查找prototype，还是没有则返回undefined。</p>

<h3 id="section-6">类型检测</h3>
<p><code>javascript
function Ninja(){}
var ninja = new Ninja();
assert(typeof ninja == "object",
    "The type of the instance is object.");
assert(ninja instanceof Ninja,
    "instanceof identifies the constructor." );
assert(ninja.constructor == Ninja,
    "The ninja object was created by the Ninja function.");
</code></p>

<p>使用对象constructor属性引用的构造器创建对象：
<code>javascript
function Ninja(){}
var ninja = new Ninja();
var ninja2 = new ninja.constructor();
assert(ninja2 instanceof Ninja, "It's a Ninja!");
assert(ninja !== ninja2, "But not the same Ninja!");
</code></p>

<h3 id="prototype-chain">通过prototype chain实现继承</h3>
<p><code>SubClass.prototype = new SuperClass();</code></p>

<p>这样子类就有了父类的全部属性。
<code>javascript
function Person(){}
Person.prototype.dance = function(){};
function Ninja(){}
Ninja.prototype = new Person();
var ninja = new Ninja();
assert(ninja instanceof Ninja,
    "ninja receives functionality from the Ninja prototype");
assert(ninja instanceof Person, "... and the Person prototype");
assert(ninja instanceof Object, "... and the Object prototype");
assert(typeof ninja.dance == "function", "... and can dance!")
</code></p>

<p><code>Ninja.prototype = Person.prototype;</code>不能这样，Ninja的prototype发生改变也会影响Person</p>

<h3 id="js">扩展js中的对象</h3>
<p><code>javascript
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(callback, context) {
        for (var i = 0; i &lt; this.length; i++) {
            callback.call(context || null, this[i], i, this);//防止传入undefined
        }
    };
}
["a", "b", "c"].forEach(function(value, index, array) {
    assert(value,
        "Is in position " + index + " out of " +
        (array.length - 1));
});
</code></p>

<h3 id="html-dom">扩展html dom对象</h3>
<p>现代浏览器中的dom对象继承自HTMLElement
<code>javascript
HTMLElement.prototype.remove = function() {
    if (this.parentNode)
    this.parentNode.removeChild(this);
};
</code></p>

<p>但是这种用法是错误的：浏览器禁止直接调用构造函数
<code>var elem = new HTMLElement();</code></p>

<h3 id="object">扩展Object</h3>
<p>这样无法得到正确的结果，原因是引入了keys这个新属性。
<code>javascript
Object.prototype.keys = function() {
    var keys = [];
    for (var p in this) keys.push(p);
    return keys;
};
var obj = { a: 1, b: 2, c: 3 };
assert(obj.keys().length == 3,
    "There are three properties in this object.");
</code></p>

<p>使用hasOwnProperty判断属性是通过实例定义的还是prototype引入的。
<code>javascript
Object.prototype.keys = function() {
    var keys = [];
    for (var i in this)
        if (this.hasOwnProperty(i)) keys.push(i);
    return keys;
};
</code></p>

<h3 id="number">扩展Number：</h3>
<p>p138 最好不要,语法上不支持</p>

<p><a href="http://perfectionkills.com/">一个很好的blog</a></p>

<h3 id="section-7">继承原生对象</h3>
<p><code>javascript
function MyArray() {}
MyArray.prototype = new Array();
var mine = new MyArray();
mine.push(1, 2, 3);
assert(mine.length == 3,
    "All the items are in our sub-classed array.");
assert(mine instanceof Array,
    "Verify that we implement Array functionality.");
</code>
在IE上length和Array的关系及其紧密</p>

<p>解决办法：定义新的Length属性并copy其他Array方法，使用immediate function：
<code>javascript
function MyArray() {}
MyArray.prototype.length = 0;
(function() {
    var methods = ['push', 'pop', 'shift', 'unshift',
        'slice', 'splice', 'join'];
    for (var i = 0; i &lt; methods.length; i++) (function(name) {
        MyArray.prototype[ name ] = function() {
            return Array.prototype[ name ].apply(this, arguments);
        };
    })(methods[i]);
})();
var mine = new MyArray();
mine.push(1, 2, 3);
assert(mine.length == 3,
    "All the items are on our sub-classed array.");
assert(!(mine instanceof Array),
    "We aren't subclassing Array, though.");
</code></p>

<h3 id="section-8">实例化注意事项</h3>
<p>new操作符在创建对象时必不可少，缺少有可能污染全局scope，恰巧变量与属性同名。
<code>javascript
function User(first, last){
    this.name = first + " " + last;
}
var name = "Rukia";
var user = User("Ichigo", "Kurosaki");
</code></p>

<h3 id="function-2">function序列化</h3>
<p><code>/xyz/.test(function() { xyz; }</code>调用function的toString方法</p>

<h3 id="function-3">检验function是通过构造函数调用还是普通调用</h3>
<p><code>javascript
function Test() {
    return this instanceof arguments.callee;
}
assert(!Test(), "We didn't instantiate, so it returns false.");
assert(new Test(), "We did instantiate, returning true.");
</code></p>

<h3 id="section-9">防御式编程</h3>
<p>如果不是通过new实例化
<code>javascript
function User(first, last) {
    if (!(this instanceof arguments.callee)) {
        return new User(first,last);
    }
    this.name = first + " " + last;
}
assert(name == "Rukia",
    "Name was set to Rukia.");
</code>
仍存在3个问题：</p>

<ol>
  <li>callee在未来版本js中废弃，strict模式下禁用。</li>
  <li>好的编程实践？</li>
  <li>自以为了解用户</li>
</ol>

<h3 id="p146">P146实现类的继承</h3>
<p>```javascript
var Person = Object.subClass({
    init: function(isDancing){
        this.dancing = isDancing;
    }
});
var Ninja = Person.subclass({
    init: function(){
        this._super(false);
    }
});</p>

<p>(function() {
var initializing = false,
    superPattern =
        /xyz/.test(function() { xyz; }) ? /\b_super\b/ : /.*/;
Object.subClass = function(properties) {
    var _super = this.prototype;
    initializing = true;
    var proto = new this();
    initializing = false;
    for (var name in properties) {
        proto[name] = typeof properties[name] == “function” &amp;&amp; //判断三件事：子类是方法，父类是方法，子类方法包含对_super()的引用
        typeof _super[name] == “function” &amp;&amp;
            superPattern.test(properties[name]) ?
            (function(name, fn) {
                return function() {
                    var tmp = this._super;
                    this._super = _super[name];
                    var ret = fn.apply(this, arguments);
                    this._super = tmp;
                    return ret;
                };
            })(name, properties[name]) :
            properties[name];
    }
    function Class() {
        // All construction is actually done in the init method
        if (!initializing &amp;&amp; this.init)
            this.init.apply(this, arguments);
    } <br />
    Class.prototype = proto;
    Class.constructor = Class;
    Class.subClass = arguments.callee;
    return Class;
};
})();
```</p>

<h2 id="ch7">ch7正则表达式</h2>

<ul>
  <li>? 0/1</li>
  <li>
    <ul>
      <li>
        <blockquote>
          <p>=1</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <ul>
      <li>
        <blockquote>
          <p>=0</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<p><a href="jsbin.com">jsbin</a></p>

<p><a href="www.regexplanet.com/advanced/javascript/index.html">regexplanet</a></p>

<p>三种flag: </p>

<ul>
  <li>i-忽略大小写</li>
  <li>g-默认local匹配第一次</li>
  <li>m-多行</li>
</ul>

<p>创建方式：<code>/test/ig</code>或者 <code>new RegExp("test","ig")</code>
第二种的 好处是字符串可以运行时动态拼接</p>

<p>greedy <code>/a+/ aaa</code>匹配一次，全部
nongreedy <code>/a+?/ aaa</code>匹配第一个a</p>

<p>backreference: <code>/&lt;(\w+)&gt;(.+)&lt;\/\1&gt;/</code> 匹配xml格式</p>

<p><code>var regex = new RegExp("(^|\\s)" + className + "(\\s|$)");</code>这里需要额外的\，因为在字符串中，需要转义</p>

<h3 id="section-10">得到透明度</h3>
<p>```javascript
&lt;div id="opacity"
    style="opacity:0.5;filter:alpha(opacity=50);"&gt;
&lt;/div&gt;</p>

<p>function getOpacity(elem) {
    var filter = elem.style.filter;
    return filter ?
        filter.indexOf(“opacity=”) &gt;= 0 ?
            (parseFloat(filter.match(/opacity=([^)]+/)[1]) / 100) + “” :
                “” :
                elem.style.opacity;
}
```
由于match会返回匹配数组，而0下标中是整个匹配字符串</p>

<p><code>exec()</code>每次执行返回全局搜索的一个match
<code>javascript
var html = "&lt;div class='test'&gt;&lt;b&gt;Hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;";
var tag = /&lt;(\/?)(\w+)([^&gt;]*?)&gt;/g, match;
var num = 0;
while ((match = tag.exec(html)) !== null) {
    assert(match.length == 4,
        "Every match finds each tag and 3 captures.");
    num++;
}
assert(num == 6, "3 opening and 3 closing tags found.");
</code></p>

<p>backreference和exec结合使用
```javascript
var html = “<b class="hello">Hello</b> <i>world!</i>”;
var pattern = /&lt;(\w+)([^&gt;]<em>)&gt;(.</em>?)&lt;\/\1&gt;/g;   //非贪婪模式</p>

<p>var match = pattern.exec(html);
assert(match[0] == “<b class="hello">Hello</b>”,
    “The entire tag, start to finish.”);
assert(match[1] == “b”, “The tag name.”);
assert(match[2] == “ class=’hello’”, “The tag attributes.”);
assert(match[3] == “Hello”, “The contents of the tag.”);</p>

<p>match = pattern.exec(html);
assert(match[0] == “<i>world!</i>”,
    “The entire tag, start to finish.”);
assert(match[1] == “i”, “The tag name.”);
assert(match[2] == “”, “The tag attributes.”);
assert(match[3] == “world!”, “The contents of the tag.”);
```</p>

<p>replace方法中使用$1表示匹配
<code>javascript
assert("fontFamily".replace(/([A-Z])/g, "-$1").toLowerCase() ==
    "font-family", "Convert the camelCase into dashed notation.");
</code></p>

<h3 id="non-capturing-group">non-capturing group</h3>
<p><code>var pattern = /((ninja-)+)sword/;</code></p>

<p>第一个括号表示sword前的全部字符串，第二个括号表示+之前的ninja-
第二个括号不加入group中：
<code>javascript
var pattern = /((?:ninja-)+)sword/;
var ninjas = "ninja-ninja-sword".match(pattern);
assert(ninjas.length == 2,"Only one capture was returned.");
assert(ninjas[1] == "ninja-ninja-",
    "Matched both words, without any extra capture.");
</code></p>

<h3 id="replace">replace()</h3>
<p>replace函数的第二个参数可以是function，传入4类参数：</p>

<ul>
  <li>The full text of the match</li>
  <li>The captures of the match, one parameter for each（多个）</li>
  <li>The index of the match within the original string</li>
  <li>The source string</li>
</ul>

<p><code>javascript
function upper(all,letter) { return letter.toUpperCase(); }
assert("border-bottom-width".replace(/-(\w)/g,upper)
    == "borderBottomWidth",
    "Camel cased a hyphenated string.");
</code>
无需使用while循环调用exec</p>

<h3 id="query">压缩query字符串</h3>
<p><code>javascript
function compress(source) {
    var keys = {};
    source.replace(
        /([^=&amp;]+)=([^&amp;]*)/g,
        function(full, key, value) {
            keys[key] =
            (keys[key] ? keys[key] + "," : "") + value;
            return "";
        }
    );
    var result = [];
    for (var key in keys) {
        result.push(key + "=" + keys[key]);
    }
    return result.join("&amp;");
}
assert(compress("foo=1&amp;foo=2&amp;blah=a&amp;blah=b&amp;foo=3") ==
    "foo=1,2,3&amp;blah=a,b",
    "Compression is OK!");
</code></p>

<h3 id="section-11">使用正则表达式解决常见问题</h3>
<p>#### trim string
<code>javascript
function trim(str) {
    return (str || "").replace(/^\s+|\s+$/g, "");
}
</code>
p170提供手动解决尾部空格，针对大文档提高效率</p>

<h4 id="section-12">匹配换行符</h4>
<p>```javascript
var html = “<b>Hello</b>\n<i>world!</i>”;</p>

<p>assert(/.*/.exec(html)[0] === “<b>Hello</b>”,
    “A normal capture doesn’t handle endlines.”);无法匹配换行符</p>

<p>assert(/[\S\s]*/.exec(html)[0] ===
“<b>Hello</b>\n<i>world!</i>”,
“Matching everything with a character set.”);使用空格字符检测所有</p>

<p>assert(/(?:.|\s)*/.exec(html)[0] ===
“<b>Hello</b>\n<i>world!</i>”,
“Using a non-capturing group to match everything.”);\s包括换行符
```</p>

<h3 id="unicode">unicode</h3>
<p><code>var matchAll = /[\w\u0080-\uFFFF_-]+/;</code></p>

<h2 id="ch8--">ch8线程 和 定时器</h2>
<p>timer不是js而是浏览器提供的特性。</p>

<h3 id="section-13">处理计算成本高的任务</h3>
<p>下面的任务耗时巨大，浏览器处理时，用户无法交互：
<code>javascript
var tbody = document.getElementsByTagName("tbody")[0];
for (var i = 0; i &lt; 20000; i++) {
    var tr = document.createElement("tr");
    for (var t = 0; t &lt; 6; t++) {
        var td = document.createElement("td");
        td.appendChild(document.createTextNode(i + "," + t));
        tr.appendChild(td);
    }
    tbody.appendChild(tr);
}
</code></p>

<p>使用定时器分割任务：
<code>javascript
var rowCount = 20000;
var divideInto = 4;
var chunkSize = rowCount/divideInto;
var iteration = 0;
var table = document.getElementsByTagName("tbody")[0];
setTimeout(function generateRows(){
    var base = (chunkSize) * iteration;
    for (var i = 0; i &lt; chunkSize; i++) {
        var tr = document.createElement("tr");
        for (var t = 0; t &lt; 6; t++) {
            var td = document.createElement("td");
            td.appendChild(
                document.createTextNode((i + base) + "," + t +
                "," + iteration));
            tr.appendChild(td);
        }
        table.appendChild(tr);
    }
    iteration++;
    if (iteration &lt; divideInto)
        setTimeout(generateRows,0);
},0);
</code></p>

<h3 id="central-timer-control">central timer control</h3>
<p>问题：动画，多个定时器改变不同的属性
特点：</p>

<ul>
  <li>页面中同时只有一个运行的定时器</li>
  <li>可以随时暂停和继续定时器</li>
  <li>移除回调函数的过程</li>
</ul>

<p>```javascript
var timers = {
    timerID: 0,
    timers: [],</p>

<pre><code>add: function(fn) {
    this.timers.push(fn);
},

start: function() {
    if (this.timerID) return;
    (function runNext() {
        if (timers.timers.length &gt; 0) {
            for (var i = 0; i &lt; timers.timers.length; i++) {
                if (timers.timers[i]() === false) {
                    timers.timers.splice(i,1);
                    i--;
                }
            }
            timers.timerID = setTimeout(runNext, 0);
        }
    })();
},

stop: function() {
    clearTimeout(this.timerID);
    this.timerID = 0;
} };
</code></pre>

<p>var box = document.getElementById(“box”), x = 0, y = 20;
timers.add(function() {
    box.style.left = x + “px”;
    if (++x &gt; 50) return false;
});
timers.add(function() {
    box.style.top = y + “px”;
    y += 2;
    if (y &gt; 120) return false;
});
timers.start();
```
除了动画，中心定时器控制还能用于测试前端</p>

<h3 id="section-14">异步测试</h3>

<p><code>javascript
(function() {
    var queue = [], paused = false;
    this.test = function(fn) {
        queue.push(fn);
        runTest();
    };
    this.pause = function() {
        paused = true;
    };
    this.resume = function() {
        paused = false;
        setTimeout(runTest, 1);
    };
    function runTest() {
        if (!paused &amp;&amp; queue.length) {
            queue.shift()();
            if (!paused) resume();
        }
    }
})();
</code></p>

<h2 id="ch9-">ch9 运行时代码解析</h2>
<p>运行时动态解释执行代码。</p>

<h3 id="eval">eval()</h3>
<p>参数是string，在被调用的scope中执行</p>

<p>返回最后一个表达式的结果<code>eval('3+4;5+6')</code>，结果是11</p>

<p>如果希望返回的不是原始类型，简单变量或者赋值，需要用大括号包裹。
<code>var o = eval('({ninja: 1})');</code>，如果没有，虽然还是创建了o，但是值是1。</p>

<h3 id="function-4">通过Function的构造函数</h3>
<p>不会创建闭包
<code>javascript
var add = new Function("a", "b", "return a + b;");
assert(add(3,4) === 7, "Function created and working!");
</code></p>

<h3 id="section-15">定时器</h3>
<p>其实和new Function()差不多
<code>var tick = window.setTimeout('alert("Hi!")',100);</code></p>

<h3 id="string">想在全局作用域中动态解释string</h3>
<p>赋值给<code>window.propName</code></p>

<p><a href="http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html">Web Reflection</a>提供的另外一种办法，在head后添加script代码段，在全局作用域执行。
<code>javascript
function globalEval(data) {
    data = data.replace(/^\s*|\s*$/g, "");//去除首尾空白字符
    if (data) {
        var head = document.getElementsByTagName("head")[0] ||
                    document.documentElement,
            script = document.createElement("script");
        script.type = "text/javascript";
        script.text = data;
        head.appendChild(script);
        head.removeChild(script);
    }
}
window.onload = function() {
    (function() {
        globalEval("var test = 5;");
    })();
    assert(test === 5, "The code was evaluated globally.");
};
</code></p>

<p>应用场景是动态执行从服务端返回的代码，但问题是安全性。</p>

<h3 id="section-16">安全地解析代码</h3>
<p>google项目<a href="http://code.google.com/p/google-caja/">Caja</a>，将js代码转换成更安全的形式
```javascript
var test = true;
(function(){ var foo = 5; })();
Function.prototype.toString = function(){};</p>

<p><strong><em>.loadModule(function (</em></strong>, IMPORTS<strong><em>) {
{
    var Function = __</em>.readImport(IMPORTS</strong><em>, ‘Function’);
    var x0</em><strong>;
    var x1</strong><em>;
    var x2</em><strong>;
    var test = true;
    __<em>.asSimpleFunc(</em></strong>.primFreeze(<strong><em>.simpleFunc(function () {
        var foo = 5;
    })))();
    IMPORTS</em></strong>[ ‘yield’ ] ((x0<strong>_ = (x2</strong>_ = Function,
        x2<strong><em>.prototype_canRead</em></strong>?
    x2<strong><em>.prototype: __</em>.readPub(x2</strong><em>, ‘prototype’)),
    x1</em>__ = <strong><em>.primFreeze(</em></strong>.simpleFunc(function () {})),
    x0<strong><em>.toString_canSet</em></strong>? (x0<strong><em>.toString = x1</em></strong>):
    <strong><em>.setPub(x0</em></strong>, ‘toString’, x1___)));
}
});
}
```</p>

<h3 id="function-5">function的反编译</h3>
<p>将function反编译成string，注意返回的字符串包含全部空格和换行符
<code>javascript
function test(a){ return a + a; }
assert(test.toString() ===
    "function test(a){ return a + a; }",
    "Function decompiled");
</code></p>

<p>用途：Prototype中提取函数的参数
<code>javascript
function argumentNames(fn) {
    var found = /^[\s\(]*function[^(]*\(\s*([^)]*?)\s*\)/
        .exec(fn.toString());
    return found &amp;&amp; found[1] ?
        found[1].split(/,\s*/) :
        [];
}
</code></p>

<p>检测浏览器是否支持反编译
<code>javascript
var FUNCTION_DECOMPILATION = /abc(.|\n)*xyz/.test(function(abc){xyz;});
assert(FUNCTION_DECOMPILATION,
    "Function decompilation works in this browser");
</code></p>

<h3 id="jsonjs">将JSON字符串转化成js对象</h3>
<p>很多浏览器支持JSON对象的parse()和stringify()方法
<code>javascript
var json = '{"name":"Ninja"}';
var object = eval("(" + json + ")");
assert(object.name === "Ninja",
    "My name is Ninja!");
</code></p>

<p><a href="https://github.com/douglascrockford/JSON-js">安全的实现</a>
做了很多预处理工作</p>

<h3 id="section-17">导入命名空间中的代码</h3>

<p><code>javascript
base2.namespace ==
    "var Base=base2.Base;var Package=base2.Package;"
eval(base2.namespace);
</code></p>

<h3 id="section-18">压缩和混淆</h3>
<p>将代码中的变量重新命名，压缩成一个字符串，使用eval解析执行</p>

<p><a href="http://dean.edwards.name/packer/">Dean Edwards’s Packer</a></p>

<p>但是小虽然能减少下载时间，但是解析时间不一定
load time = download time + evaluation time</p>

<h3 id="section-19">动态代码重写</h3>
<p>单元测试库<a href="https://github.com/nkallen/screw-unit">Screw.Unit</a></p>

<p>测试代码
<code>javascript
describe(“Matchers”, function() {
    it("invokes the provided matcher on a call to expect", function() {
        expect(true).to(equal, true);
        expect(true).to_not(equal, false);
    });
});
</code></p>

<p>使用Function构造函数，动态生成代码。通过with避免引入大量全局变量。
<code>javascript
var contents = fn.toString().match(/^[^{]*{((.*\n*)*)}/m)[1];
var fn = new Function("matchers", "specifications",
    "with (specifications) { with (matchers) { " + contents + " } }"
);
fn.call(this, Screw.Matchers, Screw.Specifications);
</code></p>

<h3 id="script-tag">面向方面的script tag</h3>
<p>面向方面编程：代码在运行时动态注入和执行，处理一些类似日志，缓存工作。</p>

<p>通过定义新的script type，浏览器会忽略
<code>javascript
&lt;script type="text/javascript"&gt;
    window.onload = function(){
        var scripts = document.getElementsByTagName("script");
        for (var i = 0; i &lt; scripts.length; i++) {
            if (scripts[i].type == "x/onload") {
                globalEval(scripts[i].innerHTML);
            }
        }
    };
&lt;/script&gt;
&lt;script type="x/onload"&gt;
    assert(true,"Executed on page load");
&lt;/script&gt;
</code></p>

<p>jquery的tmp方法提供运行时的模板</p>

<h3 id="dsl">元语言和DSL领域特定语言</h3>

<p><a href="http://processing.org/">Processing.js</a></p>

<p>john resig写了<a href="http://ejohn.org/blog/processingjs/">js的版本</a>应用于HTML5 canvas</p>

<p>使用元语言的好处：</p>

<ul>
  <li>先进的语言特性：如class和继承</li>
  <li>使用简单的画图api</li>
</ul>

<p>示例代码
<code>javascript
&lt;script type="application/processing"&gt;
class SpinSpots extends Spin {
    float dim;
    SpinSpots(float x, float y, float s, float d) {
        super(x, y, s);
        dim = d;
    }
    void display() {
        noStroke();
        pushMatrix();
        translate(x, y);
        angle += speed;
        rotate(angle);
        ellipse(-dim/2, 0, dim, dim);
        ellipse(dim/2, 0, dim, dim);
        popMatrix();
    }
}
&lt;/script&gt;
</code></p>

<p>转化成js，使用eval执行
<code>javascript
function SpinSpots() {with(this){
    var __self=this;function superMethod(){
    extendClass(__self,arguments,Spin);
    this.dim = 0;
    extendClass(this, Spin);
    addMethod(this, 'display', function() {
        noStroke();
        pushMatrix();
        translate(x, y);
        angle += speed;
        rotate(angle);
        ellipse(-dim/2, 0, dim, dim);
        ellipse(dim/2, 0, dim, dim);
        popMatrix();
    });
    if ( arguments.length == 4 ) {
        var x = arguments[0];
        var y = arguments[1];
        var s = arguments[2];
        var d = arguments[3];
        superMethod(x, y, s);
        dim = d;
    }
}}
</code></p>

<h2 id="ch10-with">ch10 with语句</h2>

<h3 id="with-scope">在with scope中引用属性</h3>
<p>性能差，this指向全局对象，可以给已有属性赋值，但是如果想要增加新属性，
必须通过<code>object.prop</code>才能创建，否则在全局对象中创建。</p>

<h3 id="with">现实中使用with的例子</h3>

<p>Prototype中提高代码可读性
<code>javascript
Object.extend(String.prototype.escapeHTML, {
    div: document.createElement('div'),
    text: document.createTextNode('')
});
with (String.prototype.escapeHTML) div.appendChild(text);
</code></p>

<p>但是不一定要这样做，使用立即执行function也可以办到，虽然还是需要短小的前缀
<code>javascript
(function(s){
    s.div.appendChild(s.text);
})(String.prototype.escapeHTML);
</code></p>

<h3 id="section-20">导入命名空间中的代码</h3>
<p><code>javascript
with (YAHOO.util.Dom) {
    YAHOO.util.Event.on([get('item'), get('otheritem')], 'click',
        function(){ setStyle(this,'color','#c00'); });
}
</code></p>

<h3 id="section-21">测试</h3>
<p><code>javascript
new Test.Unit.Runner({
    testSliderBasics: function(){with(this){
        var slider = new Control.Slider('handle1', 'track1');
        assertInstanceOf(Control.Slider, slider);
        assertEqual('horizontal', slider.axis);
        assertEqual(false, slider.disabled);
        assertEqual(0, slider.value);
        slider.dispose();
    }},
    // ...
});
</code></p>

<h3 id="section-22">模板</h3>
<p><code>javascript
(function(){
    var cache = {};
    this.tmpl = function tmpl(str, data){
        var fn = !/\W/.test(str) ?
            cache[str] = cache[str] ||
                tmpl(document.getElementById(str).innerHTML) :
            new Function("obj",
                "var p=[],print=function(){p.push.apply(p,arguments);};" +
                "with(obj){p.push('" +
                str
                    .replace(/[\r\t\n]/g, " ")
                    .split("&lt;%").join("\t")
                    .replace(/((^|%&gt;)[^\t]*)'/g, "$1\r")
                    .replace(/\t=(.*?)%&gt;/g, "',$1,'")
                    .split("\t").join("');")
                    .split("%&gt;").join("p.push('")
                    .split("\r").join("\\'")
                + "');}return p.join('');");
        return data ? fn( data ) : fn;
    };
})();
assert( tmpl("Hello, &lt;%= name %&gt;!", {name: "world"}) ==
    "Hello, world!", "Do simple variable inclusion." );
var hello = tmpl("Hello, &lt;%= name %&gt;!");
assert( hello({name: "world"}) == "Hello, world!",
    "Use a pre-compiled template." );
</code></p>

<h2 id="ch11-">ch11 跨浏览器策略</h2>

<h3 id="section-23">封装代码</h3>
<p>不影响加载页面中的其他代码</p>

<h3 id="section-24">避免属性冲突</h3>
<p>使用hasOwnProperty判断，和in的区别是前者不会检查原型链</p>

<h3 id="id">贪婪的id</h3>

<p>没有取到form的action属性，而是input#action
```javascript
&lt;form id="form" action="/conceal"&gt;
<input type="text" id="action" />
<input type="submit" id="submit" />
&lt;/form&gt;</p>

<p>var what = document.getElementById(‘form’).action;
```
原因是浏览器会将form中每个input元素作为属性(prop)增加到form中，属性名就是input的id。所以产生了冲突，form的本身属性被覆盖了。</p>

<p>可以查看node信息获得正确的action值
<code>var actionValue = element.getAttibuteNode("action").nodeValue;</code></p>

<h2 id="ch12-attribute-property-css">ch12 attribute property css</h2>
<p>attribute是dom构建的完整部分，property是元素保存运行时信息，提供访问的主要方式</p>

<p>奇怪的测试，给img.src赋值，但是结果却不一样。没有改变attribute，但是还是变了。
<code>javascript
&lt;img src="../images/ninja-with-nunchuks.png"&gt;
&lt;script type="text/javascript"&gt;
    var image = document.getElementsByTagName('img')[0];
    var newSrc = '../images/ninja-with-pole.png';
    image.src = newSrc;
    assert(image.src === newSrc,
        'the image source is now ' + image.src);//http://localhost/ninja/images/ninja-with-pole.png
    assert(image.getAttribute('src') === '../images/ninja-with-nunchuks.png',
        'the image src attribute is ' + image.getAttribute('src'));//../images/ninja-with-pole.png
&lt;/script&gt;
</code></p>

<h3 id="section-25">浏览器命名不同</h3>
<p>大多数浏览器可以通过getAttribute(“class”)取到class，但是IE使用className，保持和property一致。</p>

<h3 id="section-26">命名限制</h3>
<p>attr和prop不能做到一一对应，因为要考虑到保留字，比如label的for(attr)，就只能通过htmlFor(prop)。
另外，由多个词组合成的attr，对应的prop要使用驼峰命名方式，如maxLength,rowSpan。
这是因为通过prop访问<code>element.style.font-size;</code>连字符会被当做减号。</p>

<h3 id="xmlhtml">xml和html间的区别</h3>
<p>attr和prop的对应关系是HTML DOM的特性，在处理XML DOM时，prop不会自动创建代表attr。</p>

<p>判断XML
<code>javascript
function isXML(elem) {
    return elem.ownerDocument ||
        elem.documentElement.nodeName.toLowerCase() !== "html";
}
</code></p>

<h3 id="attr">自定义attr</h3>
<p>自定义attr，只能通过get/setAttribute
<code>var value = element.someValue ? element.someValue :element.getAttribute('someValue');</code></p>

<h3 id="section-27">性能考虑</h3>
<p>通常prop访问比getAttribute速度快</p>

<h3 id="url">url标准化</h3>
<p>浏览器特性：当访问指向url的prop时，如src,action,href，URL值会被标准化成完整的路径。attr不会。</p>

<h3 id="style-attr">style attr</h3>
<p>例子<code>&lt;div style='color:red;'&gt;&lt;/div&gt;</code></p>

<p><code>element.style.color</code>通过prop可以取得style对象的属性值，但如果我们想访问style中整个字符串，通过prop显然不行。
通过<code>getAttribute("style")</code>在大多数浏览器中可行。IE在style对象中增加cssText属性存储，所以可以通过<code>element.style.cssText</code>访问。</p>

<h3 id="type-attr">type attr</h3>
<p>IE9之前的版本不允许修改input的type attr，一旦它被插入文档中。P267</p>

<h3 id="style">style的位置</h3>
<p>style属性优先级最高，比!important还高。
```javascript</p>
<style>
    div { font-size: 1.8em; border: 0 solid gold; }
</style>

<div style="color:#000;" title="Ninja power!">
    忍者パワー
</div>
<script>
window.onload = function(){
    var div = document.getElementsByTagName("div")[0];
    assert(div.style.color == 'rgb(0, 0, 0)' ||
        div.style.color == '#000',
        'color was recorded');
    assert(div.style.fontSize == '1.8em',
        'fontSize was recorded');   // fail
    assert(div.style.boderWidth == '0',
        'borderWidth was recorded');   // fail
        div.style.borderWidth = "4px";
    assert(div.style.borderWidth == '4px',
        'borderWidth was replaced');
};
</script>

<p>```</p>

<h3 id="section-28">像素值</h3>

<p>有些属性需要加上单位
<code>javascript
element.style.height = "10px";
element.style.height = 10 + "px";
</code></p>

<h3 id="heightwidth">度量height和width</h3>
<p>两者的值根据内容变化，无法通过height和width属性得到精确值。</p>

<p>offsetHeight和offsetWidth属性包括padding。但是对于<code>display:none</code>的元素，值是0。</p>

<p>如果想度量一个隐藏元素非隐藏时的大小</p>

<ol>
  <li>display: block 使offsetHeight/Width可度量</li>
  <li>visibility: hidden 不显示</li>
  <li>position: absolute 虽然不显示，但会留下空洞，需要脱离正常的显示流</li>
  <li>抓取值</li>
  <li>恢复改变的属性</li>
</ol>

<h3 id="section-29">透明度</h3>
<p>所有现代浏览器包括IE9，支持<code>opacity: 0.5</code>，
IE9之前，使用<code>filter: alpha(opacity=50)</code></p>

<p>2大困难</p>

<ul>
  <li>filter种类除了alpha还有很多，不能确定</li>
  <li>即使不支持opacity，IE8或者更早的版本还是会返回style.opacity的值，尽管浏览器会忽略，导致无法判断浏览器是否支持。</li>
</ul>

<p>还是有办法判断：
<code>opacity: .5</code>，支持的浏览器会规范化成0.5，而不支持的浏览器会简单返回.5
<code>javascript
var div = document.createElement("div");
div.setAttribute('style','opacity:.5');
var OPACITY_SUPPORTED = div.style.opacity === "0.5";
assert(OPACITY_SUPPORTED,
    "Opacity is supported.");
</code></p>

<h3 id="section-30">颜色</h3>
<p>表达方式多种
<a href="http://plugins.jquery.com/project/color">jQuery Color plugin</a></p>

<h3 id="section-31">获取计算后的样式</h3>

<p><code>window.getComputedStyle()</code>IE9+，接受element作为参数，返回一个接口。
返回的接口有方法<code>getPropertyValue()</code>来获取计算后的样式值。</p>

<p>与style.prop不同，getPropertyValue接受css属性值(非驼峰)作为参数。</p>

<p>IE9之前的版本，每个元素有currentStyle属性</p>

<p><code>javascript
function fetchComputedStyle(element,property) {
    if (window.getComputedStyle) {
        var computedStyles = window.getComputedStyle(element);
        if (computedStyles) {
            property = property.replace(/([A-Z])/g,'-$1').toLowerCase();
            return computedStyles.getPropertyValue(property);
        }
    }
    else if (element.currentStyle) {
        property = property.replace(
            /-([a-z])/ig,
            function(all,letter){ return letter.toUpperCase(); });
        return element.currentStyle[property];
    }
}
</code></p>

<h2 id="ch13-">ch13 事件</h2>
<p>DOM Level 0 Event Model 
<code>javascript
&lt;body onload="doSomething()"&gt;
window.onload = doSomething;
</code></p>

<p>DOM Level 2 Event Model</p>

<h3 id="section-32">绑定事件处理器</h3>
<p>add/removeEventListener 主流浏览器 IE9+</p>

<p>attach/detachEvent IE9-  IE MODEL</p>

<p>IE Model不提供监听事件捕获阶段，只有冒泡阶段。
在冒泡阶段，事件从目标向DOM根节点传播，在捕获阶段反向传播。</p>

<p>并且，IE MODEL不设置处理器上下文，导致处理器内部this指向全局对象。不传递事件信息到处理器，而是传到全局上下文window对象。</p>

<h4 id="section-33">解决设置上下文的问题</h4>
<p><code>javascript
if (document.addEventListener) {
    this.addEvent = function (elem, type, fn) {
        elem.addEventListener(type, fn, false);
        return fn;
    };
    this.removeEvent = function (elem, type, fn) {
        elem.removeEventListener(type, fn, false);
    };
}
else if (document.attachEvent) {
    this.addEvent = function (elem, type, fn) {
        var bound = function () {
            return fn.apply(elem, arguments);
        };
        elem.attachEvent("on" + type, bound);
        return bound;
    };
    this.removeEvent = function (elem, type, fn) {
        elem.detachEvent("on" + type, fn);
    };
}
</code>
p291</p>

<h3 id="section-34">解决事件对象的问题</h3>
<p>主要修复IE MODEL存在的问题
<code>javascript
function fixEvent(event) {
    function returnTrue() { return true; }
    function returnFalse() { return false; }
    if (!event || !event.stopPropagation) {
        var old = event || window.event;
        // Clone the old object so that we can modify the values
        event = {};
        for (var prop in old) {
            event[prop] = old[prop];
        }
        // The event occurred on this element
        if (!event.target) {
            event.target = event.srcElement || document;
        }
        // Handle which other element the event is related to
        event.relatedTarget = event.fromElement === event.target ?
            event.toElement :
            event.fromElement;
        // Stop the default browser action
        event.preventDefault = function () {
            event.returnValue = false;
            event.isDefaultPrevented = returnTrue;
        };
        event.isDefaultPrevented = returnFalse;
        // Stop the event from bubbling
        event.stopPropagation = function () {
            event.cancelBubble = true;
            event.isPropagationStopped = returnTrue;
        };
        event.isPropagationStopped = returnFalse;
        // Stop the event from bubbling and executing other handlers
        event.stopImmediatePropagation = function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        };
        event.isImmediatePropagationStopped = returnFalse;
        // Handle mouse position
        if (event.clientX != null) {
            var doc = document.documentElement, body = document.body;
            event.pageX = event.clientX +
                (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) -
                (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);
            event.pageY = event.clientY +
                (doc &amp;&amp; doc.scrollTop || body &amp;&amp; body.scrollTop || 0) -
                (doc &amp;&amp; doc.clientTop || body &amp;&amp; body.clientTop || 0);
        }
        // Handle key presses
        event.which = event.charCode || event.keyCode;
        // Fix button for mouse clicks:
        // 0 == left; 1 == middle; 2 == right
        if (event.button != null) {
            event.button = (event.button &amp; 1 ? 0 :
                (event.button &amp; 4 ? 1 :
                (event.button &amp; 2 ? 2 : 0)));
        }
    }
    return event;
}
</code></p>

<h3 id="section-35">处理器管理</h3>
<p>一个元素绑定了多个事件处理器，难以管理</p>

<h4 id="section-36">存储相关信息</h4>
<p><code>javascript
&lt;div title="Ninja Power!"&gt; 忍者パワー!&lt;/div&gt;
&lt;div title="Secrets"&gt; 秘密&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    (function () {
        var cache = {},
            guidCounter = 1,
            expando = "data" + (new Date).getTime(); //保证对象之前没有同名属性
        this.getData = function (elem) {
            var guid = elem[expando];
            if (!guid) {
                guid = elem[expando] = guidCounter++;
                cache[guid] = {};
            }
            return cache[guid];
        };
        this.removeData = function (elem) {
            var guid = elem[expando];
            if (!guid) return;
            delete cache[guid];
            try {
                delete elem[expando];
            }
            catch (e) {
                if (elem.removeAttribute) {
                    elem.removeAttribute(expando);
                }
            }
        };
    })();
    var elems = document.getElementsByTagName('div');
    for (var n = 0; n &lt; elems.length; n++) {
        getData(elems[n]).ninja = elems[n].title;
    }
    for (var n = 0; n &lt; elems.length; n++) {
        assert(getData(elems[n]).ninja === elems[n].title,
            "Stored data is " + getData(elems[n]).ninja);
    }
    for (var n = 0; n &lt; elems.length; n++) {
        removeData(elems[n]);
        assert(getData(elems[n]).ninja === undefined,
            "Stored data has been destroyed.")
    }
&lt;/script&gt;
</code></p>

<h4 id="section-37">管理事件处理器</h4>
<p>绑定事件处理器
<code>javascript
(function(){
    var nextGuid = 1;
    this.addEvent = function (elem, type, fn) {
        var data = getData(elem); //取得存储对象，后面要多次引用
        if (!data.handlers) data.handlers = {};
        if (!data.handlers[type])
            data.handlers[type] = []; //存储参数事件的处理器数组
        if (!fn.guid) fn.guid = nextGuid++; //每个回调函数存储独特的guid
        data.handlers[type].push(fn); //添加回调函数
        if (!data.dispatcher) {
            data.disabled = false;
            data.dispatcher = function (event) { //创建分发器
                if (data.disabled) return;
                event = fixEvent(event); //使用修复过的event
                var handlers = data.handlers[event.type];
                if (handlers) {
                    for (var n = 0; n &lt; handlers.length; n++) {
                        handlers[n].call(elem, event); //调用回调函数，并将事件对象传递到函数中，修复IE MODEL的问题
                    }
                }
            };
        }
        if (data.handlers[type].length == 1) { //第一次注册dispatcher
            if (document.addEventListener) {
                elem.addEventListener(type, data.dispatcher, false);
            }
            else if (document.attachEvent) {
                elem.attachEvent("on" + type, data.dispatcher);
            }
        }this.removeEvent = function (elem, type, fn) {
    };
})();
</code></p>

<p>回收资源工具方法，需要多次调用
<code>javascript
function tidyUp(elem, type) {
    function isEmpty(object) { //内部使用
        for (var prop in object) {
            return false;
        }
        return true;
    }
    var data = getData(elem);
    if (data.handlers[type].length === 0) {// 某个事件的处理器数组空了，回收数组
        delete data.handlers[type]; 
        if (document.removeEventListener) {
            elem.removeEventListener(type, data.dispatcher, false);
        }
        else if (document.detachEvent) {
            elem.detachEvent("on" + type, data.dispatcher);
        }
    }
    if (isEmpty(data.handlers)) { //如果处理器对象空了，回收对象和分发器
        delete data.handlers;
        delete data.dispatcher;
    }
    if (isEmpty(data)) { //如果导致存储对象空了，回收整个对象
        removeData(elem);
    }
}
</code></p>

<p>解除绑定，使用变长参数列表
<code>javascript
this.removeEvent = function (elem, type, fn) {// 可以通过检查elem的data-属性判断elem是否合理
    var data = getData(elem);
    if (!data.handlers) return;
    var removeType = function(t){ //移除事件类型参数的处理器数组
        data.handlers[t] = [];
        tidyUp(elem,t);
    };
    if (!type) { //如果没有传入特定的事件类型参数，清空所有事件处理器
        for (var t in data.handlers) removeType(t);
        return;
    }
    var handlers = data.handlers[type];
    if (!handlers) return;
    if (!fn) { //如果没有回调函数参数，清空该事件类型的所有处理器
        removeType(type);
        return;
    }
    if (fn.guid) { //在addEvent中添加的属性
        for (var n = 0; n &lt; handlers.length; n++) {
            if (handlers[n].guid === fn.guid) {
                handlers.splice(n--, 1); //可能有多个同样的处理器，不能找到一个就终止，在数组中删除当前的元素，指针前移
            }
        }
    }
    tidyUp(elem, type);
};
</code></p>

<h3 id="section-38">触发事件</h3>
<p>事件触发时：</p>

<ul>
  <li>目标元素绑定的处理器被触发</li>
  <li>事件冒泡，触发其他绑定的处理器</li>
  <li>目标元素如果有默认的action，触发，比如目标元素定义了focus方法，focus事件需要能触发它</li>
</ul>

<p>第二个参数可以是event对象或者是表示事件类型的string
<code>javascript
function triggerEvent(elem, event) {
    var elemData = getData(elem),
        parent = elem.parentNode || elem.ownerDocument;
    if (typeof event === "string") {
        event = { type:event, target:elem };
    }
    event = fixEvent(event);
    if (elemData.dispatcher) {
        elemData.dispatcher.call(elem, event);
    }
    if (parent &amp;&amp; !event.isPropagationStopped()) { //没有显式停止传播，递归调用向上冒泡
        triggerEvent(parent, event);
    }
    else if (!parent &amp;&amp; !event.isDefaultPrevented()) { //已到达dom顶端，触发默认的action，比如目标元素有focus方法
        var targetData = getData(event.target);
        if (event.target[event.type]) {
            targetData.disabled = true;
            event.target[event.type]();
            targetData.disabled = false;
        }
    }
}
</code></p>

<h3 id="section-39">自定义事件</h3>
<p>需要在不同场合下多次调用一段代码，使用全局函数？自定义事件，松耦合。</p>

<h4 id="ajax">ajax例子</h4>
<p>需要在ajax开始和结束时显示隐藏图片，绑定在body上，这样事件总会冒泡上来
<code>javascript
var body = document.getElementsByTagName('body')[0];
addEvent(body, 'ajax-start', function(e){
    document.getElementById('whirlyThing').style.display = 'inline-block';
});
addEvent(body, 'ajax-complete', function(e){
    document.getElementById('whirlyThing').style.display = 'none';
});
</code>
这其实是事件的委托。</p>

<h3 id="section-40">冒泡和委托</h3>
<p>委托：在目标节点更高级的dom节点上建立事件处理器</p>

<h4 id="section-41">委托事件给祖先节点</h4>

<p>场景：点击每一个td使其变色</p>

<p>最初的想法：在每个td上绑定click事件处理器
<code>javascript
var cells = document.getElementsByTagName('td');
for (var n = 0; n &lt; cells.length; n++) {
    addEvent(cells[n], 'click', function(){
        this.style.backgroundColor = 'yellow';
    });
}
</code></p>

<p>能工作，但是在数百个元素上绑定同样的处理器，做同样的事。不够优雅。
event.target可以取得事件放生的元素，委托祖先节点处理。
<code>javascript
var table = document.getElementById('#someTable');
addEvent(table, 'click', function(event){
    if (event.target.tagName.toLowerCase() == 'td')
        event.target.style.backgroundColor = 'yellow';
});
</code></p>

<h4 id="section-42">浏览器缺陷</h4>
<p>submit,change,focus,blur在不同浏览器的冒泡实现中，存在严重问题。</p>

<p>事件冒泡检测代码，使用div是因为包含最多的冒泡事件种类
<code>javascript
function isEventSupported(eventName) {
    var element = document.createElement('div'),
    isSupported;
    eventName = 'on' + eventName;
    isSupported = (eventName in element);
    if (!isSupported) {
        element.setAttribute(eventName, 'return;');
        isSupported = typeof element[eventName] == 'function';
    }
    element = null;
    return isSupported;
}
</code>
##### submit事件冒泡
submit在IE MODEL中不能正确冒泡，有两种方式触发：</p>

<ul>
  <li>type为submit的input/button元素，或者type为image的input元素。可以通过点击，也可以在取得焦点后通过回车或者空格键触发。</li>
  <li>在type为text/password的input元素中按回车。</li>
</ul>

<p>通过可以正常冒泡的click和keyress事件处理器触发submit事件。
```javascript
(function(){
    var isSubmitEventSupported = isEventSupported(“submit”);
    function isInForm(elem) { //判断元素是否在form元素内部
        var parent = elem.parentNode;
        while (parent) {
            if (parent.nodeName.toLowerCase() === “form”) {
                return true;
            }
            parent = parent.parentNode;
        }
        return false;
    }</p>

<pre><code>function triggerSubmitOnClick(e) {
    var type = e.target.type;
    if ((type === "submit" || type === "image") &amp;&amp;
        isInForm(e.target)) {
        return triggerEvent(this,"submit");
    }
}

function triggerSubmitOnKey(e) {
    var type = e.target.type;
    if ((type === "text" || type === "password") &amp;&amp;
        isInForm(e.target) &amp;&amp; e.keyCode === 13) {
        return triggerEvent(this,"submit");
    }
}

this.addSubmit = function (elem, fn) {
    addEvent(elem, "submit", fn);
    if (isSubmitEventSupported) return; //如果浏览器支持，短路
    if (elem.nodeName.toLowerCase() !== "form" &amp;&amp; //如果是form不存在冒泡不正确的问题
            getData(elem).handlers.submit.length === 1) { //如果是第一个被绑定的处理器
        addEvent(elem, "click", triggerSubmitOnClick);
        addEvent(elem, "keypress", triggerSubmitOnKey);
    }
};
this.removeSubmit = function (elem, fn) {
    removeEvent(elem, "submit", fn);
    if (isEventSupported("submit")) return;
    var data = getData(elem);
    if (elem.nodeName.toLowerCase() !== "form" &amp;&amp;
            !data || !data.events || !data.events.submit) {
        removeEvent(elem, "click", triggerSubmitOnClick);
        removeEvent(elem, "keypress", triggerSubmitOnKey);
    }
}; })(); ```
</code></pre>

<h5 id="change">change事件冒泡</h5>
<p>需要绑定更多的事件</p>

<ul>
  <li>The focusout event for checking the value after moving away from the form element</li>
  <li>The click and keydown events for checking the value the instant it’s been changed</li>
  <li>The beforeactivate event for getting the previous value before a new one is set</li>
</ul>

<p><code>javascript
(function(){
    this.addChange = function (elem, fn) {
        addEvent(elem, "change", fn);
        if (isEventSupported("change")) return;
        if (getData(elem).events.change.length === 1) {
            addEvent(elem, "focusout", triggerChangeIfValueChanged);
            addEvent(elem, "click", triggerChangeOnClick);
            addEvent(elem, "keydown", triggerChangeOnKeyDown);
            addEvent(elem, "beforeactivate", triggerChangeOnBefore);
        }
    };
    this.removeChange = function (elem, fn) {
        removeEvent(elem, "change", fn);
        if (isEventSupported("change")) return;
        var data = getData(elem);
        if (!data || !data.events || !data.events.submit) {
            addEvent(elem, "focusout", triggerChangeIfValueChanged);
            addEvent(elem, "click", triggerChangeOnClick);
            addEvent(elem, "keydown", triggerChangeOnKeyDown);
            addEvent(elem, "beforeactivate", triggerChangeOnBefore);
        }
    };
    function triggerChangeOnClick(e) {
        var type = e.target.type;
        if (type === "radio" || type === "checkbox" ||
                e.target.nodeName.toLowerCase() === "select") {
            return triggerChangeIfValueChanged.call(this, e);
        }
    }
    function triggerChangeOnKeyDown(e) {
        var type = e.target.type,
        key = e.keyCode;
        if (key === 13 &amp;&amp; e.target.nodeName.toLowerCase() !== "textarea" ||
                key === 32 &amp;&amp; (type === "checkbox" || type === "radio") ||
                type === "select-multiple") {
            return triggerChangeIfValueChanged.call(this, e);
        }
    }
    function triggerChangeOnBefore(e) { //保存改变前的值
        getData(e.target)._change_data = getVal(e.target);
    }
    function getVal(elem) {
        var type = elem.type,
        val = elem.value;
        if (type === "radio" || type === "checkbox") {
            val = elem.checked;
        } else if (type === "select-multiple") {
            val = "";
            if (elem.selectedIndex &gt; -1) {
                for (var i = 0; i &lt; elem.options.length; i++) {
                    val += "-" + elem.options[i].selected;
                }
            }
        } else if (elem.nodeName.toLowerCase() === "select") {
            val = elem.selectedIndex;
        }
        return val;
    }
    function triggerChangeIfValueChanged(e) {
        var elem = e.target, data, val;
        var formElems = /textarea|input|select/i;
        if (!formElems.test(elem.nodeName) || elem.readOnly) {
            return;
        }
        data = getData(elem)._change_data;
        val = getVal(elem);
        if (e.type !== "focusout" || elem.type !== "radio") {
            getData(elem)._change_data = val;
        }
        if (data === undefined || val === data) { //值没发生改变，不触发
            return;
        }
        if (data != null || val) {
            return triggerEvent(elem, "change");
        }
    }
})();
</code></p>

<h5 id="focusin--focusout">focusin 和 focusout</h5>
<p>IE MODEL中在focus和blur之前会触发非标准的focusin和focusout事件，所以只要在addEvent中判断即可</p>

<p><code>javascript
if (document.addEventListener) {
    elem.addEventListener(
        type === "focusin" ? "focus" :
        type === "focusout" ? "blur" : type,
        data.handler, type === "focusin" || type === "focusout");
}
else if (document.attachEvent) {
    elem.attachEvent("on" + type, data.handler);
}
</code>
##### mouseenter和mouseleave事件
IE MODEL自定义的两个事件</p>

<p>通常使用标准的mouseover和mouseout事件，问题是由于事件的冒泡机制，除了父元素，在子元素之间移动时也会触发事件。这在实际场景例如菜单等交互元素中，我们只想知道是否还在父元素内，而不是离开一个子元素到另一个时也触发事件。</p>

<p>并且，当鼠标从父元素移动到内部的子元素时，mouseout事件会触发，尽管直观上并没有离开父元素。同理，从子元素离开时，mouseover事件会被触发。</p>

<p>所以IE MODEL实现的这两个事件还是很有用的，需要在其他浏览器中模拟。
<code>javascript
(function() {
    if (isEventSupported("mouseenter")) { //IE MODEL
        this.hover = function (elem, fn) {
            addEvent(elem, "mouseenter", function () {
                fn.call(elem, "mouseenter");
            });
            addEvent(elem, "mouseleave", function () {
                fn.call(elem, "mouseleave");
            });
        };
    }
    else { //不支持mouseenter和mouseleave的浏览器
        this.hover = function (elem, fn) {
            addEvent(elem, "mouseover", function (e) {
                withinElement(this, e, "mouseenter", fn);
            });
            addEvent(elem, "mouseout", function (e) {
                withinElement(this, e, "mouseleave", fn);
            });
        };
    }
    function withinElement(elem, event, type, handle) {
        var parent = event.relatedTarget; //取得从哪进入或者离开去哪
        while (parent &amp;&amp; parent != elem) {
            try {
                parent = parent.parentNode;
            }
            catch (e) {
                break;
            }
        }
        if (parent != elem) { //relatedTarget不在elem内部
            handle.call(elem, type);
        }
    }
})();
</code></p>

<h3 id="document-ready">document ready事件</h3>
<p>DOMContentLoaded，当整个DOM文档加载完毕触发ready事件，但是在页面展示之前。对于IE9之前的版本：</p>

<ul>
  <li>把文档滚动到最左边的操作会失败，除非文档加载完毕。</li>
  <li>监听document的onreadystatechange事件，会比第一种晚一点触发，但是仍会在window的load事件之前。</li>
  <li>检查document的readyState属性，这被所有浏览器支持，用来记录加载DOM文档的完整程度。</li>
</ul>

<p>```javascript
(function () {
    var isReady = false,
        contentLoadedHandler;
    function ready() {
        if (!isReady) {
            triggerEvent(document, “ready”);
            isReady = true;
        }
    }</p>

<pre><code>if (document.readyState === "complete") {//如果此时已经加载完成，触发事件即可
    ready();
}

if (document.addEventListener) {//W3C 浏览器
    contentLoadedHandler = function () {
        document.removeEventListener(
            "DOMContentLoaded", contentLoadedHandler, false);
        ready();
    };
    document.addEventListener(
        "DOMContentLoaded", contentLoadedHandler, false);
}
else if (document.attachEvent) {//IE MODEL
    contentLoadedHandler = function () {
        if (document.readyState === "complete") {
            document.detachEvent(
                "onreadystatechange", contentLoadedHandler);
            ready();
        }
    };
    document.attachEvent(
        "onreadystatechange", contentLoadedHandler);
    var toplevel = false;
    try {
        toplevel = window.frameElement == null;
    }
    catch (e) {
    }
    if (document.documentElement.doScroll &amp;&amp; toplevel) { //不在iframe中
        doScrollCheck();
    }
}

function doScrollCheck() {
    if (isReady) return;
    try {
        document.documentElement.doScroll("left");
    }
    catch (error) {
        setTimeout(doScrollCheck, 1); //移动失败继续尝试
        return;
    }
    ready();
} })(); ```
</code></pre>

<h2 id="ch14-dom">ch14 操作DOM</h2>
<p>很多lib实现考虑效率问题。比如插入html，使用<a href="https://developer.mozilla.org/en/DOM/range.createContextualFragment">createContextualFragment</a>效率就比通常使用的createElement高。</p>

<p>一个DOM操作实现<a href="https://github.com/tomhuda/metamorph.js/blob/master/lib/metamorph.js">metamorph.js</a></p>

<h3 id="htmldom">注入HTML到DOM中</h3>
<p>DOM操作API</p>

<ol>
  <li>将合法的HTML/XML字符串转化成DOM结构</li>
  <li>将DOM结构注入到DOM的任意有效位置</li>
  <li>执行字符串中包含的行内脚本</li>
</ol>

<h4 id="html---dom">HTML字符串 -&gt; DOM</h4>
<p>使用DOM元素的innerHTML属性</p>

<ul>
  <li>确保html字符串是合法的</li>
  <li>用标记包装字符串</li>
  <li>使用DOM元素的innerHTML属性插入HTML字符串</li>
  <li>返回DOM节点</li>
</ul>

<h5 id="xmlhtml-1">预处理XML/HTML源字符串</h5>
<p>比如要支持自闭合的标签比如<code>&lt;table/&gt;</code>，需要转换成<code>&lt;table&gt;&lt;/table&gt;</code>，便于所有浏览器支持。</p>

<p>列出只能以自闭合形式出现的标签
<code>javascript
var tags =
    /^(abbr|br|col|img|input|link|meta|param|hr|area|embed)$/i;
function convert(html) {
    return html.replace(/(&lt;(\w+)[^&gt;]*?)\/&gt;/g, function (all, front, tag) {
        return tags.test(tag) ?
            all :
            front + "&gt;&lt;/" + tag + "&gt;";
    });
}
</code></p>

<h5 id="html">HTML包装</h5>
<p>一些HTML元素必须被容器元素包裹。例如<code>&lt;option&gt;</code>必须在<code>&lt;select&gt;</code>中</p>

<p>有两种方法解决这个问题，都需要构建元素和容器的映射</p>

<h5 id="dom">生成DOM</h5>

<p>```javascript
function getNodes(htmlString, doc, fragment) {
    var map = {
        “&lt;td”:[3,”&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;”,”&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;”],
        “&lt;th”:[3,”&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;”,”&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;”],
        “&lt;tr”:[2,”&lt;table&gt;&lt;thead&gt;”,”&lt;/thead&gt;&lt;/table&gt;”],
        “&lt;option”:[1,”<select multiple="multiple">”,”</select>”],
        “&lt;optgroup”:[1,”<select multiple="multiple">”,”</select>”],
        “&lt;legend”:[1,”&lt;fieldset&gt;”,”&lt;/fieldset&gt;”],
        “&lt;thead”:[1,”&lt;table&gt;”,”&lt;/table&gt;”],
        “&lt;tbody”:[1,”&lt;table&gt;”,”&lt;/table&gt;”],
        “&lt;tfoot”:[1,”&lt;table&gt;”,”&lt;/table&gt;”],
        “&lt;colgroup”:[1,”&lt;table&gt;”,”&lt;/table&gt;”],
        “&lt;caption”:[1,”&lt;table&gt;”,”&lt;/table&gt;”],
        “&lt;col”:[2,”&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;”,”&lt;/colgroup&gt;&lt;/table&gt;”],
        “&lt;link”:[3,”&lt;div&gt;&lt;/div&gt;&lt;div&gt;”,”&lt;/div&gt;”]
    };
    var tagName = htmlString.match(/&lt;\w+/),
        mapEntry = tagName ? map[tagName[0]] : null;
    if (!mapEntry) mapEntry = [0, “ “. “ “ ];
    var div = (doc || document).createElement(“div”); //默认document
    div.innerHTML = mapEntry[1] + htmlString + mapEntry[2];//使用容器元素进行包裹
    while (mapEntry[0]–) div = div.lastChild; //按照层数取得最内层的节点，就是想要创建的节点</p>

<pre><code>if(fragment){//DOM fragment供元素注入
    while(div.firstChild){
        fragment.appendChild(div.firstChild);
    }
}
return div.childNodes; } assert(getNodes("&lt;td&gt;test&lt;/td&gt;&lt;td&gt;test2&lt;/td&gt;").length === 2,
"Get two nodes back from the method."); assert(getNodes("&lt;td&gt;test&lt;/td&gt;")[0].nodeName === "TD",
"Verify that we're getting the right node."); ```
</code></pre>

<p>IE中还存在bug，在空的table中会创建<code>&lt;tbody&gt;</code>元素。修复方法可以检查table是否为空，如果是空的，就移除所有子节点。</p>

<p>另外，IE会对传入innerHTML属性的字符串进行trim，但是html会忽略空格。修复方法可以检查生成的第一个节点是否是文本节点。</p>

<h5 id="document">插入document</h5>

<p>使用W3C DOM标准的DOM fragment，被所有浏览器支持。</p>

<p>如果要将元素插入多个地方，需要复制fragment，这比复制每个节点效率高。因为多次调用append之类的方法，每次都要刷新页面，而将节点都加入一个fragment，再将fragment一次性添加到document中，只要刷新一次页面。</p>

<p>另外，如果想要将tr直接加入table元素，一般都认为是加入tbody元素中。</p>

<p>以下代码来自jquery中的应用
```javascript
function root(elem, cur) {
    return elem.nodeName.toLowerCase() === “table” &amp;&amp;
        cur.nodeName.toLowerCase() === “tr” ?
        (elem.getElementsByTagName(“tbody”)[0] ||
            elem.appendChild(elem.ownerDocument.createElement(“tbody”))) ://创建tbody并返回新添加的节点
        elem;
}</p>

<p>window.onload = function () {
    function insert(elems, args, callback) {
        if (elems.length) {
            var doc = elems[0].ownerDocument || elems[0],
                fragment = doc.createDocumentFragment(),
                scripts = getNodes(args, doc, fragment),
                first = fragment.firstChild;
            if (first) {
                for (var i = 0; elems[i]; i++) {
                    callback.call(root(elems[i], first),                        i &gt; 0 ? fragment.cloneNode(true) : fragment);//除了第一次都要进行复制
                }
            }
        }
    }
    var divs = document.getElementsByTagName(“div”);
    insert(divs, [“<b>Name:</b>”], function (fragment) {//传入字符串？
        this.appendChild(fragment);
    });
    insert(divs, [“<span>First</span> <span>Last</span>”],
        function (fragment) {
        this.parentNode.insertBefore(fragment, this);
    });
};
```</p>

<h5 id="section-43">执行脚本</h5>

<p>在插入到document之前，将内联脚本提取出来。ret数组保存所有生成的DOM节点。scripts数组保存所有提取出来的脚本节点。在插入操作完成后，解释执行这些脚本。
<code>javascript
for (var i = 0; ret[i]; i++) {//ret的大小可能会改变，所以判断条件是ret[i]非空
    if (jQuery.nodeName(ret[i], "script") &amp;&amp;
        (!ret[i].type ||
            ret[i].type.toLowerCase() === "text/javascript")) {//没有显式的type或者type是text/javascript
        scripts.push(ret[i].parentNode ?
            ret[i].parentNode.removeChild(ret[i]) :
            ret[i]);
    } else if (ret[i].nodeType === 1) {//检查子树中是否包含脚本节点
        ret.splice.apply(ret, [i + 1, 0].concat(//添加进ret数组中的当前下一个位置
            jQuery.makeArray(ret[i].getElementsByTagName("script"))));
    }
}
</code></p>

<p>解析出的脚本应该在全局上下文中执行。ch9中介绍过，通过在head中创建script元素并移除。
<code>javascript
function globalEval(data) {
    data = data.replace(/^\s+|\s+$/g, "");//移除首尾空白符
    if (data) {
        var head = document.getElementsByTagName("head")[0] ||
                document.documentElement,
            script = document.createElement("script");
        script.type = "text/javascript";
        script.text = data;
        head.insertBefore(script, head.firstChild);
        head.removeChild(script);
    }
}
</code></p>

<p>加上对非本地脚本的处理
<code>javascript
function evalScript(elem) {
    if (elem.src)
        jQuery.ajax({
            url:elem.src,
            async:false,
            dataType:"script"
        });
    else
        jQuery.globalEval(elem.text || "");
    if (elem.parentNode)
        elem.parentNode.removeChild(elem);
}
</code></p>

<h3 id="section-44">克隆元素</h3>

<p>cloneNode方法，参数表示是否拷贝所有子节点。</p>

<p>首先检测cloneNode是否会拷贝事件处理器包括扩展属性，IE中的问题
<code>javascript
var div = document.createElement("div");
if (div.attachEvent &amp;&amp; div.fireEvent) {
    div.attachEvent("onclick", function () {
        jquery.support.noCloneEvent = false;//标志
        div.detachEvent("onclick", arguments.callee);
    });
    div.cloneNode(true).fireEvent("onclick");
}
</code></p>

<p>其次，解决第一个问题的方法首先想到去移除clone元素上的事件处理器，扩展属性。但是在IE中，如果这么做，原节点的也会被移除。</p>

<p>最终的解决方案：克隆元素到另一个元素，读取innerHTML，再转换成DOM节点。在IE中还是有bug，innerHTML并不一定反映元素属性的正确状态。比如input元素的name属性动态改变了，innerHTML不会显示这一点。</p>

<p><code>javascript
function clone() {
    var ret = this.map(function () {
        if (!jQuery.support.noCloneEvent &amp;&amp; !jQuery.isXMLDoc(this)) {
            var clone = this.cloneNode(true),
            container = document.createElement("div");
            container.appendChild(clone);
            return jQuery.clean([container.innerHTML])[0];
        }
        else
            return this.cloneNode(true);
    });
    var clone = ret.find("*").andSelf().each(function () {
        if (this[ expando ] !== undefined)
            this[ expando ] = null;
    });
    return ret;
}
</code></p>

<h3 id="section-45">删除元素</h3>
<p>在简单地调用removeChild之前，还要做清理工作。</p>

<p>首先，所有绑定的事件处理器要清理。其次，元素关联的外部数据要清理。
在ch13中，没有将数据直接依附在元素上，而是使用额外的数据结构存储。这样清理起来就很方便。</p>

<p>另外，子元素也要这样做。</p>

<p><code>javascript
function remove() {
    jQuery("*", this).add([this]).each(function () {//遍历子元素
        jQuery.event.remove(this);
        jQuery.removeData(this);
    });
    if (this.parentNode)
        this.parentNode.removeChild(this);
    if (typeof this.outerHTML !== "undefined")//针对IE
        this.outerHTML = "";
}
</code></p>

<p>IE中，每一个单独的从页面移除的元素不会被马上回收内存资源，直到离开页面。这样长时间运行的页面就会占用大量内存。</p>

<p>解决方法是，在IE中有一个独有的属性outerHTML，代表元素的HTML字符串。既是getter又是setter，通过设置字符串为空比调用removeChild清除的更彻底，不是全部但也有大部分了。</p>

<h3 id="section-46">文本内容</h3>

<p>textContent属性，
IE中innerText属性</p>

<p>下面的例子说明设置这两个属性后，会清除原来的元素结构，只剩下一个文本节点。
<code>javascript
&lt;div id="test"&gt;&lt;b&gt;Hello&lt;/b&gt;, I'm a ninja!&lt;/div&gt;
&lt;script type="text/javascript"&gt;
window.onload = function () {
    var b = document.getElementById("test");
    var text = b.textContent || b.innerText;
    assert(text === "Hello, I’m a ninja!",
        "Examine the text contents of an element.");
    assert(b.childNodes.length === 2,
        "An element and a text node exist.");
    if (typeof b.textContent !== "undefined") {
        b.textContent = "Some new text";
    }
    else {
        b.innerText = "Some new text";
    }
    text = b.textContent || b.innerText;
    assert(text === "Some new text", "Set a new text value.");
    assert(b.childNodes.length === 1,
        "Only one text node exists now.");
};
&lt;/script&gt;
</code></p>

<h4 id="section-47">设置文本</h4>

<p>插入文本和插入html不同在于文本需要进行转义，<code>&lt;</code>转义成<code>&amp;lt</code>。使用内置的createTextNode方法。</p>

<h4 id="section-48">获取文本</h4>
<p>想取得精确的文本值，不能通过textContent或者innerText。原因是换行符会被去掉。</p>

<p>只能手动得到每个文本节点的nodeValue
<code>javascript
function getText(elem) {
    var text = "";
    for (var i = 0; i &lt; elem.childNodes.length; i++) {
        var cur = elem.childNodes[i];
        if (cur.nodeType === 3) //文本节点
            text += cur.nodeValue;
        else if (cur.nodeType === 1) //元素节点，递归调用
            text += getText(cur);
    }
    return text;
}
</code></p>

<h2 id="ch15-css">ch15 css选择器引擎</h2>
<p>W3C Selectors API提供了querySelectorAll和querySelector方法。</p>

<p>但是类库提供的选择器比标准考虑了更多因素。比如使用缓存提高效率，扩展性更好，更好的错误报告。</p>

<p>实现CSS选择器引擎有三种方法：</p>

<ul>
  <li>使用API</li>
  <li>使用XPath，一种DOM查询语言</li>
  <li>纯DOM</li>
</ul>

<h3 id="api">API</h3>
<p>querySelectorAll返回节点列表，querySelector返回第一个匹配的节点</p>

<p>问题出现在以元素为基准的查询上，test元素内部没有<code>div &gt; b</code>，但是选择器只检查最后的部分，这是违反直觉的。
<code>javascript
&lt;div id="test"&gt;
&lt;b&gt;Hello&lt;/b&gt;, I'm a ninja!
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
window.onload = function () {
    var b = document.getElementById("test").querySelector("div b");
    assert(b, "Only the last part of the selector matters.");
};
&lt;/script&gt;
</code></p>

<p>解决方法是临时分配一个id给根元素。查完后再恢复。
之所以使用try/catch块是因为API可能抛出异常。
<code>javascript
(function() {
    var count = 1;
    this.rootedQuerySelectorAll = function (elem, query) {
        var oldID = elem.id;
        elem.id = "rooted" + (count++);
        try {
            return elem.querySelectorAll("#" + elem.id + " " + query);
        }
        catch (e) {
            throw e;
        }
        finally {
            elem.id = oldID;
        }
    };
})();
</code></p>

<h3 id="xpath">使用XPath查找</h3>

<p>复杂表达式的表现XPath更好。</p>

<p>Prototype类库中
<code>
if (typeof document.evaluate === "function") {
    function getElementsByXPath(expression, parentElement) {
        var results = [];
        var query = document.evaluate(expression,
            parentElement || document,
            null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
        for (var i = 0, length = query.snapshotLength; i &lt; length; i++)
            results.push(query.snapshotItem(i));
        return results;
    }
}
</code></p>

<h3 id="dom-1">纯DOM实现</h3>
<p>getElementById/TagName，HTML5中增加ClassName</p>

<ul>
  <li>IE89支持API，但是67不支持XPath和API</li>
  <li>向后兼容性</li>
  <li>有些查询例如ID，纯DOM实现更快</li>
  <li>CSS3选择器浏览器支持各不相同</li>
</ul>

<p>两种可能的选择器实现：自顶向下，自底向上</p>

<p>考虑的因素：结果按照文档中定义的顺序。不能返回重复的元素。</p>

<p>自顶向下：类似这样的选择<code>div.ninja a span</code></p>

<p>一个简单的实现：按tag查找，问题是有可能返回重复的元素。
<code>javascript
function find(selector, root){
    root = root || document;
    var parts = selector.split(" "),
        query = parts[0],
        rest = parts.slice(1).join(" "),
        elems = root.getElementsByTagName(query),
        results = [];
    for (var i = 0; i &lt; elems.length; i++) {
        if (rest) {
            results = results.concat(find(rest, elems[i]));//递归查找
        }
        else {
            results.push(elems[i]);
        }
    }
    return results;
};
</code></p>

<h4 id="section-49">解析选择符</h4>
<p>上面的简单例子按照空格分割tag，但是很多选择中包含额外的空格，例如按照属性或者值查询。</p>

<p>注意非捕获组中的三种情况()，[]和非空格，逗号，大小括号。第三种情况将空格剔除。
<code>javascript
var selector = "div.class &gt; span:not(:first-child) a[href]";
var chunker = /((?:\([^\)]+\)|\[[^\]]+\]|[^ ,\(\[]+)+)(\s*,\s*)?/g;
var parts = [];
chunker.lastIndex = 0;//下一次匹配的开始位置
while ((m = chunker.exec(selector)) !== null) {
    parts.push(m[1]);
    if (m[2]) {//如果有逗号，停止匹配
        extra = RegExp.rightContext;//最后一个匹配后面的字符串
        break;
    }
}
assert(parts.length == 4, "Our selector is broken into 4 unique parts.");
assert(parts[0] === "div.class", "div selector");
assert(parts[1] === "&gt;", "child selector");
assert(parts[2] === "span:not(:first-child)", "span selector");
assert(parts[3] === "a[href]", "a selector");
</code></p>

<h4 id="section-50">查找元素</h4>

<p>getElementById用于ID选择器，IE和Opera会查出name值相同的元素。</p>

<p>getElementsByTagName还有另一个作用，tag为*能够查出文档/元素内部的所有元素。在属性选择器并没有提供tag的情况下，例如<code>.class</code>或者<code>[attr]</code></p>

<p>getElementsByName适用于<code>[name=name]</code></p>

<p>getElementsByClassName是HTML5的新方法，加速查询。</p>

<h4 id="section-51">过滤结果集</h4>

<p>属性过滤：getAttribute()，类过滤也是其中一种，访问className属性。</p>

<p>位置过滤：<code>:nth-child(even)</code>或者<code>:last-child,</code>，使用children和childNodes这两个方法</p>

<h4 id="section-52">递归和合并</h4>

<p>之前简单例子中，结果集没有去重。采用遍历元素分配临时的标志，来判断是否之前遇到过。</p>

<p><code>javascript
(function(){
    var run = 0;
    this.unique = function(array) {
        var ret = [];
        run++;
        for (var i = 0, length = array.length; i &lt; length; i++) {
            var elem = array[i];
            if (elem.uniqueID !== run) {
                elem.uniqueID = run;
                ret.push(array[i]);
            }
        }
        return ret;
    };
})();
</code>
### 自底向上的实现</p>

<p>先找到所有符合最后一个表达式的子节点，再向上找父节点。成本高。
优点是不会出现重复。</p>

<p>简单的例子
<code>javascript
function find(selector, root){
    root = root || document;
    var parts = selector.split(" "),
        query = parts[parts.length - 1],
        rest = parts.slice(0,-1).join(""),
        elems = root.getElementsByTagName(query),
        results = [];
    for (var i = 0; i &lt; elems.length; i++) {
        if (rest) {
            var parent = elems[i].parentNode;
            while (parent &amp;&amp; parent.nodeName != rest) {
                parent = parent.parentNode;
            }
            if (parent) {
                results.push(elems[i]);
            }
        } else {
            results.push(elems[i]);
        }
    }
    return results;
};
</code></p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">xiaOp写东西的地方</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>xiaOp写东西的地方</li>
          <li><a href="mailto:pyqiverson@gmail.com">pyqiverson@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/xiaoiver">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">xiaoiver</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/jekyllrb">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">jekyllrb</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">读书笔记，碰到的问题
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
