<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>《Async Javascript》读书笔记</title>
    <meta name="description" content="读书笔记，碰到的问题
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://yourdomain.com/js/async/yepnope/require/2014/10/11/async-javascript-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">xiaOp写东西的地方</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">关于xiaOp</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">《Async Javascript》读书笔记</h1>
    <p class="post-meta">Oct 11, 2014</p>
  </header>

  <article class="post-content">
    <h1 id="ch1-js">ch1 理解js中的事件</h1>

<h2 id="section">调度事件</h2>

<h3 id="section-1">立即执行？</h3>

<p>关于setTimeout的描述不完全正确</p>

<blockquote>
  <p>Given a callback and a delay of n milliseconds, setTimeout runs that 
callback n milliseconds later.</p>
</blockquote>

<p>下面的代码会输出3个4，而不是1,2,3</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">};</span></code></pre></div>

<p>需要了解3件事</p>

<ul>
  <li>循环结束时，i的值是4</li>
  <li>闭包维持对变量i的引用</li>
  <li>js中 event handlers don’t run until the thread is free</li>
</ul>

<h3 id="section-2">阻塞线程</h3>

<p>并不会在500ms后就调用定时器回调函数进行输出，至少要1000ms，也就是在while循环结束后才会触发回调。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">;</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
	<span class="kd">var</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Time elapsed:&#39;</span><span class="p">,</span> <span class="nx">end</span> <span class="o">-</span> <span class="nx">start</span><span class="p">,</span> <span class="s1">&#39;ms&#39;</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">500</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Date</span> <span class="o">-</span> <span class="nx">start</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{};</span></code></pre></div>

<p>setTimeout并没有使用另一个线程</p>

<h3 id="section-3">队列</h3>

<p>调用setTimeout时，timeout事件进入队列，接着setTimeout下面的代码执行，最后js虚拟机才会到队列中找，调用事件回调函数，此时距离当初定时器设定的时间已经过去很久了。</p>

<h2 id="section-4">异步函数的类型</h2>

<h3 id="io">I/O函数</h3>

<p>Node.js并不是想让服务端也能运行js才创造的。作者只是想找支持事件驱动服务器的高级语言，js由于十分适合非阻塞I/O，正好支持。</p>

<p>在其他语言中，使用循环能阻塞程序直到某个I/O请求完成。但是在js中不可能。下面的循环会一直运行。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">ajaxRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">;</span>
	<span class="nx">ajaxRequest</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
	<span class="nx">ajaxRequest</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="nx">ajaxRequest</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="nx">XMLHttpRequest</span><span class="p">.</span><span class="nx">UNSENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// readyState can&#39;t change until the loop returns</span>
	<span class="p">};</span></code></pre></div>

<p>在js中，需要绑定回调函数实现，让事件队列执行回调。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">ajaxRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">;</span>
	<span class="nx">ajaxRequest</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nx">url</span><span class="p">);</span>
	<span class="nx">ajaxRequest</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
	<span class="nx">ajaxRequest</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// ...</span>
	<span class="p">};</span></code></pre></div>

<p>浏览器ajax方法提供async选项，值为false时代表同步，浏览器会不响应直到接收到服务端的响应。Node.js中同步API从方法名就能看出来，如<code>fs.readFileSync</code>。</p>

<p><code>console.log</code>在Chrome和Safari中是异步执行的，会输出<code>{foo:bar}</code>。原因是WebKit的日志方法会存储对象的引用，在代码返回到事件队列时再输出。
而在Node.js中，是严格同步的，所以输出是<code>{}</code>。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
	<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span></code></pre></div>

<h3 id="section-5">时间函数</h3>

<p>测试一秒钟能触发多少次定时器事件。FF,Chrome和Safari下大概是200/s，Node.js下1000/s。换成简单的while循环后，提高到4000000/s，Node.js中更高一些。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">fireCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Date</span> <span class="o">-</span> <span class="nx">start</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">clearInterval</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fireCount</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nx">fireCount</span><span class="o">++</span><span class="p">;</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span></code></pre></div>

<p>setInterval设置间隔为0比while循环慢很多，因为HTML规范中浏览器timeout/interval最小间隔是4ms。</p>

<p>想要更小的间隔有其他选择</p>

<ul>
  <li>Node.js中<code>process.nextTick</code>，超过100000/s</li>
  <li>现代浏览器包括ie9以上可以使用<code>requestAnimationFrame</code>方法，动画60帧每秒</li>
</ul>

<h2 id="section-6">异步函数编写</h2>

<h3 id="section-7">什么时候函数是异步的</h3>

<p>测试异步函数</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">functionHasReturned</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="nx">asyncFunction</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span><span class="nx">functionHasReturned</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">functionHasReturned</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span></code></pre></div>

<h3 id="section-8">有时是异步的函数</h3>

<p>一个错误的认识：jQuery中$传入的方法会在页面加载完毕后运行。</p>

<p>大多数情况下下面的代码都能正常运行。除非浏览器从缓存中加载页面，此时DOM在脚本运行之前就加载完毕，调用还未被设置的utils方法就会出错。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// application.js</span>
<span class="nx">$</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">utils</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Ready&#39;</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// utils.js</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">utils</span> <span class="o">=</span> <span class="p">{</span>
	<span class="nx">log</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">console</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">console</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;application.js&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span>
<span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;util.js&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span></code></pre></div>

<h3 id="cache">使用cache的异步函数</h3>

<p><a href="http://webworkersandbox.com/5009efc12245588e410002cf">例子</a></p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">calculationCache</span> <span class="o">=</span> <span class="p">{},</span>
	<span class="nx">calculationCallbacks</span> <span class="o">=</span> <span class="p">{},</span>
	<span class="nx">mathWorker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">(</span><span class="s1">&#39;calculator.js&#39;</span><span class="p">);</span>
	
<span class="nx">mathWorker</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
	<span class="nx">calculationCache</span><span class="p">[</span><span class="nx">message</span><span class="p">.</span><span class="nx">formula</span><span class="p">]</span> <span class="o">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
	<span class="nx">calculationCallbacks</span><span class="p">[</span><span class="nx">message</span><span class="p">.</span><span class="nx">formula</span><span class="p">](</span><span class="nx">message</span><span class="p">.</span><span class="nx">result</span><span class="p">);</span>
<span class="p">});</span>

<span class="kd">function</span> <span class="nx">runCalculation</span><span class="p">(</span><span class="nx">formula</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">formula</span> <span class="k">in</span> <span class="nx">calculationCache</span><span class="p">)</span> <span class="p">{</span><span class="c1">//同步状态，结果已经被放入了cache中</span>
		<span class="k">return</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">calculationCache</span><span class="p">[</span><span class="nx">formula</span><span class="p">]);</span>
	<span class="p">};</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">formula</span> <span class="k">in</span> <span class="nx">calculationCallbacks</span><span class="p">)</span> <span class="p">{</span><span class="c1">//结果还未发回，调用自己</span>
		<span class="k">return</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">runCalculation</span><span class="p">(</span><span class="nx">formula</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
		<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">};</span>
	<span class="nx">mathWorker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="nx">formula</span><span class="p">);</span><span class="c1">//公式还未分发给worker,触发事件</span>
	<span class="nx">calculationCallbacks</span><span class="p">[</span><span class="nx">formula</span><span class="p">]</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-9">异步递归和存储回调函数</h3>

<p>上面的runCalculation采用了异步递归和简单存储回调函数。</p>

<p>在java中轮询：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">while</span> <span class="o">(!</span><span class="n">calculationCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">formula</span><span class="o">))</span> <span class="o">{</span>
	<span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="o">};</span></code></pre></div>

<p>看起来异步递归更易用，但是js中使用setTimeout的异步递归调用并不好，在等待时触发的timeout事件是没有数量限制的，而且会使程序的事件结构变得不必要地复杂。所以异步递归是反模式。</p>

<p>使用存储回调函数来避免异步递归</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">mathWorker</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
		<span class="nx">calculationCache</span><span class="p">[</span><span class="nx">message</span><span class="p">.</span><span class="nx">formula</span><span class="p">]</span> <span class="o">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
		<span class="nx">calculationCallbacks</span><span class="p">[</span><span class="nx">message</span><span class="p">.</span><span class="nx">formula</span><span class="p">]</span>
			<span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span><span class="c1">//统一处理之前未得到结果前压入的函数</span>
			<span class="nx">callback</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">result</span><span class="p">);</span>
		<span class="p">});</span>
<span class="p">});</span>
<span class="kd">function</span> <span class="nx">runCalculation</span><span class="p">(</span><span class="nx">formula</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">formula</span> <span class="k">in</span> <span class="nx">calculationCache</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">calculationCache</span><span class="p">[</span><span class="nx">formula</span><span class="p">]);</span><span class="c1">//已经有结果，直接调用回调函数</span>
	<span class="p">};</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">formula</span> <span class="k">in</span> <span class="nx">calculationCallbacks</span><span class="p">)</span> <span class="p">{</span><span class="c1">//将回调函数压栈</span>
		<span class="k">return</span> <span class="nx">calculationCallbacks</span><span class="p">[</span><span class="nx">formula</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
	<span class="p">};</span>
	<span class="nx">mathWorker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="nx">formula</span><span class="p">);</span>
	<span class="nx">calculationCallbacks</span><span class="p">[</span><span class="nx">formula</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">callback</span><span class="p">];</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-10">返回值和回调函数混合</h3>

<p><code>return callback(calculationCache[formula]);</code>由于返回值没有使用，
可以简单地写成</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">callback</span><span class="p">(</span><span class="nx">calculationCache</span><span class="p">[</span><span class="nx">formula</span><span class="p">]);</span>
	<span class="k">return</span><span class="p">;</span></code></pre></div>

<p>但是有些函数的返回值会被回调函数使用。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">webSocketCache</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">function</span> <span class="nx">openWebSocket</span><span class="p">(</span><span class="nx">serverAddress</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">socket</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">serverAddress</span> <span class="k">in</span> <span class="nx">webSocketCache</span><span class="p">)</span> <span class="p">{</span><span class="c1">//查看缓存</span>
		<span class="nx">socket</span> <span class="o">=</span> <span class="nx">webSocketCache</span><span class="p">[</span><span class="nx">serverAddress</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">socket</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="nx">WebSocket</span><span class="p">.</span><span class="nx">OPEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">callback</span><span class="p">();</span><span class="c1">//这里有问题</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">//使用了Underscore.js，将两个函数包裹成一个新函数</span>
			<span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span><span class="p">);</span>
		<span class="p">};</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="nx">serverAddress</span><span class="p">);</span>
		<span class="nx">webSocketCache</span><span class="p">[</span><span class="nx">serverAddress</span><span class="p">]</span> <span class="o">=</span> <span class="nx">socket</span><span class="p">;</span>
		<span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="nx">socket</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>代码的问题在于，如果socket已经被缓存并且是打开的，callback会在openWebSocket函数返回之前运行。而callback函数中使用了返回值socket，就会出错。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">socket</span> <span class="o">=</span> <span class="nx">openWebSocket</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">socket</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Hello, server!&#39;</span><span class="p">);</span>
<span class="p">});</span></code></pre></div>

<p>解决办法是使用setTimeout，保证在函数返回后才执行回调函数。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">if</span> <span class="p">(</span><span class="nx">socket</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="nx">WebSocket</span><span class="p">.</span><span class="nx">OPEN</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-11">处理异步错误</h3>

<p>从一个异步回调函数中抛出异常</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">B</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">C</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Something terrible has happened!&#39;</span><span class="p">);</span>
		<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span></code></pre></div>

<p>stack trace中只有C：<code>Error: Something terrible has happened! at Timer.C (/AsyncJS/nestedErrors.js:4:13)</code>。在C运行时，A和B都不在stack中，这三个函数都是直接从事件队列中运行的。</p>

<p>所以外部的try/catch捕获不了异步回调函数抛出的异常：</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">try</span> <span class="p">{</span>
	<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Catch me if you can!&#39;</span><span class="p">);</span>
	<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>所以Node.js中回调函数会err作为参数，让函数内部决定如何处理。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
	<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;fhgwgdz.txt&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
		<span class="p">};</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">));</span>
	<span class="p">});</span></code></pre></div>

<p>客户端脚本如jquery使用两个回调函数（success/failure）</p>

<h3 id="section-12">处理未捕获的异常</h3>

<p>当回调函数抛出异常时，应该由调用者来捕获。但如果异常从未被捕获，不同的js环境有不同的规则。</p>

<p>在浏览器中，将未捕获的异常显示在控制台中，然后返回事件队列。可以为window.onerror添加处理函数改变浏览器行为。返回true会阻止浏览器默认的错误处理行为。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">window</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
	<span class="p">};</span></code></pre></div>

<p>在Node.js中，process对象有类似的uncaughtException事件。
通常遇到未捕获的异常，程序会立即退出。但只要至少存在一个uncaughtException处理器，app就会返回事件队列。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;uncaughtException&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span> <span class="c1">// shutdown averted!</span>
<span class="p">});</span></code></pre></div>

<p>但是从0.8.4版本，就被废弃了。推荐使用domain模块。domain会将异常转化成error事件，然后在error事件处理器中进行处理。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">myDomain</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;domain&#39;</span><span class="p">).</span><span class="nx">create</span><span class="p">();</span>
	<span class="nx">myDomain</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Listen to me!&#39;</span><span class="p">)</span>
		<span class="p">},</span> <span class="mi">50</span><span class="p">);</span>
	<span class="p">});</span>
	<span class="nx">myDomain</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Error ignored!&#39;</span><span class="p">);</span><span class="c1">//简单的记录</span>
	<span class="p">});</span></code></pre></div>

<h3 id="section-13">是否抛出异常</h3>

<p>Isaac Schlueter认为try/catch是反模式，不推荐使用。
把try当作类似assert的结构使用，在出现重大问题时将程序终止。</p>

<h2 id="section-14">嵌套的回调函数</h2>

<p>常见的反模式，回调函数里嵌套回调函数。目前看来没问题，但是需要扩展时，如处理数据库错误，添加日志等，就会变得很糟。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">checkPassword</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">passwordGuess</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">queryStr</span> <span class="o">=</span> <span class="s1">&#39;SELECT * FROM user WHERE username = ?&#39;</span><span class="p">;</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">query</span><span class="p">(</span><span class="nx">selectUser</span><span class="p">,</span> <span class="nx">username</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
		<span class="nx">hash</span><span class="p">(</span><span class="nx">passwordGuess</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">passwordGuessHash</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">callback</span><span class="p">(</span><span class="nx">passwordGuessHash</span> <span class="o">===</span> <span class="nx">result</span><span class="p">[</span><span class="s1">&#39;password_hash&#39;</span><span class="p">]);</span>
		<span class="p">});</span>
	<span class="p">});</span>
<span class="p">}</span></code></pre></div>

<p>下面的写法代码行变多了但是更清晰。将passwordHash拿到外面。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">checkPassword</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">passwordGuess</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">passwordHash</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">queryStr</span> <span class="o">=</span> <span class="s1">&#39;SELECT * FROM user WHERE username = ?&#39;</span><span class="p">;</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">query</span><span class="p">(</span><span class="nx">selectUser</span><span class="p">,</span> <span class="nx">username</span><span class="p">,</span> <span class="nx">queryCallback</span><span class="p">);</span>
	<span class="kd">function</span> <span class="nx">queryCallback</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
		<span class="nx">passwordHash</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="s1">&#39;password_hash&#39;</span><span class="p">];</span>
		<span class="nx">hash</span><span class="p">(</span><span class="nx">passwordGuess</span><span class="p">,</span> <span class="nx">hashCallback</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="kd">function</span> <span class="nx">hashCallback</span><span class="p">(</span><span class="nx">passwordGuessHash</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">callback</span><span class="p">(</span><span class="nx">passwordHash</span> <span class="o">===</span> <span class="nx">passwordGuessHash</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<h1 id="ch2-">ch2 事件</h1>

<p>一个事件由多个处理器处理。发布/订阅模式很适合。</p>

<h2 id="pubsub">Pub/Sub模式</h2>

<p>早期的js，浏览器允许事件处理器依附在DOM上，缺点是只能合并成一个函数。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">link</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">clickHandler1</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
	<span class="nx">clickHandler2</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
<span class="p">};</span></code></pre></div>

<p>W3C在DOM标准中增加了addEventListener，jquery实现了bind。</p>

<h3 id="eventemitter">EventEmitter</h3>

<p>on进行订阅，emit进行发布通知。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">emitter</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;evacuate&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">emitter</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;evacuate&#39;</span><span class="p">,</span><span class="s1">&#39;args&#39;</span><span class="p">);</span><span class="c1">//可以传递参数</span></code></pre></div>

<h3 id="section-15">简单的实现</h3>

<p>EventEmitter中的实现</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">PubSub</span> <span class="o">=</span> <span class="p">{</span><span class="nx">handlers</span><span class="o">:</span> <span class="p">{}}</span>
<span class="nx">PubSub</span><span class="p">.</span><span class="nx">on</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">eventType</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">eventType</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="nx">handlers</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">eventType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span><span class="c1">//每个事件都有处理器数组</span>
	<span class="p">}</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">eventType</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">handler</span><span class="p">);</span>
	<span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">PubSub</span><span class="p">.</span><span class="nx">emit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">eventType</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">handlerArgs</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//截取参数</span>
	<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">eventType</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">eventType</span><span class="p">][</span><span class="nx">i</span><span class="p">].</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">handlerArgs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-16">同步</h3>

<p>会输出foo bar。也就是trigger会立即触发回调函数，然后后面的代码才能执行。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;input[type=submit]&#39;</span><span class="p">)</span>
	<span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span> <span class="p">})</span>
	<span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span></code></pre></div>

<p>如果太多处理器按顺序触发，可能会阻塞线程导致浏览器未响应。更糟糕的情况是当事件从处理器中触发时，会导致死循环。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;input[type=submit]&#39;</span><span class="p">)</span>
	<span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">);</span> <span class="c1">// stack overflow!</span>
	<span class="p">});</span></code></pre></div>

<p>对于许多处理器需要按顺序执行，并且有些处理器很耗时的情况，解决方法是维持一个队列，使用定时器按顺序调用。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">tasks</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">nextTask</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">nextTask</span> <span class="o">=</span> <span class="nx">tasks</span><span class="p">.</span><span class="nx">shift</span><span class="p">())</span> <span class="p">{</span>
		<span class="nx">nextTask</span><span class="p">();</span>
	<span class="p">};</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span></code></pre></div>

<h2 id="evented-model-">Evented Model 可以发布事件的模型</h2>

<p>当一个对象拥有Pub/Sub接口，就称作evented object。
特别的，这个对象存储了数据，成为了model，还能在数据改变时发布事件。</p>

<p>在Backbone.js中，可以创建一个model。
和js中对象的区别是，model可以在发生改变时发布通知。使用set方法触发改变。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">style</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">(</span>
	<span class="p">{</span><span class="nx">font</span><span class="o">:</span> <span class="s1">&#39;Georgia&#39;</span><span class="p">}</span>
<span class="p">);</span>
<span class="nx">style</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;change:font&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">font</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;Thank you for choosing &#39;</span> <span class="o">+</span> <span class="nx">font</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span><span class="p">);</span>
<span class="p">});</span></code></pre></div>

<p>js中普遍的做法是通过input事件处理器直接改变DOM。而新的做法是对model进行改变，然后通过model发射事件使DOM更新。新的做法更优雅。</p>

<h2 id="jquery">jquery中自定义事件</h2>

<p>js中event会被父节点冒泡emit，一直到document根节点，除非调用了event的stopPropagation方法（jquery中只要handler中返回false会自动调用该方法）。jquery中自定义事件也会冒泡。
如果soda是bottle的子节点，会冒泡到父节点。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#soda, #bottle&#39;</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;fizz&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">+</span> <span class="s1">&#39; emitted fizz&#39;</span><span class="p">);</span>
	<span class="p">});</span>
	<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#soda&#39;</span><span class="p">).</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;fizz&#39;</span><span class="p">);</span></code></pre></div>

<p>有时不需要冒泡，jquery中提供不冒泡的<a href="http://api.jquery.com/triggerHandler/">triggerHandler</a>方法。</p>

<h3 id="section-17">工具提示的例子</h3>

<p>问题：容器中一次只显示一个工具提示，需要在每次添加新提示前移除旧的。
<code>$('.tooltip').remove();</code>并且容器之间互不影响，还要支持容器的嵌套。</p>

<p>使用选择器会很麻烦，采用事件的思想。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$container</span><span class="p">.</span><span class="nx">triggerHandler</span><span class="p">(</span><span class="s1">&#39;newTooltip&#39;</span><span class="p">);</span><span class="c1">//不会冒泡到父节点</span>
<span class="nx">$container</span><span class="p">.</span><span class="nx">one</span><span class="p">(</span><span class="s1">&#39;newTooltip&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="c1">//触发后移除处理器</span>
	<span class="nx">$tooltip</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
<span class="p">});</span></code></pre></div>

<h1 id="ch3-promisedeferred">ch3 Promise和Deferred</h1>

<p>jquery1.4中ajax请求需要包含成功/失败/总是执行的处理器。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/mydata&#39;</span><span class="p">,</span> <span class="p">{</span>
	<span class="nx">success</span><span class="o">:</span> <span class="nx">onSuccess</span><span class="p">,</span>
	<span class="nx">failure</span><span class="o">:</span> <span class="nx">onFailure</span><span class="p">,</span>
	<span class="nx">always</span><span class="o">:</span> <span class="nx">onAlways</span>
<span class="p">});</span></code></pre></div>

<p>1.5中分离开，返回封装的Promise对象。一个明显的好处是可以对同一个事件绑定多个处理器，拆分功能。例如显示隐藏loading图片的代码就可以被多个ajax调用共用。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/mydata&#39;</span><span class="p">);</span>
	<span class="nx">promise</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="nx">onSuccess</span><span class="p">);</span>
	<span class="nx">promise</span><span class="p">.</span><span class="nx">fail</span><span class="p">(</span><span class="nx">onFailure</span><span class="p">);</span>
	<span class="nx">promise</span><span class="p">.</span><span class="nx">always</span><span class="p">(</span><span class="nx">onAlways</span><span class="p">);</span></code></pre></div>

<p>最大的优点是可以从已有的Promise中获取新的Promise。两个并行的Promise返回代表共同进度的Promise.</p>

<h2 id="deferred">Deferred</h2>

<p>Deferred是Promise的超集，可以被直接触发。而Promise需要其他人来触发。
另外，回调函数的运行顺序和绑定顺序一致。always最先绑定，所以最先触发。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">promptDeferred</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
	<span class="c1">//1.6以上版本支持always</span>
	<span class="nx">promptDeferred</span><span class="p">.</span><span class="nx">always</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;A choice was made:&#39;</span><span class="p">);</span> <span class="p">});</span>
	<span class="nx">promptDeferred</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Starting game...&#39;</span><span class="p">);</span> <span class="p">});</span>
	<span class="nx">promptDeferred</span><span class="p">.</span><span class="nx">fail</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;No game today.&#39;</span><span class="p">);</span> <span class="p">});</span></code></pre></div>

<p>通过resolve和reject触发Deferred。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#playGame&#39;</span><span class="p">).</span><span class="nx">focus</span><span class="p">().</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;keypress&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">Y</span> <span class="o">=</span> <span class="mi">121</span><span class="p">,</span> <span class="nx">N</span> <span class="o">=</span> <span class="mi">110</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">keyCode</span> <span class="o">===</span> <span class="nx">Y</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">promptDeferred</span><span class="p">.</span><span class="nx">resolve</span><span class="p">();</span><span class="c1">//只会被调用一次</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">keyCode</span> <span class="o">===</span> <span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">promptDeferred</span><span class="p">.</span><span class="nx">reject</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// our Deferred remains pending</span>
	<span class="p">};</span>
<span class="p">});</span></code></pre></div>

<p>Promise只能被解决或者拒绝一次，在此之前处于pending等待状态。
1.7版本以上调用state方法查看状态，老版本使用isResovled和isRejected查看。</p>

<h2 id="promise">Promise</h2>

<p>调用Deferred的promise方法得到一个Promise。多次调用会返回同一个Promise。在Promise上继续调用这个方法还是返回同一个对象的引用。</p>

<p>Promise只是Deferred缺少resolve/reject方法的拷贝。内部共享同样的回调函数，所以绑定在Deferred或者生成的Promise上都一样。
<code>var promptPromise = promptDeferred.promise();</code></p>

<p>使用Promise的唯一理由是封装。保留Deferred只传递Promise可以保证控制回调函数的触发。</p>

<h3 id="jquerypromise">jquery中的Promise</h3>

<p>动画方法允许传递回调函数，在效果完成后调用。
<code>$('.error').fadeIn(afterErrorShown);</code></p>

<p>1.6之后</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">errorPromise</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;.error&#39;</span><span class="p">).</span><span class="nx">fadeIn</span><span class="p">().</span><span class="nx">promise</span><span class="p">();</span>
	<span class="nx">errorPromise</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="nx">afterErrorShown</span><span class="p">);</span></code></pre></div>

<p>jquery 1.8+ 以下等价</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="nx">onReady</span><span class="p">);</span>
	<span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ready</span><span class="p">(</span><span class="nx">onReady</span><span class="p">);</span>
	<span class="nx">$</span><span class="p">.</span><span class="nx">ready</span><span class="p">.</span><span class="nx">promise</span><span class="p">().</span><span class="nx">done</span><span class="p">(</span><span class="nx">onReady</span><span class="p">);</span></code></pre></div>

<h2 id="section-18">传递数据到回调函数</h2>

<p>通过resolve/reject传递参数到回调函数</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">aDreamDeferred</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
	<span class="nx">aDreamDeferred</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">subject</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;I had the most wonderful dream about&#39;</span><span class="p">,</span> <span class="nx">subject</span><span class="p">);</span>
	<span class="p">});</span>
	<span class="nx">aDreamDeferred</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;the JS event model&#39;</span><span class="p">);</span></code></pre></div>

<p>resolveWith/rejectWith用于传递上下文作为第一个参数，后面是参数数组</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">slashdotter</span> <span class="o">=</span> <span class="p">{</span>
		<span class="nx">comment</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">editor</span><span class="p">){</span>
			<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Obviously&#39;</span><span class="p">,</span> <span class="nx">editor</span><span class="p">,</span> <span class="s1">&#39;is the best text editor.&#39;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">};</span>
	<span class="kd">var</span> <span class="nx">grammarDeferred</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
	<span class="nx">grammarDeferred</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">verb</span><span class="p">,</span> <span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="p">[</span><span class="nx">verb</span><span class="p">](</span><span class="nx">object</span><span class="p">);</span>
	<span class="p">});</span>
	<span class="nx">grammarDeferred</span><span class="p">.</span><span class="nx">resolveWith</span><span class="p">(</span><span class="nx">slashdotter</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">,</span> <span class="s1">&#39;Emacs&#39;</span><span class="p">]);</span></code></pre></div>

<p>但想传递上下文使用call/apply就行了，因为resolve/reject会传递上下文到回调函数中</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">grammarDeferred</span><span class="p">.</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">slashdotter</span><span class="p">,</span> <span class="s1">&#39;comment&#39;</span><span class="p">,</span> <span class="s1">&#39;Emacs&#39;</span><span class="p">);</span></code></pre></div>

<h2 id="section-19">进度通知</h2>

<p>不同于resolve/reject，progress方法可以被多次调用。
notify可以传递参数到progress回调函数中。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">nanowrimoing</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
	<span class="kd">var</span> <span class="nx">wordGoal</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
	<span class="nx">nanowrimoing</span><span class="p">.</span><span class="nx">progress</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">wordCount</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">percentComplete</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">wordCount</span> <span class="o">/</span> <span class="nx">wordGoal</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
		<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#indicator&#39;</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="nx">percentComplete</span> <span class="o">+</span> <span class="s1">&#39;% complete&#39;</span><span class="p">);</span>
	<span class="p">});</span>
	<span class="nx">nanowrimoing</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
		<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#indicator&#39;</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="s1">&#39;Good job!&#39;</span><span class="p">);</span>
	<span class="p">});</span>
	<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#document&#39;</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;keypress&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
		<span class="kd">var</span> <span class="nx">wordCount</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">val</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="sr">/\s+/</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">wordCount</span> <span class="o">&gt;=</span> <span class="nx">wordGoal</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">nanowrimoing</span><span class="p">.</span><span class="nx">resolve</span><span class="p">();</span>
		<span class="p">};</span>
		<span class="nx">nanowrimoing</span><span class="p">.</span><span class="nx">notify</span><span class="p">(</span><span class="nx">wordCount</span><span class="p">);</span><span class="c1">//触发progress回调函数</span>
	<span class="p">});</span></code></pre></div>

<h2 id="promise-1">合并Promise</h2>

<p>多个Promise可以使用when合并成一个任务集合，这样就把异步任务抽象成了布尔值，有and关系。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">gameReadying</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="nx">tutorialPromise</span><span class="p">,</span> <span class="nx">gameLoadedPromise</span><span class="p">);</span>
	<span class="nx">gameReadying</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="nx">startGame</span><span class="p">);</span></code></pre></div>

<p>常用的场景，组合多个ajax请求，在都成功后得到通知。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/1&#39;</span><span class="p">,</span> <span class="nx">data1</span><span class="p">),</span> <span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/2&#39;</span><span class="p">,</span> <span class="nx">data2</span><span class="p">))</span>
	<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">onPosted</span><span class="p">,</span> <span class="nx">onFailure</span><span class="p">);</span></code></pre></div>

<p>使用一个全局的数据容器，如Array，存放多个Promise想合并的数据。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">serverData</span> <span class="o">=</span> <span class="p">{};</span>
	<span class="kd">var</span> <span class="nx">getting1</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/1&#39;</span><span class="p">)</span>
		<span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span><span class="nx">serverData</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;});</span>
	<span class="kd">var</span> <span class="nx">getting2</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/2&#39;</span><span class="p">)</span>
		<span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span><span class="nx">serverData</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;});</span>
	<span class="nx">$</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="nx">getting1</span><span class="p">,</span> <span class="nx">getting2</span><span class="p">)</span>
		<span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// the GET information is now in serverData...</span>
		<span class="p">});</span></code></pre></div>

<h2 id="pipe">使用pipe绑定</h2>

<p>只有在GET操作完成后才能对postPromise绑定回调函数，之前还不存在。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">getPromise</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/query&#39;</span><span class="p">);</span>
	<span class="nx">getPromise</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">postPromise</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/search&#39;</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
	<span class="p">});</span></code></pre></div>

<p>1.6之后增加pipe方法。如果返回一个Promise。如果返回一个非Promise甚至没有返回值，</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">getPromise</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/query&#39;</span><span class="p">);</span>
	<span class="kd">var</span> <span class="nx">postPromise</span> <span class="o">=</span> <span class="nx">getPromise</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/search&#39;</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
	<span class="p">});</span></code></pre></div>

<h2 id="promise-2">使用Promise替换回调函数</h2>

<p>在Node.js中使用jquery<code>npm install jquery</code></p>

<p>大多js框架使用callback而非promise，改写Node.js回调函数风格代码：</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">fileReading</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fileReading</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fileReading</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">};</span>
<span class="p">});</span></code></pre></div>

<p>改写成通用的工具方法</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">deferredCallback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">deferred</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">deferred</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">deferred</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
			<span class="p">};</span>
		<span class="p">};</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">fileReading</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">$</span><span class="p">.</span><span class="nx">Deferred</span><span class="p">();</span>
	<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="nx">deferredCallback</span><span class="p">(</span><span class="nx">fileReading</span><span class="p">));</span></code></pre></div>

<p>Q.js中node方法直接使用。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">fileReading</span> <span class="o">=</span> <span class="nx">Q</span><span class="p">.</span><span class="nx">defer</span><span class="p">();</span>
	<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="nx">fileReading</span><span class="p">.</span><span class="nx">node</span><span class="p">());</span></code></pre></div>

<h1 id="ch4-asyncjs">ch4 使用Async.js控制流程</h1>

<p>迭代中保持顺序的问题。</p>

<p>安装async和step<code>npm install -g async step</code></p>

<p><a href="https://github.com/kriskowal/es5-shim/">es5-shim</a></p>

<h2 id="section-20">异步顺序问题</h2>

<p>问题：按字典序读取文件夹下所有文件，然后拼接内容。</p>

<p>使用同步方法：</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
	<span class="nx">process</span><span class="p">.</span><span class="nx">chdir</span><span class="p">(</span><span class="s1">&#39;recipes&#39;</span><span class="p">);</span><span class="c1">//切换目录</span>
	<span class="kd">var</span> <span class="nx">concatenation</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
	<span class="nx">fs</span><span class="p">.</span><span class="nx">readdirSync</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
		<span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span> <span class="p">{</span><span class="c1">//忽略目录</span>
			<span class="k">return</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">statSync</span><span class="p">(</span><span class="nx">filename</span><span class="p">).</span><span class="nx">isFile</span><span class="p">();</span>
		<span class="p">})</span>
		<span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span> <span class="p">{</span><span class="c1">//forEach至少需要IE6+</span>
			<span class="nx">concatenation</span> <span class="o">+=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">);</span>
		<span class="p">});</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">concatenation</span><span class="p">);</span></code></pre></div>

<p>不能替换成异步版本。原因是拼接任务放在回调函数中，短文件会比长文件先读完，拼接的顺序不可预测。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
		<span class="nx">concatenation</span> <span class="o">+=</span> <span class="nx">contents</span><span class="p">;</span>
	<span class="p">});</span></code></pre></div>

<h2 id="section-21">异步</h2>

<h3 id="section-22">简单的实现</h3>

<p>不使用forEach，在前一个回调函数中调用下一个保证执行顺序，在最后一个文件处理完毕后输出。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
	<span class="nx">process</span><span class="p">.</span><span class="nx">chdir</span><span class="p">(</span><span class="s1">&#39;recipes&#39;</span><span class="p">);</span> <span class="c1">// change the working directory</span>
	<span class="kd">var</span> <span class="nx">concatenation</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
	<span class="nx">fs</span><span class="p">.</span><span class="nx">readdir</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">filenames</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
		<span class="kd">function</span> <span class="nx">readFileAt</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">filename</span> <span class="o">=</span> <span class="nx">filenames</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
			<span class="nx">fs</span><span class="p">.</span><span class="nx">stat</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">stats</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="nx">stats</span><span class="p">.</span><span class="nx">isFile</span><span class="p">())</span> <span class="k">return</span> <span class="nx">readFileAt</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
					<span class="nx">concatenation</span> <span class="o">+=</span> <span class="nx">text</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">===</span> <span class="nx">filenames</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">concatenation</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="nx">readFileAt</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//保证顺序</span>
				<span class="p">});</span>
			<span class="p">});</span>
		<span class="p">}</span>
		<span class="nx">readFileAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">});</span></code></pre></div>

<h3 id="asyncjs">使用Async.js</h3>

<p>提供两种选择</p>

<ul>
  <li><code>async.filter</code>和<code>async.forEach</code>，并行处理数组</li>
  <li><code>async.filterSeries</code>和<code>async.forEachSeries</code>，串行处理数组</li>
</ul>

<p>并行异步操作明显更快，为何还要用串行的？两个原因</p>

<ul>
  <li>顺序问题。</li>
  <li>Node同时读取文件的数目有限制，超过会出错。串行读取不会有问题。</li>
</ul>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">concatenation</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">dirContents</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readdirSync</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">);</span>
	<span class="nx">async</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">dirContents</span><span class="p">,</span> <span class="nx">isFilename</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">filenames</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">async</span><span class="p">.</span><span class="nx">forEachSeries</span><span class="p">(</span><span class="nx">filenames</span><span class="p">,</span> <span class="nx">readAndConcat</span><span class="p">,</span> <span class="nx">onComplete</span><span class="p">);</span>
	<span class="p">});</span>
	<span class="kd">function</span> <span class="nx">isFilename</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fs</span><span class="p">.</span><span class="nx">stat</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">stats</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
			<span class="nx">callback</span><span class="p">(</span><span class="nx">stats</span><span class="p">.</span><span class="nx">isFile</span><span class="p">());</span>
		<span class="p">});</span>
	<span class="p">}</span>
	<span class="kd">function</span> <span class="nx">readAndConcat</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">fileContents</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">return</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
			<span class="nx">concatenation</span> <span class="o">+=</span> <span class="nx">fileContents</span><span class="p">;</span>
			<span class="nx">callback</span><span class="p">();</span>
		<span class="p">});</span>
	<span class="p">}</span>
	<span class="kd">function</span> <span class="nx">onComplete</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">concatenation</span><span class="p">);</span>
	<span class="p">}</span></code></pre></div>

<h2 id="asyncjs-1">Async.js中错误处理</h2>

<blockquote>
  <p>Async.js follows Node conventions. This means that every I/O
callback has the form (err, results…)—with the exception of callbacks 
where the result is a boolean. Boolean callbacks just have the form (result)
, which is why our isFilename iterator from the previous code example needs 
to handle errors on its own.</p>
</blockquote>

<p>onComplete只会被调用一次，在第一次error出现时或者全部操作成功后。</p>

<h2 id="section-23">组织任务</h2>

<h3 id="section-24">串行运行异步任务</h3>

<p>async.series/async.waterfall</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">async</span> <span class="o">=</span> <span class="nx">require</span> <span class="p">(</span><span class="s1">&#39;async&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">;</span>
<span class="nx">async</span><span class="p">.</span><span class="nx">series</span><span class="p">([</span>
	<span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="p">},</span>
	<span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span> <span class="p">},</span>
	<span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span> <span class="p">}</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Completed in &#39;</span> <span class="o">+</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Date</span> <span class="o">-</span> <span class="nx">start</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;ms&#39;</span><span class="p">);</span>
<span class="p">});</span></code></pre></div>

<h3 id="section-25">并行</h3>

<p>async.parallel上面的例子可能只要300ms，但无法保证顺序。</p>

<h2 id="section-26">动态异步队列</h2>

<p>series和parallel存在局限性</p>

<ul>
  <li>任务数组是静态的，一旦调用不能再添加或者移除。</li>
  <li>无法得知任务完成进度。</li>
  <li>只有完全无并发性或者无限的并发性，无法精确控制并发粒度。</li>
</ul>

<h3 id="section-27">理解队列</h3>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">async</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;async&#39;</span><span class="p">);</span>
<span class="kd">function</span> <span class="nx">worker</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
	<span class="nx">callback</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">concurrency</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">queue</span> <span class="o">=</span> <span class="nx">async</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="nx">worker</span><span class="p">,</span> <span class="nx">concurrency</span><span class="p">);</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span></code></pre></div>

<h2 id="step">使用Step进行最小的流程控制</h2>

<p>只有一个方法Step，接受函数列表作为参数。</p>

<p>每个函数可以以三种方式控制流程</p>

<ul>
  <li>调用this使Step运行列表中下一个函数</li>
  <li>调用n次callback使Step运行下一个函数n次</li>
  <li>返回一个值，</li>
</ul>

<p>下一个函数可以接受前一个的结果，包括返回值或者传递给this方法的参数。
或者前面所有函数的结构，如果前一个通过this.parallel或者this.group调用。
两个函数的区别是parallel将结果作为分离的参数，而group合并成数组。</p>

<p>async.map等同于</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Step</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">);</span>
	<span class="kd">function</span> <span class="nx">stepMap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">iterator</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">Step</span><span class="p">(</span>
			<span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
				<span class="kd">var</span> <span class="nx">group</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">group</span><span class="p">();</span>
				<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">iterator</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">group</span><span class="p">());</span>
				<span class="p">}</span>
			<span class="p">},</span>
			<span class="nx">callback</span>
		<span class="p">);</span>
	<span class="p">}</span></code></pre></div>

<h1 id="ch5-workers">ch5 使用Workers多线程</h1>

<h2 id="web-worker">Web Worker</h2>

<p>Html5提供Web Worker。
双方通过监听message事件接收数据，通过postMessage发送数据。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// master script</span>
	<span class="kd">var</span> <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">(</span><span class="s1">&#39;boknows.js&#39;</span><span class="p">);</span>
	<span class="nx">worker</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
	<span class="p">});</span>
	<span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;football&#39;</span><span class="p">);</span>
	<span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;baseball&#39;</span><span class="p">);</span>
	<span class="c1">// boknows.js</span>
	<span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">self</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s1">&#39;Bo knows &#39;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
	<span class="p">});</span></code></pre></div>

<p><a href="https://github.com/ajaxorg/ace-builds/">Ace文本编辑器</a>
使用单独的线程进行语法分析，保证编辑界面流畅运行。</p>

<p>通常worker将计算结果发送给主线程，然后由主线程更新页面。如果worker能直接改变页面，就会带来同步问题，需要将DOM操作包装在同步量中，像Java中那样。</p>

<p>所以worker无法看见全局window对象或者主线程和其他worker中的任何对象。
通过postMessage传递对象时，会进行序列化和反序列化，修改原对象不会影响其他线程中的拷贝。</p>

<p>worker只能看到自身的全局对象也就是self对象。包括了标准的js对象和浏览器的ajax方法。worker可以使用XMLHttpRequest和WebSocket，可以独立地向服务器请求数据。</p>

<h2 id="nodecluster">Node中的cluster</h2>

<h1 id="ch6-">ch6 异步脚本加载</h1>

<p>script的位置，放在head标签中，影响加载速度，长时间的空白。
放在body末尾，无生气的组件。</p>

<h2 id="section-28">限制和警告</h2>

<p>以下方法不适合内联脚本。尽量避免使用，非要用则不要使用defer或者async属性。
避免使用document.write，在异步加载的脚本中的行为是不可预测的。类似DOM操作的GOTO。</p>

<h2 id="script">script标签</h2>

<p>用户只能看到标题，直到放在head中的script被全部下载完毕并运行。
需要绑定document.onreadystatechange，确保dom加载完成。</p>

<p>所以将脚本放在body的末尾，用户能更快看到页面，
脚本也能看见DOM，无需等待事件触发。</p>

<p>这么做需要注意三点，任何一点不满足就不应该下移：</p>

<ol>
  <li>body中是否有inline的js调用末尾的这些脚本</li>
  <li>使用<a href="http://modernizr.com/">Modernizr</a>检测用户的浏览器是否支持HTML5&amp;CSS3 <a href="http://html5boilerplate.com/">HTML5 Boilerplate</a>将其在顶部引入</li>
  <li>脚本是否会影响页面中某些元素（如字体）的展示效果，会显示两次。</li>
</ol>

<h2 id="section-29">脚本延迟加载</h2>

<p>在文档全部加载完毕之前浏览器不会下载脚本，在大的文档传输中，会成为性能瓶颈。</p>

<p>理想化的场景中，脚本和文档并行加载，不影响DOM的渲染，当文档加载完毕再运行脚本。</p>

<p>使用ajax加载脚本可以满足需求，但是有个更简单的解决方案。
使用script的defer属性：<code>&lt;script defer src="deferredScript.js"&gt;</code>。
告诉浏览器首先加载，但不会立即执行，直到DOM加载完毕并且之前包含defer的脚本也执行完毕。这样就可以移入head标签中，得到所有之前移入body末尾的好处，还额外获得了加载大文档的速度提升。</p>

<p>缺点是不被所有浏览器支持。</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;html&gt;</span>
	<span class="nt">&lt;head&gt;</span>
		<span class="c">&lt;!-- metadata and stylesheets go here --&gt;</span>
		<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;headScripts.js&quot;</span><span class="nt">&gt;</span><span class="o">&lt;</span><span class="err">/scripts&gt;</span>
		<span class="o">&lt;</span><span class="nx">script</span> <span class="nx">defer</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;deferredScripts.js&quot;</span><span class="o">&gt;</span><span class="nt">&lt;/script&gt;</span>
	<span class="nt">&lt;/head&gt;</span>
	<span class="nt">&lt;body&gt;</span>
		<span class="c">&lt;!-- content goes here --&gt;</span>
	<span class="nt">&lt;/body&gt;</span>
	<span class="nt">&lt;/html&gt;</span></code></pre></div>

<h2 id="section-30">并行加载</h2>

<p>有时我们不希望等到一个脚本执行完才开始加载下一个脚本。希望尽快加载所有脚本并运行。现代浏览器提供了async属性，不保证脚本的执行顺序，也不保证执行时DOM是否加载完毕。</p>

<p>同时使用async和defer时，支持async的浏览器中async会覆盖defer。由于defer支持度更高，也能提供在加载脚本的同时渲染DOM的好处，所以推荐在使用async的地方都使用defer。</p>

<p>以下加载顺序是：headScript运行完毕后，dom开始加载，deferredScript在dom显示的同时后台加载，dom显示完毕，两个wigetJs开始执行，顺序未知。</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;html&gt;</span>
	<span class="nt">&lt;head&gt;</span>
		<span class="c">&lt;!-- metadata and stylesheets go here --&gt;</span>
		<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;headScripts.js&quot;</span><span class="nt">&gt;</span><span class="o">&lt;</span><span class="err">/scripts&gt;</span>
		<span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;deferredScripts.js&quot;</span> <span class="nx">defer</span><span class="o">&gt;</span><span class="nt">&lt;/script&gt;</span>
	<span class="nt">&lt;/head&gt;</span>
	<span class="nt">&lt;body&gt;</span>
		<span class="c">&lt;!-- content goes here --&gt;</span>
		<span class="nt">&lt;script </span><span class="na">async</span> <span class="na">defer</span> <span class="na">src=</span><span class="s">&quot;feedbackWidget.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
		<span class="nt">&lt;script </span><span class="na">async</span> <span class="na">defer</span> <span class="na">src=</span><span class="s">&quot;chatWidget.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
	<span class="nt">&lt;/body&gt;</span>
	<span class="nt">&lt;/html&gt;</span></code></pre></div>

<h2 id="section-31">可编程加载</h2>

<p>希望在特定的条件下加载脚本。</p>

<h3 id="section-32">直接加载</h3>

<p>浏览器向服务器请求脚本并执行的两种方式：</p>

<ol>
  <li>发出ajax请求，使用eval执行响应内容。</li>
  <li>向DOM中插入script标签。</li>
</ol>

<p>第一种的缺点是eval存在作用域泄露问题。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">head</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;head&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">);</span>
	<span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="s1">&#39;/js/feature.js&#39;</span><span class="p">;</span>
	<span class="nx">head</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span></code></pre></div>

<p>如果想知道script何时加载完成，可以让其触发一个特定事件，但这样太繁琐。
html5中<code>script.onload = function(){}</code>可以绑定一个回调函数。但是不被所有
浏览器支持，比如ie8使用<code>onreadystatechange</code>。所以推荐使用script加载类库。</p>

<h3 id="yepnope">使用yepnope进行条件加载</h3>

<p>yepnope是一个轻量级类库，可以单独使用，也可以配合Modernizr使用。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">yepnope</span><span class="p">({</span>
		<span class="nx">load</span><span class="o">:</span> <span class="s1">&#39;oompaLoompas.js&#39;</span><span class="p">,</span>
		<span class="nx">callback</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Oompa-Loompas ready!&#39;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">});</span></code></pre></div>

<p>backbone依赖于underscore，加载顺序。complete不同于callback，前者在所有脚本都被加载完毕后运行，而callback为加载列表中每一个资源运行。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">yepnope</span><span class="p">({</span>
		<span class="nx">load</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;underscore.js&#39;</span><span class="p">,</span> <span class="s1">&#39;backbone.js&#39;</span><span class="p">],</span>
		<span class="nx">complete</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// Backbone logic goes here</span>
		<span class="p">}</span>
	<span class="p">});</span></code></pre></div>

<p>yepnope最具代表性的特征是条件加载。</p>

<p>判断设备是否是触屏设备：根据条件判断决定加载文件</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">yepnope</span><span class="p">({</span>
		<span class="nx">test</span><span class="o">:</span> <span class="nx">Modernizr</span><span class="p">.</span><span class="nx">touch</span><span class="p">,</span>
		<span class="nx">yep</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;touchStyles.css&#39;</span><span class="p">,</span> <span class="s1">&#39;touchApplication.js&#39;</span><span class="p">],</span>
		<span class="nx">nope</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;mouseStyles.css&#39;</span><span class="p">,</span> <span class="s1">&#39;mouseApplication.js&#39;</span><span class="p">],</span>
		<span class="nx">complete</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// either way, the application is now ready!</span>
		<span class="p">}</span>
	<span class="p">});</span></code></pre></div>

<p>常用的用法：填补旧版本浏览器缺失的功能</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">yepnope</span><span class="p">({</span>
		<span class="nx">test</span><span class="o">:</span> <span class="nb">window</span><span class="p">.</span><span class="nx">json</span><span class="p">,</span>
		<span class="nx">nope</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;json2.js&#39;</span><span class="p">],</span>
		<span class="nx">complete</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// now we can JSON safely</span>
		<span class="p">}</span>
	<span class="p">});</span></code></pre></div>

<h3 id="requirejsamd">使用Require.js和AMD智能加载</h3>

<p>require函数第一个参数是数组，并行加载数组中的脚本。不同于yepnope，require不保证目标脚本的运行顺序。但是会保证脚本之间的依赖关系，只要脚本满足AMD(Asynchronous Module Definition)规范。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">require</span><span class="p">([</span><span class="s1">&#39;moment&#39;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">moment</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">moment</span><span class="p">().</span><span class="nx">format</span><span class="p">(</span><span class="s1">&#39;dddd&#39;</span><span class="p">));</span> <span class="c1">// day of the week</span>
	<span class="p">});</span></code></pre></div>

<p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a>规范。</p>

<p>全局函数define，三个参数：名字，依赖列表和依赖加载完毕后的回调函数。</p>

<p>下面就是一个有效的AMD规范，定义了一个依赖jquery的应用。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;myApplication&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;jquery&#39;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;body&gt;&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;&lt;p&gt;Hello, async world!&lt;/p&gt;&#39;</span><span class="p">);</span>
	<span class="p">});</span></code></pre></div>

<p>define是如何捕获jquery对象的呢？jquery的AMD定义返回了jQuery对象。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">define</span><span class="p">(</span> <span class="s2">&quot;jquery&quot;</span><span class="p">,</span> <span class="p">[],</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">jQuery</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span></code></pre></div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">xiaOp写东西的地方</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>xiaOp写东西的地方</li>
          <li><a href="mailto:pyqiverson@gmail.com">pyqiverson@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/xiaoiver">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">xiaoiver</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/jekyllrb">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">jekyllrb</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">读书笔记，碰到的问题
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
