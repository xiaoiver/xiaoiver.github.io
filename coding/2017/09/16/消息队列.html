<!DOCTYPE html><meta charset=utf-8><meta name=viewport content="width=device-widthinitial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=keywords content=coding编程javascriptxiaoiverxiaop><meta name=theme-color content=#eee><title>Node.js 中的消息队列 | xiaOp的博客</title><meta property=og:title content="Node.js 中的消息队列"><meta name=author content=xiaOp><meta property=og:locale content=en_US><meta name=description content="在用户注册的场景中，服务端接收到提交的表单内容，将数据写入数据库，随后发送一封注册成功邮件。 通常处理请求参数，操作数据库，调用 STMP 邮件服务器发送邮件都写在一个请求处理函数中。这样的问题是任何一步发生错误，都需要重试。这还只是一个简单场景，如果流程复杂，依赖外部系统众多，显然问题就不可避免了。"><meta property=og:description content="在用户注册的场景中，服务端接收到提交的表单内容，将数据写入数据库，随后发送一封注册成功邮件。 通常处理请求参数，操作数据库，调用 STMP 邮件服务器发送邮件都写在一个请求处理函数中。这样的问题是任何一步发生错误，都需要重试。这还只是一个简单场景，如果流程复杂，依赖外部系统众多，显然问题就不可避免了。"><link rel=canonical href=https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html><meta property=og:url content=https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html><meta property=og:site_name content=xiaOp的博客><meta property=og:type content=article><meta property=article:published_time content=2017-09-17T03:21:32+08:00><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Node.js 中的消息队列","author":{"@type":"Person","name":"xiaOp"},"datePublished":"2017-09-17T03:21:32+08:00","dateModified":"2017-09-17T03:21:32+08:00","description":"在用户注册的场景中，服务端接收到提交的表单内容，将数据写入数据库，随后发送一封注册成功邮件。 通常处理请求参数，操作数据库，调用 STMP 邮件服务器发送邮件都写在一个请求处理函数中。这样的问题是任何一步发生错误，都需要重试。这还只是一个简单场景，如果流程复杂，依赖外部系统众多，显然问题就不可避免了。","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html"},"url":"https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html"}</script><title>Node.js 中的消息队列</title><link rel="shortcut icon" href=/img/favicon.ico><link rel=canonical href=https://xiaoiver.github.io/coding/2017/09/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html><link rel=manifest href=/manifest.json><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/style-large.css><link rel=stylesheet href=/css/prism.css><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script src=/js/jquery.min.js></script><script src=/js/Imager.min.js></script><script src=/js/jquery.scrollzer.min.js></script><script src=/js/jquery.scrolly.min.js></script><script src=/js/skel.min.js></script><script src=/js/skel-layers.min.js></script><script src=/js/prism.min.js></script><script src=/js/init.min.js></script><section id=header class=skel-layers-fixed><header><span class="image avatar"><img src=/img/avatar.jpg alt=""></span><h1 id=logo><a href=/ class=secret>xiaOp's Blog</a></h1><p>想成为一个有趣的人</header><nav id=nav><ul><li><a href=#intro>主页</a><li><a href=#blog>文章</a><li><a href=#contact>兴趣</a></ul></nav><footer><ul class=icons><li><a href=https://github.com/xiaoiver class="icon fa-github"><span class=label>Github</span></a><li><a href=mailto:pyqiverson@gmail.com class="icon fa-envelope"><span class=label>Email</span></a><li><a href=https://www.douban.com/people/150275082/ class=icon>豆</a><li><a href=https://www.zhihu.com/people/pan-yu-qi-20/activities class=icon>知</a></ul></footer></section><div id=wrapper><div id=main><style>header.intro-header {
        position: relative;
        background-image: url('/img/work-queue.png');
        background-size: cover;
    }
    
    header.intro-header .header-mask {
        width: 100%;
        height: 100%;
        position: absolute;
        background: rgba(0,0,0, 0.6);
    }
    

    header.intro-header .icon {
        position: absolute;
        top: 8px;
        right: 8px;
        color: white;
        background: #4acaa8;
        border-radius: 50%;
        height: 2.5em;
        width: 2.5em;
        line-height: 2.5em;
        text-align: center;
    }

    .post-heading {
        position: relative;
        padding: 50px 0;
        color: white;
    }
    .post-heading h2,
    .post-heading h3,
    .post-heading h4 {
        color: white;
    }
    .post-heading h2 {
        font-size: 3em;
    }
    .post-heading .meta {
        transform: translate(0.1em, 0.5em);
    }

    article {
        padding-top: 20px;
    }

    .post-container img {
        display: block;
        max-width: 100%;
        height: auto;
        margin: 1.5em auto 1.6em auto;
    }
    .post-container a {
        color: #4acaa8;
    }</style><header class=intro-header><div class=header-mask></div><span class="icon fa-code"></span><div class=container><div class=post-heading><h2>Node.js 中的消息队列<h3 class=subheading>基于内存，持久化，Redis 和 RabbitMQ</h3></h2><div class=tags><a class=tag href=/tags#javascript title=javascript>javascript</a> <a class=tag href=/tags#nodejs title=nodejs>nodejs</a> <a class=tag href=/tags#leveldb title=leveldb>leveldb</a> <a class=tag href=/tags#redis title=redis>redis</a> <a class=tag href=/tags#rabbitMQ title=rabbitMQ>rabbitMQ</a></div><span class="meta secret secret-lg">Posted by xiaOp on September 16, 2017</span></div></div></header><article class=post-container><div class=container><p>在用户注册的场景中，服务端接收到提交的表单内容，将数据写入数据库，随后发送一封注册成功邮件。 通常处理请求参数，操作数据库，调用 STMP 邮件服务器发送邮件都写在一个请求处理函数中。这样的问题是任何一步发生错误，都需要重试。这还只是一个简单场景，如果流程复杂，依赖外部系统众多，显然问题就不可避免了。<p>我们引入消息队列，producer 负责向队列中推送消息，而 worker 负责消费。 <img src=/img/work-queue.png alt=""><p>使用消息队列的好处是显而易见的：<ol><li>解耦了 producer 和 worker。尤其是像发送邮件这样对实时性要求不高的步骤，如果这一步操作失败，我们显然不需要回滚之前对数据库的修改，只需要在合适的时间重试就行了。<li>实现重试逻辑变得简单。另外，当进程出现错误，不至于丢失全部状态，甚至可以从错误中恢复。<li>分布式和扩展性。配合 cluster，创建多个 worker 变得简单。<li>让外部系统更容易集成进来，相比在一个请求回调函数中完成所有逻辑处理。</ol><h2 id=简单的内存队列>简单的内存队列</h2><p>首先实现一个内存中的队列管理，使用 async 创建队列。<div><pre class=line-numbers data-line=""><code class=language-javascript>// 创建并发度为1的异步队列
const queue = async.queue(work, 1);

function work(item, cb) {
    ensureConnected(function() {
        domotic.command(item.command, item.options, callback);
    });

    function callback(err) {
        // 出错重试
        if (err &amp;&amp; err.code == &#39;ECONN&#39;) {
            connected = false;
            work(item, cb);
        } else cb(err);
    }
}
// 推送消息到队列中
queue.push(work, cb);</code></pre></div><p>这样一个简单的 demo 存在的问题就是所有状态存在于内存中，一旦崩溃就无法恢复了。另外内存毕竟有限，对于一个长时间运行的系统，迟早是会超出内存限制的。<h2 id=通过-leveldb-持久化>通过 LevelDB 持久化</h2><p>持久化队列是个不错的改进方向。LevelDB 是一个键值对数据库，不需要安装，可以在指定目录下创建。另外，使用配套的 <code class=highlighter-rouge>level-jobs</code> 可以快捷的创建队列。<div><pre class=line-numbers data-line=""><code class=language-javascript>const level = require(&#39;level&#39;);
// 创建本地数据库
const db = level(&#39;./event/db&#39;);
const Jobs = require(&#39;level-jobs&#39;);
const maxConcurrency = 1;
// 创建队列，并发度1
const queue = Jobs(db, worker, maxConcurrency);

module.exports = queue;

function worker(id, payload, cb) {
    sendEventToRemoteService(payload, (err) =&gt; {
        if (err) {
            console.error(&#39;Error processing event %s: %s&#39;,payload.id, err.message);
        }
        else {
            console.log(&#39;event %s successfully relayed&#39;, payload.id);
        }
        cb(err);
    });
}
// 模拟复杂异步处理流程
function sendEventToRemoteService(payload, cb) {
    setTimeout(() =&gt; {
        let err;
        if (Math.random() &gt; 0.5) {
            err = Error(&#39;something awful has happened&#39;);
        }
        cb(err);
    }, 100);
}</code></pre></div><p>通过<code class=highlighter-rouge>queue.push(payload)</code>可以向队列中推送消息。<div><pre class=line-numbers data-line=""><code class=language-javascript>const relay = require(&#39;./event_relay&#39;);
for(let i = 0; i &lt; 10; i++) {
    relay.push({
        id: i,
        event: &#39;door opened&#39;
    });
}</code></pre></div><p>现在我们解决了持久化队列的问题，但是我们的 worker 是单线程运行的。如果任务是 CPU 密集型的，还是需要分配负载到多个线程上。<h2 id=redis-和多线程>Redis 和多线程</h2><p><code class=highlighter-rouge>simple-redis-safe-work-queue</code> 是一个基于 Redis 的分布式 worker/producer 的队列解决方案。 创建 worker，设置重试次数。<div><pre class=line-numbers data-line=""><code class=language-javascript>const request = require(&#39;request&#39;);
const Queue = require(&#39;simple-redis-safe-work-queue&#39;)
// 设置重试次数
const workerOptions = {
  maxRetries: 2
};

const worker = Queue.worker(&#39;invoke webhook&#39;, invokeWebhook, workerOptions);

function invokeWebhook(webhook, cb) {
    console.log(&#39;invoke webhook: %j&#39;, webhook);

    request(webhook, done);

    function done(err, res) {
        if (!err &amp;&amp; (res.statusCode &lt; 200 || res.statusCode &gt;= 300)) {
            err = Error(&#39;response status code was &#39; + res.statusCode);
        }
        cb(err);
    }
}

worker.on(&#39;max retries&#39;, function(err, payload) {
    console.error(
        &#39;max retries reached trying to talk to %s.: %s\nrequest params: %j&#39;,
        payload.url, err.stack, payload);
});</code></pre></div><p>而对于 producer，在一个实际的例子中，在数据库操作完成后向队列推送消息，并在 server 停止时关闭队列。<div><pre class=line-numbers data-line=""><code class=language-javascript>const Queue = require(&#39;simple-redis-safe-work-queue&#39;)
const webhookQueueClient = Queue.client(&#39;invoke webhook&#39;);
const server = Server();
server.listen(8080);
server.post(&#39;/some/important/action&#39;, (req, res, next) =&gt; {
    db.insert(someDoc, err =&gt; {
        if (err) res.send(err);
        else {
            webhookQueueClient.push({
                url: &#39;http://example.com&#39;,
                method: &#39;POST&#39;,
                json: {
                    a: 1,
                    b: 2
                }
            }, pushedWebhookWork);
        }

        function pushedWebhookWork(err) {
            if (err) res.stats(500).send(err);
            else res.stats(201).send({ok: true});
        }
    });
});
// 关闭队列
server.once(&#39;close&#39;, () =&gt; {
    webhookQueueClient.quit();
});</code></pre></div><p>这样我们可以启动多个 worker 线程消费队列。Redis 在处理简单的场景中足够了，如果对可扩展性和稳定性有更高要求，就需要更为成熟的平台了。<h2 id=rabbitmq>RabbitMQ</h2><p>通过 homebrew 安装后。启动服务器：<code class=highlighter-rouge>/usr/local/sbin/rabbitmq-server</code>。<p>创建 channel，无论成功与否都会触发回调函数。worker 和 producer 都会通过该方法连接队列。<div><pre class=line-numbers data-line=""><code class=language-javascript>const amqp = require(&#39;amqplib/callback_api&#39;);
const url = process.env.AMQP_URL || &#39;amqp://guest:guest@localhost:5672&#39;;

module.exports = createQueueChannel;

function createQueueChannel(queue, cb) {
    amqp.connect(url, onceConnected);

    function onceConnected(err, conn) {
        if (err) {
            console.error(&#39;Error connecting:&#39;, err.stack);
        }
        else {
            console.log(&#39;connected&#39;);
            conn.createChannel(onceChannelCreated);
        }

        function onceChannelCreated(err, channel) {
            if (err) {
                cb(err);
            }
            else {
                channel.assertQueue(queue, {durable: true}, onceQueueCreated);
            }

            function onceQueueCreated(err) {
                if (err) {
                    cb(err);
                }
                else {
                    cb(null, channel, conn);
                }
            }
        }
    }
}</code></pre></div><p>对于 producer 而言，需要连接 channel，然后向队列发送消息，随后断开连接：<div><pre class=line-numbers data-line=""><code class=language-javascript>const Channel = require(&#39;./channel&#39;);
const QUEUE = &#39;queue&#39;;

Channel(QUEUE, (err, channel, conn) =&gt; {
    if (err) {
        console.error(err.stack);
    }
    else {
        console.log(&#39;channel and queue created&#39;);
        let work = &#39;make me a sandwich&#39;;
        channel.sendToQueue(QUEUE, encode(work), {
            persistent: true
        });
        setImmediate(() =&gt; {
            channel.close();
            conn.close();
        });
    }
});</code></pre></div><p>而对于每一个 worker，连接成功后，取出队列中的消息内容载荷进行消费，完成后通过<code class=highlighter-rouge>ack()</code>通知队列，继续消费下一个消息。而如果队列为空，通过定时器在一定延迟后继续消费。<div><pre class=line-numbers data-line=""><code class=language-javascript>Channel(QUEUE, (err, channel, conn) =&gt; {
    if (err) {
        console.error(err.stack);
    }
    else {
        console.log(&#39;channel and queue created&#39;);
        consume();
    }

    function consume() {
        channel.get(QUEUE, {}, onConsume);

        function onConsume(err, msg) {
            if (err) {
                console.warn(err.message);
            }
            else if (msg) {
                console.log(&#39;consuming %j&#39;, msg.content.toString());
                setTimeout(() =&gt; {
                    channel.ack(msg);
                    consume();
                }, 1e3);
            }
            else {
                console.log(&#39;no message, waiting...&#39;);
                setTimeout(consume, 1e3);
            }
        }
    }
});</code></pre></div><h2 id=参考资料>参考资料</h2><ul><li><a href=https://blog.yld.io/2016/05/10/introducing-queues/#.Wb4dqHeg_2Q>YLD博客的系列文章</a><li><a href=http://www.rabbitmq.com/documentation.html>RabbitMQ</a></ul></div></article><div id=lv-container data-id=city data-uid=MTAyMC8zMDQyNy82OTgx><script>(function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div><script>function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }</script><script>async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.post-heading h2').remove('.subheading').remove('#logo');
    })</script><style>/* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -1.25em;
            font-size: 1.1em;
        }
    }</style></div></div>