<!DOCTYPE html>
<html>

    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="keywords" content="coding编程javascriptxiaoiverxiaop">
    <meta name="theme-color" content="#eee">
    <meta name="msapplication-TileColor" content="#eee">
    <meta name="msapplication-TileImage" content="/img/manifest/ms-icon-144x144.png">
    <!-- Begin Jekyll SEO tag v2.2.3 -->
<title>SSR 中的离线可用（一） | xiaOp的博客</title>
<meta property="og:title" content="SSR 中的离线可用（一）" />
<meta name="author" content="xiaOp" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。" />
<meta property="og:description" content="本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。" />
<link rel="canonical" href="https://xiaoiver.github.io/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html" />
<meta property="og:url" content="https://xiaoiver.github.io/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html" />
<meta property="og:site_name" content="xiaOp的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-25T03:21:32+08:00" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"BlogPosting","headline":"SSR 中的离线可用（一）","author":{"@type":"Person","name":"xiaOp"},"datePublished":"2017-10-25T03:21:32+08:00","dateModified":"2017-10-25T03:21:32+08:00","description":"本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaoiver.github.io/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html"},"url":"https://xiaoiver.github.io/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html"}</script>
<!-- End Jekyll SEO tag -->

    <title>SSR 中的离线可用（一）</title>

    <link rel="apple-touch-icon" sizes="57x57" href="/img/manifest/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/img/manifest/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/img/manifest/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/img/manifest/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/img/manifest/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/img/manifest/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/img/manifest/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/img/manifest/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/manifest/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/img/manifest/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/manifest/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/img/manifest/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/manifest/favicon-16x16.png">

    <link rel="shortcut icon" href="/img/manifest/favicon.ico" type="image/x-icon">
    <link rel="canonical" href="https://xiaoiver.github.io/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html">
    <link rel="manifest" href="/manifest.json">

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/style-large.css" />
    <link rel="stylesheet" href="/css/prism.css" />
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/Imager.min.js"></script>
    <script src="/js/jquery.scrollzer.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/skel-layers.min.js"></script>
    <script src="/js/prism.min.js"></script>
    <script src="/js/init.min.js"></script>
</head>


    <body>

        <section id="header" class="skel-layers-fixed">
    <header>
        <span class="image avatar"><img src="/img/avatar.jpg" alt="" /></span>
        <h1 id="logo"><a href="/" class="secret">xiaOp's Blog</a></h1>
        <p>想成为一个有趣的人</p>
    </header>
    <nav id="nav">
        <ul>
            <li><a href="#intro">主页</a></li>
            <li><a href="#blog">文章</a></li>
            <li><a href="#contact">兴趣</a></li>
        </ul>
    </nav>
    <footer>
        <ul class="icons">
            <li><a href="https://github.com/xiaoiver" class="icon fa-github"><span class="label">Github</span></a></li>
            <li><a href="mailto:pyqiverson@gmail.com" class="icon fa-envelope"><span class="label">Email</span></a></li>
            <li><a href="https://www.douban.com/people/150275082/" class="icon">豆</a></li>
            <li><a href="https://www.zhihu.com/people/pan-yu-qi-20/activities" class="icon">知</a></li>
        </ul>
    </footer>
</section>


        <div id="wrapper">
            <div id="main">
                <style type="text/css">
    header.intro-header {
        position: relative;
        background-image: url('/img/PWA-Directory.png');
        background-size: contain;;
        background-repeat: no-repeat;
        background-position: center center;
    }
    
    header.intro-header .header-mask {
        width: 100%;
        height: 100%;
        position: absolute;
        background: rgba(0,0,0, 0.8);
    }
    

    header.intro-header .icon {
        position: absolute;
        top: 8px;
        right: 8px;
        color: white;
        background: #4acaa8;
        border-radius: 50%;
        height: 2.5em;
        width: 2.5em;
        line-height: 2.5em;
        text-align: center;
    }

    .post-heading {
        position: relative;
        padding: 50px 0;
        color: white;
    }
    .post-heading h2,
    .post-heading h3,
    .post-heading h4 {
        color: white;
    }
    .post-heading h2 {
        font-size: 3em;
    }
    .post-heading .meta {
        transform: translate(0.1em, 0.5em);
    }

    article {
        padding-top: 20px;
    }

    .post-container img {
        display: block;
        max-width: 100%;
        height: auto;
        margin: 1.5em auto 1.6em auto;
    }
    .post-container a {
        color: #4acaa8;
    }
</style>

<header class="intro-header" >
    <div class="header-mask"></div>
    <span class="icon fa-code"></span>
    <div class="container">
        <div class="post-heading">
            <h2>
                SSR 中的离线可用（一）
            </h1>
            <h3 class="subheading">Case Study: PWA-Directory</h2>
            <div class="tags">
                
                <a class="tag" href="/tags#PWA" title="PWA">PWA</a>
                
                <a class="tag" href="/tags#ServiceWorker" title="ServiceWorker">ServiceWorker</a>
                
            </div>
            <span class="meta secret secret-lg">Posted by xiaOp on October 24, 2017</span>
        </div>
    </div>
</header>

<article class="post-container">
    <div class="container">
        <p>本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。</p>

<ul>
  <li>本文是第一部分，以<a href="https://pwa-directory.appspot.com">PWA-Directory</a>为例。</li>
  <li><a href="/coding/2017/10/28/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%BA%8C.html">第二部分</a>将研究一个 WordPress 主题项目。</li>
  <li><a href="/coding/2017/11/12/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%89.html">第三部分</a>将使用 Vue SSR 实践这一思路。</li>
</ul>

<p>PWA-Directory 是一个陈列 PWA 的站点，同时展示项目 Lighthouse 分数及其他页面性能数据。</p>

<p class="responsive-image">
    <img class="responsive-image__placeholder" src="/img/resized/480/PWA-Directory.png" alt="PWA-Directory" />
    <div class="responsive-image__delayed" data-src="/img/resized/{width}/PWA-Directory.png" data-alt="PWA-Directory">
    </div>
    <em>PWA-Directory</em>
</p>

<script>
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
</script>

<p>本文假设读者对 PWA 相关技术尤其是 Service Worker 的基础知识已有一定了解。</p>

<h3 id="app-shell-模型">App Shell 模型</h3>

<p>App Shell 是支持用户界面所需的最小的 HTML、CSS 和 JavaScript。对其进行离线缓存，可确保在用户重复访问时提供即时、可靠的良好性能。这意味着并不是每次用户访问时都要从网络加载 App Shell。 只需要从网络中加载必要的内容。</p>

<p class="responsive-image">
    <img class="responsive-image__placeholder" src="/img/resized/480/appshell.png" alt="App Shell 模型" />
    <div class="responsive-image__delayed" data-src="/img/resized/{width}/appshell.png" data-alt="App Shell 模型">
    </div>
    <em>App Shell 模型</em>
</p>

<script>
    new Imager('.responsive-image__delayed', {
        availableWidths: [480],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
</script>

<p>PWA-Directory 包括我们后续的讨论都基于 App Shell 模型。下面我们需要了解一下缓存的细节。</p>

<h3 id="预缓存">预缓存</h3>

<p>Service Worker 最重要的功能便是控制缓存。这里先简单介绍下预缓存或者说 sw-precache 插件的基本工作原理。</p>

<p>在项目构建阶段，将静态资源列表（数组形式）及本次构建版本号注入 Service Worker 代码中。在 SW 运行时（Install 阶段）依次发送请求获取静态资源列表中的资源（JS,CSS,HTML,IMG,FONT…），成功后放入缓存并进入下一阶段（Activated）。这个在实际请求之前进行缓存的过程就是预缓存。</p>

<p>在 SPA/MPA 架构的应用中，App Shell 通常包含在 HTML 页面中，连同页面一并被预缓存，保证了离线可访问。但是在 SSR 架构场景下，情况就不一样了。所有页面首屏均是服务端渲染，预缓存的页面不再是有限且固定的。如果预缓存全部页面，SW 需要发送大量请求不说，每个页面都包含的 App Shell 部分都被重复缓存，也造成了缓存空间的浪费。</p>

<p>既然针对全部页面的预缓存行不通，我们能不能将 App Shell 剥离出来，单独缓存仅包含这个空壳的页面呢？要实现这一点，就需要对后端模板进行修改，通过传入参数控制返回包含 App Shell 的完整页面 OR 代码片段。这样首屏使用完整页面，而后续页面切换交给前端路由完成，请求代码片段进行填充。这也是基于 React、Vue 等技术实现的同构项目的基本思路。</p>

<p>对于模板的修改并不复杂，例如在 PWA-Directory 中，使用 Handlebars 作为后端模板，通过自定义的 contentOnly 参数就能适应首屏和后续 HTML 片段两种请求。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-html">// list.hbs

{{#unless contentOnly}}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    {{&gt; head}}
  &lt;/head&gt;
  &lt;body&gt;
    {{&gt; header}}
    &lt;div class=&quot;page-holder&quot;&gt;
      &lt;main class=&quot;page&quot;&gt;
{{/unless}}
... 页面具体内容
{{#unless contentOnly}}
      &lt;/main&gt;
      &lt;div class=&#39;page-loader&#39;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    {{&gt; footer}}
  &lt;/body&gt;
&lt;/html&gt;
{{/unless}}</code></pre>
</div>

<p>然后在 SW 中我们需要对 App Shell 页面和 Offline 页面进行预缓存，这里使用了 sw-toolbox 。同时后端需要增加返回 App Shell 的路由规则，这里是<code class="highlighter-rouge">/.app/shell</code>。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// service-worker.js

const SHELL_URL = &#39;/.app/shell&#39;;
const ASSETS = [
   SHELL_URL,
   &#39;/favicons/android-chrome-72x72.png&#39;,
   &#39;/manifest.json&#39;,
   ...
];
// 使用 sw-toolbox 缓存静态资源
toolbox.precache(ASSETS);</code></pre>
</div>

<p>最后我们拦截掉所有 HTML 请求，请求目标页面的内容片段而非完整代码（getContentOnlyUrl 执行了 contentOnly 参数拼接工作），返回之前缓存的 App Shell 页面。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// service-worker.js

toolbox.router.default = (request, values, options) =&gt; {
    // 拦截 HTML 请求
    if (request.mode === &#39;navigate&#39;) {
        // 请求代码片段
        toolbox.cacheFirst(new Request(getContentOnlyUrl(request.url)), values, options);
        // 返回 App Shell 页面
        return getFromCache(SHELL_URL)
            .then(response =&gt; response || gulliverHandler(request, values, options));
    }
    return gulliverHandler(request, values, options);
};</code></pre>
</div>

<p>有一点值得注意，通常请求目标页面内容片段是放在前端路由中完成的，而这里放在了 SW 中，有什么好处呢？这一点 PWA-Directory 开发者有一篇文章进行了专门讨论，这里就直接使用文中的图片进行说明了。
先看看之前的做法，也就是在前端路由中：</p>

<p class="responsive-image">
    <img class="responsive-image__placeholder" src="/img/resized/480/pwa-directory-1.png" alt="前端路由请求代码片段流程图" />
    <div class="responsive-image__delayed" data-src="/img/resized/{width}/pwa-directory-1.png" data-alt="前端路由请求代码片段流程图">
    </div>
    <em>前端路由请求代码片段流程图</em>
</p>

<script>
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
</script>

<p>可以看出，<code class="highlighter-rouge">app.js</code>加载并执行时才会发出 HTML 代码片段请求，然后等待服务端响应。整个过程中 SW 处于空闲状态，而事实上第一次拦截到 HTML 请求时，SW 就完全可以先请求代码片段了（拼上参数），拿到响应后放入缓存中。这样当<code class="highlighter-rouge">app.js</code>前端路由执行发出请求时，浏览器发现已经在缓存中，就可以直接使用。当然为了实现这一点，需要在服务端通过设置响应头<code class="highlighter-rouge">Cache-Control: max-age</code>保证内容片段的缓存时间。</p>

<p class="responsive-image">
    <img class="responsive-image__placeholder" src="/img/resized/480/pwa-directory-2.png" alt="SW 请求代码片段流程图" />
    <div class="responsive-image__delayed" data-src="/img/resized/{width}/pwa-directory-2.png" data-alt="SW 请求代码片段流程图">
    </div>
    <em>SW 请求代码片段流程图</em>
</p>

<script>
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
</script>

<p>总结一下这个思路：</p>
<ol>
  <li>改造后端模板以支持返回完整页面和内容片段</li>
  <li>服务端增加一条针对 App Shell 的路由规则，返回仅包含 App Shell 的 HTML 页面</li>
  <li>预缓存 App Shell 页面</li>
  <li>SW 拦截所有 HTML 请求，统一返回缓存的 App Shell 页面</li>
  <li>前端路由负责代码片段的填充，完成前端渲染</li>
</ol>

<p>实际效果是，用户第一次访问应用站点时，首屏由服务端渲染，随后 SW 安装成功后，后续的路由切换包括刷新页面都将由前端渲染完成，服务端将只负责提供 HTML 代码片段的响应。</p>

<p>解决了预缓存问题，下面我们需要关注另外一个离线可用目标中涉及的关键问题。</p>

<h3 id="数据统计">数据统计</h3>

<p>在衡量 PWA 效果时，至少有以下几个指标可以考量：</p>
<ul>
  <li>当弹出添加到桌面的 banner 时，用户是否选择了同意</li>
  <li>当前的操作是否是来自添加到桌面之后</li>
  <li>当前的操作是否发生在离线状态下</li>
</ul>

<p>通过<code class="highlighter-rouge">beforeinstallprompt</code>事件，可以轻易获取用户对添加到桌面 banner 的反应：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">window.addEventListener(&#39;beforeinstallprompt&#39;, e =&gt; {
    console.log(e.platforms); // e.g., [&quot;web&quot;, &quot;android&quot;, &quot;windows&quot;]
    e.userChoice.then(outcome =&gt; {
        console.log(outcome); // either &quot;installed&quot;, &quot;dismissed&quot;, etc.
    }, handleError);
});</code></pre>
</div>

<p>通过在<code class="highlighter-rouge">manifest.json</code>的<code class="highlighter-rouge">start_url</code>中添加参数，很容易标识出当前的用户访问来自添加后的桌面快捷方式。例如使用<a href="https://support.google.com/analytics/answer/1033863?hl=en">GA Custom campaigns</a>。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-json">// manifest.json

{
    &quot;start_url&quot;: &quot;/?utm_source=homescreen&quot;
}</code></pre>
</div>

<p>判断当前是否处于离线状态，<a href="https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine">navigator.onLine</a>可以实现。但是要注意，返回<code class="highlighter-rouge">true</code>时不代表真的可以访问互联网。</p>

<p>现在我们有了这些统计指标，接下来的问题就是如何保证离线状态下产生的统计数据不丢失。一个很自然的想法是，在 SW 中拦截所有统计请求，离线时将统计数据存储在本地 LocalStorage 或者 IndexedDB 中，上线后再进行数据的同步。</p>

<p>Google 之前针对 GA 开发了 sw-offline-google-analytics 类库实现了这一功能，现在已经移到了 Workbox <a href="https://workboxjs.org/reference-docs/latest/module-workbox-google-analytics.html">相关模块</a>中，可以很方便地使用：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// service-worker.js

importScripts(&#39;path/to/offline-google-analytics-import.js&#39;);
workbox.googleAnalytics.initialize();</code></pre>
</div>

<p>这样离线统计的问题就解决了。以上部分代码以 GA 为例，不过其他统计脚本思路也是一致的。</p>

<h3 id="离线体验">离线体验</h3>

<p>最后说说这个项目在离线用户体验上的亮点。PWA 中的离线用户体验绝不仅仅只是展示离线页面代替浏览器“恐龙”而已。离线时，“我究竟能使用哪些功能？”往往是用户最关心的。让我们来看看 PWA-Directory 在这一点上是怎么做的。</p>

<p><img src="/img/pwa-directory-screenshot.png" alt="离线体验" />
<em>离线体验</em></p>

<p>在离线时，可以弹出 Toast（图中下方红色部分）给予用户提示。要实现这一点并不难，通过监听<code class="highlighter-rouge">online/offline</code>事件就能做到，接下来才是亮点。</p>

<p>前面说过，离线时用户很关心能访问哪些内容，如果能通过样式显式标注就再好不过了。在上图中，我访问过第一个 Tab “New” 下列表中的第一个项目，所以此时离线时，页面中其余部分都被置灰且不可点击，只有缓存过的内容被保留了下来，用户将不再有四处点击遇到同样离线页面的挫败感。</p>

<p>要实现这一点可以从两方面入手，首先从全局样式上，离线时给<code class="highlighter-rouge">body</code>或者具体页面容器加个自定义属性，关心离线功能的组件在这个规则下定义自己的离线样式就行了。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// 监听 offline
window.addEventListener(&#39;offline&#39;, () =&gt; {
    // 给容器加上自定义属性
    document.body.setAttribute(&#39;offline&#39;, &#39;true&#39;);
});</code></pre>
</div>

<p>另外具体到某些特定组件，例如这个项目中的列表项，点击每个 PWA 项目的链接都将进入对应的详情页，首次访问会被加入 runtimeCache，因此只需要在缓存中按链接地址进行查询，就能知道这个列表项是否应该置灰。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// 判断链接是否访问过
isAvailable(href) {
    if (!href || this.window.navigator.onLine) return Promise.resolve(true);
    return caches.match(href)
        .then(response =&gt; response.status === 200)
        .catch(() =&gt; false);
}</code></pre>
</div>

<p>总之，离线用户体验是需要根据实际项目情况进行精心设计的。</p>

<h3 id="总结">总结</h3>

<p>从 PWA 特性尤其是离线缓存来看，对于 SSR 架构的项目，进行 App Shell 的分离是很有必要的。相比 SPA/MPA 的预缓存方案，SSR 需要对后端模板，前端路由进行一些改造。另外，对于 PWA 相关数据的统计和离线同步，可以借鉴应用 Google 的 Workbox 方案。最后，离线用户体验也是需要仔细考量的。</p>

<p>如果感兴趣，可以深入了解一下 PWA-Directory 的<a href="https://github.com/GoogleChromeLabs/gulliver/">代码</a>，同时结合开发者的几篇技术文章：</p>
<ul>
  <li><a href="https://medium.com/dev-channel/pwa-directory-loading-content-faster-in-the-application-shell-e35a485b8f4e">结合 App Shell 优化内容加载速度</a></li>
  <li><a href="https://medium.com/dev-channel/building-a-hybrid-rendered-pwa-c9d645baf158">PWA-Directory 的设计思路</a></li>
</ul>

<p>下面我们将继续研究一个 WordPress 主题项目。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
  <li><a href="https://developers.google.cn/web/fundamentals/architecture/app-shell">App Shell 模型</a></li>
  <li><a href="https://medium.com/dev-channel/pwa-directory-loading-content-faster-in-the-application-shell-e35a485b8f4e">PWA-Directory 关于请求内容片段的优化</a></li>
  <li><a href="https://medium.com/dev-channel/tracking-pwa-events-with-google-analytics-3b50030d8922">基于 GA 的 PWA 指标统计</a></li>
  <li><a href="https://developers.google.com/web/updates/2016/07/offline-google-analytics">GA 离线统计</a></li>
  <li><a href="https://workboxjs.org/overview.html">Workbox</a></li>
  <li><a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook">Offline Cookbook</a></li>
</ul>

    </div>
</article>


<hr>
<!-- 来必力City版安装代码 -->
<div class="container" id="lv-container" data-id="city" data-uid="MTAyMC8zMDQyNy82OTgx">
    <script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
    </script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.post-heading h2').remove('.subheading').remove('#logo');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -1.25em;
            font-size: 1.1em;
        }
    }
</style>

            </div>
        </div>

        


    </body>

</html>
