<!DOCTYPE html><meta charset=utf-8><meta name=viewport content="width=device-widthinitial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=keywords content=coding编程javascriptxiaoiverxiaop><meta name=theme-color content=#eee><title>判断元素是否在视口内 | xiaOp的博客</title><meta property=og:title content=判断元素是否在视口内><meta property=og:locale content=en_US><meta name=description content="在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下： 1 2 3 4 5 6 7 8 9function inViewport( el, h ) { var elH = el.offsetHeight, // 元素高度 scrolled = scrollY(), // 视口顶部距离document顶部的距离 viewed = scrolled + getViewportH(), // 视口底部距离document的距离 elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离 elBottom = elTop + elH, // 元素底部距离document顶部的距离 h = h || 0; // 高度系数 return (elTop + elH * h) &lt;= viewed &amp;&amp; (elBottom) &gt;= scrolled; }"><meta property=og:description content="在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下： 1 2 3 4 5 6 7 8 9function inViewport( el, h ) { var elH = el.offsetHeight, // 元素高度 scrolled = scrollY(), // 视口顶部距离document顶部的距离 viewed = scrolled + getViewportH(), // 视口底部距离document的距离 elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离 elBottom = elTop + elH, // 元素底部距离document顶部的距离 h = h || 0; // 高度系数 return (elTop + elH * h) &lt;= viewed &amp;&amp; (elBottom) &gt;= scrolled; }"><link rel=canonical href=https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html><meta property=og:url content=https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html><meta property=og:site_name content=xiaOp的博客><meta property=og:type content=article><meta property=article:published_time content=2017-08-21T03:21:32+08:00><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"判断元素是否在视口内","datePublished":"2017-08-21T03:21:32+08:00","dateModified":"2017-08-21T03:21:32+08:00","description":"在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下： 1 2 3 4 5 6 7 8 9function inViewport( el, h ) { var elH = el.offsetHeight, // 元素高度 scrolled = scrollY(), // 视口顶部距离document顶部的距离 viewed = scrolled + getViewportH(), // 视口底部距离document的距离 elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离 elBottom = elTop + elH, // 元素底部距离document顶部的距离 h = h || 0; // 高度系数 return (elTop + elH * h) &lt;= viewed &amp;&amp; (elBottom) &gt;= scrolled; }","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html"},"url":"https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html"}</script><title>判断元素是否在视口内</title><link rel="shortcut icon" href=/img/favicon.ico><link rel=canonical href=https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html><link rel=manifest href=/manifest.json><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/style-large.css><link rel=stylesheet href=/css/highlight.css><!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--><script src=/js/jquery.min.js></script><script src=/js/Imager.min.js></script><script src=/js/jquery.scrollzer.min.js></script><script src=/js/jquery.scrolly.min.js></script><script src=/js/skel.min.js></script><script src=/js/skel-layers.min.js></script><script src=/js/init.min.js></script><section id=header class=skel-layers-fixed><header><span class="image avatar"><img src=/img/avatar.jpg alt=""></span><h1 id=logo><a href=/ >xiaOp的博客</a></h1><p>想成为一个有趣的人</header><nav id=nav><ul><li><a href=#intro>主页</a><li><a href=#blog>文章</a><li><a href=#contact>兴趣</a></ul></nav><footer><ul class=icons><li><a href=https://github.com/xiaoiver class="icon fa-github"><span class=label>Github</span></a><li><a href=mailto:pyqiverson@gmail.com class="icon fa-envelope"><span class=label>Email</span></a><li><a href=https://www.douban.com/people/150275082/ class=icon>豆</a><li><a href=https://www.zhihu.com/people/pan-yu-qi-20/activities class=icon>知</a></ul></footer></section><div id=wrapper><div id=main><style>header.intro-header {
        position: relative;
        background-image: url('/img/intersection.png');
        background-size: cover;
    }
    
    header.intro-header .header-mask {
        width: 100%;
        height: 100%;
        position: absolute;
        background: rgba(0,0,0, 0.6);
    }
    

    .post-heading {
        position: relative;
        padding: 50px 0;
        color: white;
    }
    .post-heading h2,
    .post-heading h3,
    .post-heading h4 {
        color: white;
    }
    .post-heading h2 {
        font-size: 3em;
    }

    article {
        padding-top: 20px;
    }

    .post-container img {
        display: block;
        max-width: 100%;
        height: auto;
        margin: 1.5em auto 1.6em auto;
    }
    .post-container a {
        color: #4acaa8;
    }</style><header class=intro-header><div class=header-mask></div><div class=container><div class=post-heading><h2>判断元素是否在视口内<h3 class=subheading>新的API: IntersectionObserver</h3></h2><div class=tags><a class=tag href=/tags#javascript title=javascript>javascript</a></div><span class=meta>Posted by xiaOp的博客 on August 20, 2017</span></div></div></header><article class=post-container><div class=container><p>在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下：<figure class=highlight><pre><code class=language-javascript data-lang=javascript><table style="border-spacing: 0"><tr><td class="gutter gl" style="text-align: right"><pre class=lineno>1
2
3
4
5
6
7
8
9</pre><td class=code><pre><span class=kd>function</span> <span class=nx>inViewport</span><span class=p>(</span> <span class=nx>el</span><span class=p>,</span> <span class=nx>h</span> <span class=p>)</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>elH</span> <span class=o>=</span> <span class=nx>el</span><span class=p>.</span><span class=nx>offsetHeight</span><span class=p>,</span> <span class=c1>// 元素高度</span>
        <span class=nx>scrolled</span> <span class=o>=</span> <span class=nx>scrollY</span><span class=p>(),</span> <span class=c1>// 视口顶部距离document顶部的距离</span>
        <span class=nx>viewed</span> <span class=o>=</span> <span class=nx>scrolled</span> <span class=o>+</span> <span class=nx>getViewportH</span><span class=p>(),</span> <span class=c1>// 视口底部距离document的距离</span>
        <span class=nx>elTop</span> <span class=o>=</span> <span class=nx>el</span><span class=p>.</span><span class=nx>getBoundingClientRect</span><span class=p>().</span><span class=nx>top</span><span class=p>,</span> <span class=c1>// 元素顶部距离document顶部的距离</span>
        <span class=nx>elBottom</span> <span class=o>=</span> <span class=nx>elTop</span> <span class=o>+</span> <span class=nx>elH</span><span class=p>,</span> <span class=c1>// 元素底部距离document顶部的距离</span>
        <span class=nx>h</span> <span class=o>=</span> <span class=nx>h</span> <span class=o>||</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 高度系数</span>
    <span class=k>return</span> <span class=p>(</span><span class=nx>elTop</span> <span class=o>+</span> <span class=nx>elH</span> <span class=o>*</span> <span class=nx>h</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=nx>viewed</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>elBottom</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>scrolled</span><span class=p>;</span>
<span class=p>}</span><span class=w>
</span></pre></table></code></pre></figure><p>这种方法的问题是使用<code class=highlighter-rouge>getBoundingClientRect()</code>读取元素尺寸数据时，会造成 re-layout，在滚动过程中会导致页面卡顿(jank)。<h2 id=intersectionobserver>IntersectionObserver</h2><p><a href=https://wicg.github.io/IntersectionObserver/ >IntersectionObserver</a> 作为新引入的 API，异步查询元素相对于另一个元素（例如视口）的位置，不会影响主线程，可以解决检测方法带来的性能问题。<p>首先我们需要创建一个观察对象，构造函数方法签名如下：<figure class=highlight><pre><code class=language-javascript data-lang=javascript><table style="border-spacing: 0"><tr><td class="gutter gl" style="text-align: right"><pre class=lineno>1</pre><td class=code><pre><span class=k>new</span> <span class=nx>IntersectionObserver</span><span class=p>(</span><span class=nx>entries</span> <span class=o>=&gt;</span> <span class=p>{},</span> <span class=nx>options</span><span class=p>);</span><span class=w>
</span></pre></table></code></pre></figure><p>随后将使用这个观察对象对元素的位置变化进行观测：<figure class=highlight><pre><code class=language-javascript data-lang=javascript><table style="border-spacing: 0"><tr><td class="gutter gl" style="text-align: right"><pre class=lineno>1</pre><td class=code><pre><span class=nx>io</span><span class=p>.</span><span class=nx>observe</span><span class=p>(</span><span class=nx>element</span><span class=p>);</span><span class=w>
</span></pre></table></code></pre></figure><p>观察对象构造函数的第一个参数便是回调函数，这能避免旧方法中轮询带来的性能问题。 在回调函数中，传入的参数是一个数组（可以观测多个元素），每个元素对象包含以下属性：<ul><li><code class=highlighter-rouge>rootBounds</code>，<code class=highlighter-rouge>ClientRect</code>对象，等同于对根元素（默认值为视口）调用<code class=highlighter-rouge>getBoundingClientRect()</code><li><code class=highlighter-rouge>boundingClientRect</code>，<code class=highlighter-rouge>ClientRect</code>对象，等同于对被观测元素调用<code class=highlighter-rouge>getBoundingClientRect()</code><li><code class=highlighter-rouge>intersectionRect</code>，以上两个矩形的交集<li><code class=highlighter-rouge>intersectionRatio</code>，被观测元素被覆盖的比例，如下图所示：</ul><div class=responsive-image><img class=responsive-image__placeholder src=/img/resized/480/intersectratio.png><div class=responsive-image__delayed data-src=/img/resized/{width}/intersectratio.png></div></div><script>new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();
        }
    });</script><p>现在来看看观察对象的第二个参数，这是一个配置对象，其中包含3个重要的配置项：<ol><li><code class=highlighter-rouge>root</code>，默认值为视口，在容器内滚动的场景中，我们可以指定根元素为容器<li><code class=highlighter-rouge>rootMargin</code>，顾名思义，值的格式与<code class=highlighter-rouge>margin</code>一样<li><code class=highlighter-rouge>threshold</code>，这个阈值甚至可以是一个列表，每次达到其中的一个阈值时都会触发回调函数，取值范围为[0-1]</ol><p>最后，相对于<code class=highlighter-rouge>observe()</code>观测方法，自然也有解除观测方法<code class=highlighter-rouge>unobserve()</code>。<p>以上就是这个新 API 的全部内容了，下面让我们看看在实际场景中如何应用吧。<h2 id=懒加载图片>懒加载图片</h2><p>有了这个新的 API，实现滚动到视口内加载图片就十分简单了，其实就是多了新的判断方法，不再需要在滚动事件中获取了。<figure class=highlight><pre><code class=language-javascript data-lang=javascript><table style="border-spacing: 0"><tr><td class="gutter gl" style="text-align: right"><pre class=lineno>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre><td class=code><pre><span class=c1>// 创建观测对象</span>
<span class=kd>let</span> <span class=nx>observer</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>IntersectionObserver</span><span class=p>(</span><span class=nx>entries</span> <span class=o>=&gt;</span> <span class=p>{</span>
    <span class=nx>entries</span><span class=p>.</span><span class=nx>forEach</span><span class=p>(</span><span class=nx>entry</span> <span class=o>=&gt;</span> <span class=p>{</span>
        <span class=c1>// 图片和视口有交集了</span>
        <span class=k>if</span> <span class=p>(</span><span class=nx>entry</span><span class=p>.</span><span class=nx>intersectionRatio</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 停止继续观测，直接加载</span>
            <span class=nx>observer</span><span class=p>.</span><span class=nx>unobserve</span><span class=p>(</span><span class=nx>entry</span><span class=p>.</span><span class=nx>target</span><span class=p>);</span>
            <span class=nx>loadImage</span><span class=p>(</span><span class=nx>entry</span><span class=p>.</span><span class=nx>target</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>});</span>
<span class=p>},</span> <span class=p>{</span><span class=na>threshold</span><span class=p>:</span> <span class=mf>0.01</span><span class=p>});</span>

<span class=c1>// 观测所有图片</span>
<span class=nx>images</span><span class=p>.</span><span class=nx>forEach</span><span class=p>(</span><span class=nx>image</span> <span class=o>=&gt;</span> <span class=p>{</span>
    <span class=nx>observer</span><span class=p>.</span><span class=nx>observe</span><span class=p>(</span><span class=nx>image</span><span class=p>);</span>
<span class=p>});</span><span class=w>
</span></pre></table></code></pre></figure><p>当然，这里还有一些细节，例如：<ol><li>考虑浏览器兼容性，目前<a href="https://caniuse.com/#feat=intersectionobserver">最新版 Chrome 和 Firefox 支持</a>良好。<a href=https://github.com/WICG/IntersectionObserver/tree/gh-pages/polyfill>polyfill</a><li>图片的 src 属性存放在例如 data-src 上<li>全部图片加载完毕，调用观测对象的<code class=highlighter-rouge>disconnect()</code>方法彻底关闭</ol><p>可以参考<a href=https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163>这篇文章</a>的实现。<h2 id=参考资料>参考资料</h2><p><a href=https://developers.google.com/web/updates/2016/04/intersectionobserver>Google Developer</a><p><a href=https://hacks.mozilla.org/2017/08/intersection-observer-comes-to-firefox/ >MDN</a><p><a href=https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163>懒加载图片文章</a></div></article><script>function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }</script><script>async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.post-heading h2').remove('.subheading').remove('#logo');
    })</script><style>/* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -1.25em;
            font-size: 1.1em;
        }
    }</style></div></div>