<!DOCTYPE html>
<html>

    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="keywords" content="coding编程javascriptxiaoiverxiaop">
    <meta name="theme-color" content="#eee">
    <meta name="msapplication-TileColor" content="#eee">
    <meta name="msapplication-TileImage" content="/img/manifest/ms-icon-144x144.png">
    <!-- Begin Jekyll SEO tag v2.2.3 -->
<title>判断元素是否在视口内 | xiaOp的博客</title>
<meta property="og:title" content="判断元素是否在视口内" />
<meta name="author" content="xiaOp" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下： function inViewport( el, h ) { var elH = el.offsetHeight, // 元素高度 scrolled = scrollY(), // 视口顶部距离document顶部的距离 viewed = scrolled + getViewportH(), // 视口底部距离document的距离 elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离 elBottom = elTop + elH, // 元素底部距离document顶部的距离 h = h || 0; // 高度系数 return (elTop + elH * h) &lt;= viewed &amp;&amp; (elBottom) &gt;= scrolled; }" />
<meta property="og:description" content="在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下： function inViewport( el, h ) { var elH = el.offsetHeight, // 元素高度 scrolled = scrollY(), // 视口顶部距离document顶部的距离 viewed = scrolled + getViewportH(), // 视口底部距离document的距离 elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离 elBottom = elTop + elH, // 元素底部距离document顶部的距离 h = h || 0; // 高度系数 return (elTop + elH * h) &lt;= viewed &amp;&amp; (elBottom) &gt;= scrolled; }" />
<link rel="canonical" href="https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html" />
<meta property="og:url" content="https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html" />
<meta property="og:site_name" content="xiaOp的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-21T03:21:32+08:00" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"BlogPosting","headline":"判断元素是否在视口内","author":{"@type":"Person","name":"xiaOp"},"datePublished":"2017-08-21T03:21:32+08:00","dateModified":"2017-08-21T03:21:32+08:00","description":"在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下： function inViewport( el, h ) { var elH = el.offsetHeight, // 元素高度 scrolled = scrollY(), // 视口顶部距离document顶部的距离 viewed = scrolled + getViewportH(), // 视口底部距离document的距离 elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离 elBottom = elTop + elH, // 元素底部距离document顶部的距离 h = h || 0; // 高度系数 return (elTop + elH * h) &lt;= viewed &amp;&amp; (elBottom) &gt;= scrolled; }","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html"},"url":"https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html"}</script>
<!-- End Jekyll SEO tag -->

    <title>判断元素是否在视口内</title>

    <link rel="apple-touch-icon" sizes="57x57" href="/img/manifest/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/img/manifest/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/img/manifest/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/img/manifest/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/img/manifest/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/img/manifest/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/img/manifest/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/img/manifest/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/manifest/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/img/manifest/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/manifest/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/img/manifest/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/manifest/favicon-16x16.png">

    <link rel="shortcut icon" href="/img/manifest/favicon.ico" type="image/x-icon">
    <link rel="canonical" href="https://xiaoiver.github.io/coding/2017/08/20/%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E8%A7%86%E5%8F%A3%E5%86%85.html">
    <link rel="manifest" href="/manifest.json">

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/style-large.css" />
    <link rel="stylesheet" href="/css/prism.css" />
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/Imager.min.js"></script>
    <script src="/js/jquery.scrollzer.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/skel-layers.min.js"></script>
    <script src="/js/prism.min.js"></script>
    <script src="/js/init.min.js"></script>
</head>


    <body>

        <section id="header" class="skel-layers-fixed">
    <header>
        <span class="image avatar"><img src="/img/avatar.jpg" alt="" /></span>
        <h1 id="logo"><a href="/" class="secret">xiaOp's Blog</a></h1>
        <p>想成为一个有趣的人</p>
    </header>
    <nav id="nav">
        <ul>
            <li><a href="#intro">主页</a></li>
            <li><a href="#blog">文章</a></li>
            <li><a href="#contact">兴趣</a></li>
        </ul>
    </nav>
    <footer>
        <ul class="icons">
            <li><a href="https://github.com/xiaoiver" class="icon fa-github"><span class="label">Github</span></a></li>
            <li><a href="mailto:pyqiverson@gmail.com" class="icon fa-envelope"><span class="label">Email</span></a></li>
            <li><a href="https://www.douban.com/people/150275082/" class="icon">豆</a></li>
            <li><a href="https://www.zhihu.com/people/pan-yu-qi-20/activities" class="icon">知</a></li>
        </ul>
    </footer>
</section>


        <div id="wrapper">
            <div id="main">
                <style type="text/css">
    header.intro-header {
        position: relative;
        background-image: url('/img/intersection.png');
        background-size: contain;;
        background-repeat: no-repeat;
        background-position: center center;
    }
    
    header.intro-header .header-mask {
        width: 100%;
        height: 100%;
        position: absolute;
        background: rgba(0,0,0, 0.6);
    }
    

    header.intro-header .icon {
        position: absolute;
        top: 8px;
        right: 8px;
        color: white;
        background: #4acaa8;
        border-radius: 50%;
        height: 2.5em;
        width: 2.5em;
        line-height: 2.5em;
        text-align: center;
    }

    .post-heading {
        position: relative;
        padding: 50px 0;
        color: white;
    }
    .post-heading h2,
    .post-heading h3,
    .post-heading h4 {
        color: white;
    }
    .post-heading h2 {
        font-size: 3em;
    }
    .post-heading .meta {
        transform: translate(0.1em, 0.5em);
    }

    article {
        padding-top: 20px;
    }

    .post-container img {
        display: block;
        max-width: 100%;
        height: auto;
        margin: 1.5em auto 1.6em auto;
    }
    .post-container a {
        color: #4acaa8;
    }
</style>

<header class="intro-header" >
    <div class="header-mask"></div>
    <span class="icon fa-code"></span>
    <div class="container">
        <div class="post-heading">
            <h2>
                判断元素是否在视口内
            </h1>
            <h3 class="subheading">新的API: IntersectionObserver</h2>
            <div class="tags">
                
                <a class="tag" href="/tags#javascript" title="javascript">javascript</a>
                
            </div>
            <span class="meta secret secret-lg">Posted by xiaOp on August 20, 2017</span>
        </div>
    </div>
</header>

<article class="post-container">
    <div class="container">
        <p>在懒加载图片的场景中，常常需要在滚动事件回调函数中检测目标图片是否在视口内，常用的检测方法如下：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">function inViewport( el, h ) {
    var elH = el.offsetHeight, // 元素高度
        scrolled = scrollY(), // 视口顶部距离document顶部的距离
        viewed = scrolled + getViewportH(), // 视口底部距离document的距离
        elTop = el.getBoundingClientRect().top, // 元素顶部距离document顶部的距离
        elBottom = elTop + elH, // 元素底部距离document顶部的距离
        h = h || 0; // 高度系数
    return (elTop + elH * h) &lt;= viewed &amp;&amp; (elBottom) &gt;= scrolled;
}</code></pre>
</div>

<p>这种方法的问题是使用<code class="highlighter-rouge">getBoundingClientRect()</code>读取元素尺寸数据时，会造成 re-layout，在滚动过程中会导致页面卡顿(jank)。</p>

<h2 id="intersectionobserver">IntersectionObserver</h2>

<p><a href="https://wicg.github.io/IntersectionObserver/">IntersectionObserver</a> 作为新引入的 API，异步查询元素相对于另一个元素（例如视口）的位置，不会影响主线程，可以解决检测方法带来的性能问题。</p>

<p>首先我们需要创建一个观察对象，构造函数方法签名如下：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">new IntersectionObserver(entries =&gt; {}, options);</code></pre>
</div>

<p>随后将使用这个观察对象对元素的位置变化进行观测：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">io.observe(element);</code></pre>
</div>

<p>观察对象构造函数的第一个参数便是回调函数，这能避免旧方法中轮询带来的性能问题。
在回调函数中，传入的参数是一个数组（可以观测多个元素），每个元素对象包含以下属性：</p>
<ul>
  <li><code class="highlighter-rouge">rootBounds</code>，<code class="highlighter-rouge">ClientRect</code>对象，等同于对根元素（默认值为视口）调用<code class="highlighter-rouge">getBoundingClientRect()</code></li>
  <li><code class="highlighter-rouge">boundingClientRect</code>，<code class="highlighter-rouge">ClientRect</code>对象，等同于对被观测元素调用<code class="highlighter-rouge">getBoundingClientRect()</code></li>
  <li><code class="highlighter-rouge">intersectionRect</code>，以上两个矩形的交集</li>
  <li><code class="highlighter-rouge">intersectionRatio</code>，被观测元素被覆盖的比例，如下图所示：</li>
</ul>

<p class="responsive-image">
    <img class="responsive-image__placeholder" src="/img/resized/480/intersectratio.png" alt="" />
    <div class="responsive-image__delayed" data-src="/img/resized/{width}/intersectratio.png" data-alt="">
    </div>
    <em></em>
</p>

<script>
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
</script>

<p>现在来看看观察对象的第二个参数，这是一个配置对象，其中包含3个重要的配置项：</p>
<ol>
  <li><code class="highlighter-rouge">root</code>，默认值为视口，在容器内滚动的场景中，我们可以指定根元素为容器</li>
  <li><code class="highlighter-rouge">rootMargin</code>，顾名思义，值的格式与<code class="highlighter-rouge">margin</code>一样</li>
  <li><code class="highlighter-rouge">threshold</code>，这个阈值甚至可以是一个列表，每次达到其中的一个阈值时都会触发回调函数，取值范围为[0-1]</li>
</ol>

<p>最后，相对于<code class="highlighter-rouge">observe()</code>观测方法，自然也有解除观测方法<code class="highlighter-rouge">unobserve()</code>。</p>

<p>以上就是这个新 API 的全部内容了，下面让我们看看在实际场景中如何应用吧。</p>

<h2 id="懒加载图片">懒加载图片</h2>

<p>有了这个新的 API，实现滚动到视口内加载图片就十分简单了，其实就是多了新的判断方法，不再需要在滚动事件中获取了。</p>

<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// 创建观测对象
let observer = new IntersectionObserver(entries =&gt; {
    entries.forEach(entry =&gt; {
        // 图片和视口有交集了
        if (entry.intersectionRatio &gt; 0) {
            // 停止继续观测，直接加载
            observer.unobserve(entry.target);
            loadImage(entry.target);
        }
    });
}, {threshold: 0.01});

// 观测所有图片
images.forEach(image =&gt; {
    observer.observe(image);
});</code></pre>
</div>

<p>当然，这里还有一些细节，例如：</p>
<ol>
  <li>考虑浏览器兼容性，目前<a href="https://caniuse.com/#feat=intersectionobserver">最新版 Chrome 和 Firefox 支持</a>良好。<a href="https://github.com/WICG/IntersectionObserver/tree/gh-pages/polyfill">polyfill</a></li>
  <li>图片的 src 属性存放在例如 data-src 上</li>
  <li>全部图片加载完毕，调用观测对象的<code class="highlighter-rouge">disconnect()</code>方法彻底关闭</li>
</ol>

<p>可以参考<a href="https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163">这篇文章</a>的实现。</p>

<h2 id="多个容器中-sticky-的场景">多个容器中 sticky 的场景</h2>

<p>同样，在 sticky 的场景中，IntersectionObserver 也有很好的应用。</p>

<p>首先来看看过去的方式有哪有限制：</p>
<ul>
  <li>对于开发者而言，通过 CSS 规则<code class="highlighter-rouge">position: sticky</code>将控制行为完全交给浏览器。除了通过手动计算，完全不知道一个元素当前是否处于 sticky 状态，当然这个计算过程，又需要放在滚动事件中重复执行，容易造成 jank。</li>
  <li>当涉及到多个独立容器的场景，计算过程将变得十分复杂。</li>
</ul>

<p><img src="/img/sticky-regions.png" alt="" /></p>

<p>对于开发者的一种理想状态是，能够监听自定义事件<code class="highlighter-rouge">sticky-change</code>，在元素 sticky 状态发生改变之时进行操作，这样就避免了在滚动事件处理函数中不断轮询。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">document.addEventListener(&#39;sticky-change&#39;, e =&gt; {
    const header = e.detail.target;  // header became sticky or stopped sticking.
    const sticking = e.detail.stuck; // true when header is sticky.
    header.classList.toggle(&#39;shadow&#39;, sticking); // add drop shadow when sticking.
});</code></pre>
</div>

<p>首先我们需要为每一个容器建立首尾两个“哨兵” DOM。IO 需要关注它们和视口容器的重合度。</p>

<p><img src="/img/sentinelanimation.gif" alt="" /></p>

<p>这里以头部的“哨兵”为例，每次一进入视口容器就需要开始计算位置信息。尾部哨兵略有不同，只有全部在容器中才需要开始计算。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">const observer = new IntersectionObserver((records, observer) =&gt; {
    for (const record of records) {
        const targetInfo = record.boundingClientRect;
        const stickyTarget = record.target.parentElement.querySelector(&#39;.sticky&#39;);
        const rootBoundsInfo = record.rootBounds;

        // Started sticking.
        if (targetInfo.bottom &lt; rootBoundsInfo.top) {
            fireEvent(true, stickyTarget);
        }

        // Stopped sticking.
        if (targetInfo.bottom &gt;= rootBoundsInfo.top &amp;&amp;
            targetInfo.bottom &lt; rootBoundsInfo.bottom) {
            fireEvent(false, stickyTarget);
        }
    }
}, {threshold: [0], root: container});

// Add the top sentinels to each section and attach an observer.
const sentinels = addSentinels(container, &#39;sticky_sentinel--top&#39;);
sentinels.forEach(el =&gt; observer.observe(el));</code></pre>
</div>

<p>发送自定义事件的代码就省略了。完整代码可参考原文中的<a href="https://ebidel.github.io/demos/sticky-position-event.html">DEMO 地址</a>。</p>

<p>现在我们可以做到监听元素 sticky 状态的变动，由此引申到另一个问题，那就是元素其他 CSS 属性的变动也能够检测么？
<code class="highlighter-rouge">MutationObserver</code>可以监听样式类的增减，但是计算出来的样式规则发生变动则不行。未来<a href="http://xml3d.org/xml3d/specification/styleobserver/"> Style Mutation Observer</a>将作为一个很好的补充。</p>

<h2 id="总结">总结</h2>

<p>IO 在需要计算两个元素重合状态，尤其是视口元素的场景中，可以完全替代滚动事件轮询的方式。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://developers.google.com/web/updates/2016/04/intersectionobserver">Google Developer</a></li>
  <li><a href="https://hacks.mozilla.org/2017/08/intersection-observer-comes-to-firefox/">MDN</a></li>
  <li><a href="https://deanhume.com/Home/BlogPost/lazy-loading-images-using-intersection-observer/10163">懒加载图片原文</a></li>
  <li><a href="https://developers.google.com/web/updates/2017/09/sticky-headers">sticky场景 原文</a></li>
  <li><a href="https://github.com/russellgoldenberg/scrollama">scrollama</a></li>
</ul>

    </div>
</article>


<hr>
<!-- 来必力City版安装代码 -->
<div class="container" id="lv-container" data-id="city" data-uid="MTAyMC8zMDQyNy82OTgx">
    <script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
    </script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.post-heading h2').remove('.subheading').remove('#logo');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -1.25em;
            font-size: 1.1em;
        }
    }
</style>

            </div>
        </div>

        


    </body>

</html>
