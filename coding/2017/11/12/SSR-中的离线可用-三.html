<!DOCTYPE html>
<html>

    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="keywords" content="coding编程javascriptxiaoiverxiaop">
    <meta name="theme-color" content="#eee">
    <meta name="msapplication-TileColor" content="#eee">
    <meta name="msapplication-TileImage" content="/img/manifest/ms-icon-144x144.png">
    <!-- Begin Jekyll SEO tag v2.2.3 -->
<title>SSR 中的离线可用（三） | xiaOp的博客</title>
<meta property="og:title" content="SSR 中的离线可用（三）" />
<meta name="author" content="xiaOp" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。" />
<meta property="og:description" content="本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。" />
<link rel="canonical" href="https://xiaoiver.github.io/coding/2017/11/12/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%89.html" />
<meta property="og:url" content="https://xiaoiver.github.io/coding/2017/11/12/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%89.html" />
<meta property="og:site_name" content="xiaOp的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-13T03:21:32+08:00" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"BlogPosting","headline":"SSR 中的离线可用（三）","author":{"@type":"Person","name":"xiaOp"},"datePublished":"2017-11-13T03:21:32+08:00","dateModified":"2017-11-13T03:21:32+08:00","description":"本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaoiver.github.io/coding/2017/11/12/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%89.html"},"url":"https://xiaoiver.github.io/coding/2017/11/12/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%89.html"}</script>
<!-- End Jekyll SEO tag -->

    <title>SSR 中的离线可用（三）</title>

    <link rel="apple-touch-icon" sizes="57x57" href="/img/manifest/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/img/manifest/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/img/manifest/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/img/manifest/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/img/manifest/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/img/manifest/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/img/manifest/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/img/manifest/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/manifest/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/img/manifest/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/manifest/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/img/manifest/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/manifest/favicon-16x16.png">

    <link rel="shortcut icon" href="/img/manifest/favicon.ico" type="image/x-icon">
    <link rel="canonical" href="https://xiaoiver.github.io/coding/2017/11/12/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%89.html">
    <link rel="manifest" href="/manifest.json">

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/style-large.css" />
    <link rel="stylesheet" href="/css/prism.css" />
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/Imager.min.js"></script>
    <script src="/js/jquery.scrollzer.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/skel-layers.min.js"></script>
    <script src="/js/prism.min.js"></script>
    <script src="/js/init.min.js"></script>
</head>


    <body>

        <section id="header" class="skel-layers-fixed">
    <header>
        <span class="image avatar"><img src="/img/avatar.jpg" alt="" /></span>
        <h1 id="logo"><a href="/" class="secret">xiaOp's Blog</a></h1>
        <p>想成为一个有趣的人</p>
    </header>
    <nav id="nav">
        <ul>
            <li><a href="#intro">主页</a></li>
            <li><a href="#blog">文章</a></li>
            <li><a href="#contact">兴趣</a></li>
        </ul>
    </nav>
    <footer>
        <ul class="icons">
            <li><a href="https://github.com/xiaoiver" class="icon fa-github"><span class="label">Github</span></a></li>
            <li><a href="mailto:pyqiverson@gmail.com" class="icon fa-envelope"><span class="label">Email</span></a></li>
            <li><a href="https://www.douban.com/people/150275082/" class="icon">豆</a></li>
            <li><a href="https://www.zhihu.com/people/pan-yu-qi-20/activities" class="icon">知</a></li>
        </ul>
    </footer>
</section>


        <div id="wrapper">
            <div id="main">
                <style type="text/css">
    header.intro-header {
        position: relative;
        background-image: url('/img/vue-ssr.png');
        background-size: contain;;
        background-repeat: no-repeat;
        background-position: center center;
    }
    
    header.intro-header .header-mask {
        width: 100%;
        height: 100%;
        position: absolute;
        background: rgba(0,0,0, 0.8);
    }
    

    header.intro-header .icon {
        position: absolute;
        top: 8px;
        right: 8px;
        color: white;
        background: #4acaa8;
        border-radius: 50%;
        height: 2.5em;
        width: 2.5em;
        line-height: 2.5em;
        text-align: center;
    }

    .post-heading {
        position: relative;
        padding: 50px 0;
        color: white;
    }
    .post-heading h2,
    .post-heading h3,
    .post-heading h4 {
        color: white;
    }
    .post-heading h2 {
        font-size: 3em;
    }
    .post-heading .meta {
        transform: translate(0.1em, 0.5em);
    }

    article {
        padding-top: 20px;
    }

    .post-container img {
        display: block;
        max-width: 100%;
        height: auto;
        margin: 1.5em auto 1.6em auto;
    }
    .post-container a {
        color: #4acaa8;
    }
</style>

<header class="intro-header" >
    <div class="header-mask"></div>
    <span class="icon fa-code"></span>
    <div class="container">
        <div class="post-heading">
            <h2>
                SSR 中的离线可用（三）
            </h1>
            <h3 class="subheading">实践：Vue + Workbox</h2>
            <div class="tags">
                
                <a class="tag" href="/tags#PWA" title="PWA">PWA</a>
                
                <a class="tag" href="/tags#ServiceWorker" title="ServiceWorker">ServiceWorker</a>
                
                <a class="tag" href="/tags#vue" title="vue">vue</a>
                
                <a class="tag" href="/tags#workbox" title="workbox">workbox</a>
                
            </div>
            <span class="meta secret secret-lg">Posted by xiaOp on November 12, 2017</span>
        </div>
    </div>
</header>

<article class="post-container">
    <div class="container">
        <p>本系列文章将以两个实际项目作为研究对象，探讨离线可用这个 PWA 的重要特性在 SSR 架构中的应用思路，最后结合 Vue SSR 进行实际应用。</p>

<ul>
  <li>本文是第三部分，将使用 Vue SSR 和 Workbox 实践这一思路。</li>
  <li><a href="/coding/2017/10/24/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%B8%80.html">第一部分</a>以 PWA-Directory 为例进行分析。</li>
  <li><a href="/coding/2017/10/28/SSR-%E4%B8%AD%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%8F%AF%E7%94%A8-%E4%BA%8C.html">第二部分</a>研究了一个 WordPress 主题项目。</li>
</ul>

<h3 id="思路回顾">思路回顾</h3>

<p>我们之前参考 PWA-Directory 的实现，提供了一种 SSR 架构下通用的离线缓存思路：</p>
<ol>
  <li>改造后端模板以支持返回完整页面和内容片段( contentOnly )</li>
  <li>服务端增加一条针对 App Shell 的路由规则，返回仅包含 App Shell 的 HTML 页面( shell.html )</li>
  <li>预缓存 App Shell 页面</li>
  <li>Service Worker 拦截所有 HTML 请求，统一返回缓存的 App Shell 页面。同时向服务端请求当前页面需要的内容片段并写入缓存</li>
  <li>前端路由( app.js )向服务端请求内容片段，发现缓存中已存在，将其填充进 App Shell 中，完成前端渲染</li>
</ol>

<p class="responsive-image">
    <img class="responsive-image__placeholder" src="/img/resized/480/pwa-directory-2.png" alt="SW 请求代码片段流程图" />
    <div class="responsive-image__delayed" data-src="/img/resized/{width}/pwa-directory-2.png" data-alt="SW 请求代码片段流程图">
    </div>
    <em>SW 请求代码片段流程图</em>
</p>

<script>
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800, 1400],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
</script>

<p>将这一思路应用到 Vue SSR 项目中时，需要做一些改变，另外有些步骤框架已经解决，也不需要我们再实现。</p>

<h3 id="后端模板和代码片段">后端模板和代码片段</h3>

<p>首先在 Vue 同构项目中，同一套代码在 Node 端和浏览器端都能运行，是没有“后端模板”的概念的，同样对于“内容片段”也是如此。在首屏使用服务端渲染直出 HTML 后，浏览器端进行 Hydrate(混合)，绑定事件使页面真正可响应，除非刷新页面，否则后续的路由切换都将由前端路由器完成。</p>

<p class="responsive-image">
    <img class="responsive-image__placeholder" src="/img/resized/480/vue-ssr.png" alt="Vue SSR" />
    <div class="responsive-image__delayed" data-src="/img/resized/{width}/vue-ssr.png" data-alt="Vue SSR">
    </div>
    <em>Vue SSR</em>
</p>

<script>
    new Imager('.responsive-image__delayed', {
        availableWidths: [480, 800],
        onImagesReplaced: function() {
            $('.responsive-image__placeholder').hide();

        }
    });
</script>

<p>得益于 Webpack 的<a href="https://doc.webpack-china.org/guides/code-splitting/">Code Splitting</a>和 Vue 的异步组件，我们能够实现路由组件的<a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html">按需加载</a>：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// router.js

// 定义切割点
const Home = () =&gt; import(&#39;./Home.vue&#39;);
const router = new VueRouter({
    routes: [
        {
            path: &#39;/home&#39;,
            component: Home // 使用异步组件
        }
    ]
});</code></pre>
</div>

<p>在 Vue SSR 项目中的实际效果就是首屏由服务端渲染，随后当路由切换时，客户端会请求对应的路由组件代码。所以之前思路中的第5步“前端路由向服务端请求内容片段渲染内容”实际上已经完成了，对于开发者并没有额外的工作要做。</p>

<p>当然，在切换路由时才去请求路由组件代码显然并不够好，因为这样需要等待下载并解析完成，路由才能完成切换。常见的做法是将这些 async chunk 放在<code class="highlighter-rouge">&lt;link rel="preload"&gt;</code>中指示浏览器预取。这样当用户切换路由时，对应的组件代码已经在缓存中，不需要再发送请求。实际上 vue-ssr-renderer 在生成最终 HTML 时也是<a href="https://ssr.vuejs.org/zh/build-config.html#manual-asset-injection">这么做的</a>。</p>

<p>由于我们使用了 ServiceWorker，在构建时同样会把这些分割后的路由组件代码加入预缓存列表，在安装阶段会请求并缓存。那么问题来了，同时使用<code class="highlighter-rouge">&lt;link rel="preload"&gt;</code>和 ServiceWorker 时，同样的资源会被<strong>请求两次</strong>吗？</p>

<p>根据 Google 的<a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">Preload, Prefetch And Priorities in Chrome</a>这篇文章，在 Chrome 中存在<a href="https://calendar.perfplanet.com/2016/a-tale-of-four-caches/">四种缓存</a>：HTTP cache、memory cache、Service Worker cache 和 Push cache，而 preload 资源存储在 HTTP cache 中。</p>
<blockquote>
  <p> …the resource won’t be refetched from the network unless it has expired from the HTTP cache or the Service Worker intentionally refetches it.</p>
</blockquote>

<p>所以不用担心，另外文章中也列举了一些会造成重复请求问题的场景，感兴趣可以深入阅读一下。</p>

<h3 id="缓存-app-shell-页面">缓存 App Shell 页面</h3>

<p>已经解决了路由和代码片段的问题，也就是思路中的第1、5步。下面我们来看第2、3步，
即如何获得仅包含 App Shell 的 HTML 页面供 ServiceWorker 缓存。</p>

<p>在使用 vue-router 时，典型的页面模板结构如下：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-html">// App.vue

&lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;app-header&gt;&lt;/app-header&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
        &lt;app-footer&gt;&lt;/app-footer&gt;
        &lt;sidebar&gt;&lt;/sidebar&gt;
        &lt;loading&gt;&lt;/loading&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre>
</div>

<p>这就是一个典型的基于 App Shell 模型的应用，其中<code class="highlighter-rouge">&lt;router-view&gt;</code>作为一个动态组件，会将匹配到的路由组件渲染在这里。很自然的想到，要想获得“仅包含 App Shell 的 HTML 页面”，只要渲染一个模板为空的路由组件就行了：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-html">// AppShell.vue

&lt;template&gt;
// 空的模板
&lt;/template&gt;
&lt;script&gt;
export default {
    metaInfo: {
        title: &#39;MySite&#39;,
        meta: []
    }
};
&lt;/script&gt;</code></pre>
</div>

<p>配置好路由对象，就可通过类似<code class="highlighter-rouge">/appshell</code>这样的路由路径访问了。当然，这个路由用户是不会访问的，随后我们会把<code class="highlighter-rouge">/appshell</code>加入 ServiceWorker 的预缓存列表，让它和其他静态资源一样，在安装阶段被请求并缓存。</p>

<h4 id="使用-workbox-管理预缓存">使用 Workbox 管理预缓存</h4>

<p>这里简单介绍一下 ServiceWorker 的预缓存功能：</p>
<ul>
  <li>在项目构建阶段，写入静态资源列表到 ServiceWorker 代码中，通常以列表形式存在，其中包含了每个资源的版本号</li>
  <li>在 ServiceWorker 安装阶段，通过比较版本号，检查列表中的资源相较缓存中的内容是否发生更新，如果有则重新请求并更新缓存，另外触发自定义的更新事件通知页面，给予用户反馈，引导刷新页面</li>
  <li>在 ServiceWorker 激活阶段，删除旧缓存内容</li>
</ul>

<p>可见要实现这部分功能，在构建阶段的注入，缓存资源的版本控制都需要编写代码实现。这里必须要介绍一下<a href="https://developers.google.com/web/tools/workbox/">Workbox</a>，这是 Google 开发的工具集，能够方便地集成到 Webpack、Gulp 等构建流程中，帮助开发者生成或者注入部分 ServiceWorker 相关代码，实现了很多通用功能供开发者使用。管理预缓存正是其中之一。</p>

<p>以 Webpack 为例，配合 workbox-webpack-plugin，我们只需要定义一行注入点，剩下的只需要通过配置指示插件注入资源列表就行了：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// service-worker.js
importScripts(&#39;/node_modules/workbox-sw/build/workbox-sw.vX.X.X.prod.js&#39;);

const workboxSW = new WorkboxSW();
// 供 workbox-webpack-plugin 使用的注入点
workboxSW.precache([]);</code></pre>
</div>

<p>让我们来看下关键的配置，我们通过<code class="highlighter-rouge">templatedUrls</code>把<code class="highlighter-rouge">/appshell</code>也加入预缓存列表中：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-json">// 传入 workbox-webpack-plugin 的配置
{
    swSrc: &#39;service-worker.js&#39;, // 包含了注入点的 service-worker.js
    swDest: &#39;service-worker.js&#39;, // 目标路径
    globDirectory: &#39;dist&#39;, // 静态资源文件夹
    globPatterns: [ // 匹配合适的静态资源
        &#39;**/*.{html,js,css,eot,svg,ttf,woff}&#39;
    ],
    templatedUrls: [
        &#39;/appshell&#39;: [...] // 依赖的文件列表 or 具体版本字符串
    ],
    dontCacheBustUrlsMatching: /\.\w{8}\./
}</code></pre>
</div>

<p>根据这样的配置，插件会向最终生成的 ServiceWorker 中注入预缓存列表。默认情况下，插件会根据列表中的资源内容生成一个版本号<code class="highlighter-rouge">revision</code>。但是使用 Webpack 构建时，通常都会使用<code class="highlighter-rouge">output.path</code>指定静态资源的文件名格式，例如<code class="highlighter-rouge">[name].[hash:8].js</code>，实际上<code class="highlighter-rouge">[hash]</code>的作用和<code class="highlighter-rouge">revision</code>一样，就没必要让 Workbox 再为这些文件生成版本号了。通过配置中的<code class="highlighter-rouge">dontCacheBustUrlsMatching</code>，我们指示插件把这些文件的文件名作为版本号。至于<code class="highlighter-rouge">/appshell</code>这样的非静态资源的版本号是如何生成的，我们将在最后一节“缓存资源更新问题”中介绍。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// service-worker.js
workboxSW.precache([
  {
    &quot;url&quot;: &quot;/static/css/main.bb31e95c.css&quot;
  },
  {
    &quot;url&quot;: &quot;/static/js/main.dd298875.js&quot;
  },
  //...
  {
    &quot;url&quot;: &quot;/appshell&quot;,
    &quot;revision&quot;: &quot;7a63fa62f1370a8752bd29f4f88b7104&quot;
  }
]);</code></pre>
</div>

<p>在这个预缓存场景中应该能体会到 Workbox 带来的便利，下面我们还会使用到 Workbox 帮助拦截请求。</p>

<h3 id="拦截-html-请求">拦截 HTML 请求</h3>

<p>现在 ServiceWorker 已经能够请求<code class="highlighter-rouge">/appshell</code>并缓存 App Shell 页面了，下面我们需要实现思路中的第4步，即 让 ServiceWorker 拦截 HTML 请求并返回之前已经缓存的 App Shell 页面。</p>

<p>拦截请求作为 ServiceWorker 的重要功能，通过在<code class="highlighter-rouge">fetch</code>事件中判断请求类型，如果是 HTML 类型就读取缓存并返回。我们当然可以自己编写这段逻辑，实际上也不麻烦，但是 Workbox 提供了功能更加强大的 API：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// service-worker.js
workboxSW.router.registerNavigationRoute(&#39;/appshell&#39;);</code></pre>
</div>

<p>这样当 ServiceWorker 安装完成后，每次用户发起 HTML 请求，例如刷新当前页面，都不会到达服务端，而是由 ServiceWorker 返回缓存的 App Shell 页面，然后交给前端代码渲染具体内容。</p>

<h3 id="前端渲染">前端渲染</h3>

<p>在前端渲染时，有一个问题很重要，那就是获取数据。</p>

<p>在通常的 Vue SSR 场景中，由于首屏是服务端渲染的，所需的数据请求自然也是在服务端发送，成功后在渲染时通过向 HTML 模板写入<code class="highlighter-rouge">window.INITIAL_STATE</code>的方式将状态同步给客户端。因此到了客户端进行 Hydrate(客户端混合) 时，不需要重复请求数据，只需要根据当前状态渲染页面组件。要实现这一点，通常在客户端页面入口中，我们会在路由 ready 之后也就是<code class="highlighter-rouge">router.onReady</code>回调中才挂载包含数据请求的钩子，这样只有在后续前端路由切换时才会发送请求。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// entry-client.js
app = new App();
router.onReady(() =&gt; {
    handleAsyncData();
    app.$mount(&#39;#app&#39;);
});</code></pre>
</div>

<p>在通常的 Vue SSR 项目里这样做是没有问题的，而一旦页面请求被 ServiceWorker 拦截，并返回 App Shell 页面，情况就变得不一样了。由于此时整个应用的状态停留在初始状态，数据请求是需要客户端页面入口来发送的。这就要求客户端页面入口需要在运行时知道当前页面是否是 App Shell。</p>

<p>一个很自然的想法是在渲染的 App Shell 页面中加入标记，在 Vue SSR 项目中我们常常使用 Vue-meta 设置页面标题和<code class="highlighter-rouge">meta</code>标签，这里借助它也很容易实现在<code class="highlighter-rouge">body</code>上加上标记属性：</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-html">// AppShell.vue

&lt;template&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    metaInfo: {
        title: &#39;MySite&#39;,
        meta: [],
        bodyAttrs: {
            &#39;appshell&#39;: undefined
        }
    }
};
&lt;/script&gt;</code></pre>
</div>

<p>这样在客户端入口运行时，如果检测到此时页面是服务端直出的（第一次访问站点，此时 ServiceWorker 未安装），就不发送数据请求，而如果发现此时是 ServiceWorker 拦截后返回的，就发送请求。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">// entry-client.js
let usingAppshell = document.body.hasAttribute(&#39;appshell&#39;);
if (usingAppshell) {
    handleAsyncData();
    app = new App().$mount(&#39;#app&#39;);
}
else {
    app = new App();
    router.onReady(() =&gt; {
        handleAsyncData();
        app.$mount(&#39;#app&#39;);
    });
}</code></pre>
</div>

<p>至此，基于 Vue SSR 和 Workbox，我们已经实现了开始的思路，总结一下当前的效果是：</p>
<ul>
  <li>用户首次访问站点，首屏由服务端渲染，后续路由前端跳转。ServiceWorker 开始首次安装。过程中请求预缓存列表中的静态资源和<code class="highlighter-rouge">appshell</code>路由，缓存 App Shell 页面。</li>
  <li>用户后续访问，刷新页面都不会到达服务端，请求被 ServiceWorker 拦截，统一返回之前缓存的 App Shell 页面，由前端渲染具体内容。</li>
</ul>

<p>最后我们来关注一下缓存的更新问题。</p>

<h3 id="缓存资源更新问题">缓存资源更新问题</h3>

<p>我们的站点不可能一成不变，当 ServiceWorker 检测到代码发生更新时，需要引导用户手动刷新当前页面来使用最新的资源。这里不会介绍如何保证 ServiceWorker 本身是最新的，不被缓存，感兴趣的可以阅读<a href="https://zhuanlan.zhihu.com/p/28161855">这篇文章</a>。下面的讨论将基于 ServiceWorker 不被缓存的前提。</p>

<p>由于缓存中的 App Shell 页面包含了对静态资源的引用，这意味着当这些静态资源发生了修改，<code class="highlighter-rouge">/appshell</code>对应的版本号也需要改变，这样 ServiceWorker 才会请求新的 App Shell 并缓存。</p>

<p>这里需要一下介绍<code class="highlighter-rouge">/appshell</code>的版本号是如何生成的。Workbox 提供了<code class="highlighter-rouge">templatedUrls</code>配置项为这类非静态资源生成版本号，接受两类值：</p>
<ul>
  <li>依赖文件的列表。这些文件的内容将共同决定版本号。比如 App Shell 页面中包含了 JS，CSS，我们就需要把这些资源都加进来。在实际应用中，由于生成的静态资源的文件名中有可能包含了<code class="highlighter-rouge">[hash]</code>，所以文件名并不确定。而且一旦漏掉某个资源，它的改动就不会反映在版本号上了。</li>
  <li>直接提供一个版本字符串。例如当我们接受每次构建后，都认为代码发生了更新，都需要 ServiceWorker 重新请求新的 App Shell 页面，就可以使用时间戳。当然这样做的缺点就是即使代码没有改动，也会触发更新。</li>
</ul>
<div>
  <pre class="line-numbers" data-line=""><code class="language-json">// workbox-webpack-plugin 配置对象
{
    // 省略其他配置
    templatedUrls: [
        &#39;/appshell&#39;: [...] // 依赖的文件列表 or 具体版本字符串
    ]
}</code></pre>
</div>

<p>现在我们解决了 App Shell 的更新问题，剩下的就是给予用户视觉反馈，提示手动刷新页面。这里给出一种参考实现，在安装完成，也就是全部资源的预缓存完成之后触发一个自定义事件，在 UI 组件中监听这个事件展现提示信息就行了。</p>
<div>
  <pre class="line-numbers" data-line=""><code class="language-javascript">navigator.serviceWorker.register(&#39;/service-worker.js&#39;).then(function(reg) {
    reg.onupdatefound = function() {
        var installingWorker = reg.installing;
        installingWorker.onstatechange = function() {
            switch (installingWorker.state) {
                case &#39;installed&#39;:
                    if (navigator.serviceWorker.controller) {
                        var event = document.createEvent(&#39;Event&#39;);
                        event.initEvent(&#39;sw.update&#39;, true, true);
                        window.dispatchEvent(event);
                    }
                    break;
            }
        };
    };</code></pre>
</div>

<p>以上就是使用 Vue SSR 和 Workbox 实现离线可用的实践，其他细节可以参考这个简单的<a href="https://github.com/xiaoiver/vue-ssr-pwa-demo">demo</a>。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
  <li><a href="https://calendar.perfplanet.com/2016/a-tale-of-four-caches/">Chrome 中的缓存介绍</a></li>
  <li><a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">Preload, Prefetch And Priorities in Chrome</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/28161855">如何优雅的为 PWA 注册 Service Worker</a></li>
</ul>

    </div>
</article>


<hr>
<!-- 来必力City版安装代码 -->
<div class="container" id="lv-container" data-id="city" data-uid="MTAyMC8zMDQyNy82OTgx">
    <script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
    </script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.post-heading h2').remove('.subheading').remove('#logo');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -1.25em;
            font-size: 1.1em;
        }
    }
</style>

            </div>
        </div>

        


    </body>

</html>
