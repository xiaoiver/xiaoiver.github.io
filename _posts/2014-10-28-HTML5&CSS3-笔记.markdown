---
layout: post
title:  "《HTML5 & CSS3》读书笔记"
date:   2014-10-28 15:44:40
categories: html css
---

# ch1 html5 & css3

## 更好的开发平台

### 向后兼容性

doctype声明告诉验证器和编辑器可以使用什么tag和attribute，以及文档如何构成。另外，很多浏览器根据这个决定如何渲染页面。有效的doctype使浏览器以标准模式渲染页面。

XHTML1.0 Transitional doctype
{% highlight html %}
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
{% endhighlight %}

在HTML5中，变得很简洁
{% highlight html %}
    <!DOCTYPE html>
{% endhighlight %}

### 更多语义标签

描述内容标签，如header，section。属性如`data-`。

### 简化标签

HTML5中默认`<script>`使用js，不需要额外的属性。
{% highlight html %}
    <script language="javascript" type="text/javascript">
{% endhighlight %}

之前明确页面的编码，需要这么写meta标签
{% highlight html %}
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
{% endhighlight %}

HTML5中更简单
{% highlight html %}
    <meta charset="utf-8">
{% endhighlight %}

### 更好的表单

之前日期选择，slider都需要使用js和css才能实现。HTML5中都定义了。

### 高级的选择器

CSS3中有表格行的奇偶选择器，所有选中的多选框。

### 视觉效果

阴影，渐变

### Websocket

与服务器持久的连接。

### 客户端存储

--------------------

# ch2 新的结构化标签和属性

过度使用div，ul本来就是块元素，被两个块元素div包裹。这样div元素就没有意义，移除也不影响效果。过度使用div使结构臃肿，样式难以维护。
{% highlight html %}
<div id="page">
    <div id="navbar_wrapper">
        <div id="navbar">
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/products">Products</a></li>
                ...
            </ul>
        </div>
    </div>
</div>
{% endhighlight %}

## header

和h1之类的标签不一样，可以包含任何内容，如Logo，搜索框。页面也不是只有一个，每个section或者article都可以有一个。所以使用ID选择器比较好。

## footer

和header一样，使用ID选择器比较好。可以包含导航内容。

## nav

可以包含无序列表。

## section

页面中的逻辑区域，替代被滥用的div。

## article

描述实际内容，独立，这是和section的区别。每个article又可以分成更多的section。也可以包含header，footer。

## aside

主要内容之外的额外内容。

## 使IE9之前版本支持新标签

在head中增加条件注释。在浏览器开始渲染页面之前执行。
{% highlight html %}
    <!--[if lte IE 8]>
    <script>
    document.createElement("nav");
    document.createElement("header");
    document.createElement("footer");
    document.createElement("section");
    document.createElement("aside");
    document.createElement("article");
    </script>
    <![endif]-->
{% endhighlight %}

## 使用meter展示进度条

meter标签的value，min，max属性。通过css设置width。
{% highlight html %}
<meter title="USD" id="pledge_goal"
    value="2500.00" min="0" max="5000.00">
</meter>
{% endhighlight %}

不是所有浏览器都支持meter。可以使用jquery模拟。

## progress进度条

展示活动的进度条，用法和meter一样。

不支持的浏览器可以使用[HTML5](http://lea.verou.me/polyfills/progress/)

## 使用data属性创建弹出窗口

onclick的坏处，缺少href属性，用户如果禁用javascript，不会到达任何页面。
{% highlight html %}
<a href='#' onclick="window.open('help/holiday_pay.html',WinName,'width=300,height=300');">
    Holiday pay
</a>

<a href='help/holiday_pay.html' onclick="window.open(this.href,WinName,'width=300,height=300');">
    Holiday pay
</a>
{% endhighlight %}

将宽高数据绑定在元素上
{% highlight html %}
    <a href="help/holiday_pay.html"
        data-width="600"
        data-height="400"
        title="Holiday Pay"
        class="popup">Holiday pay</a>

    $("a.popup").click(function(event){
        event.preventDefault();
        var link = this;
        var href = link.getAttribute("href");
        var height = link.getAttribute("data-height");
        var width = link.getAttribute("data-width");
        window.open (href,"popup",
            "height=" + height +",width=" + width + "");
    });
{% endhighlight %}

IE10以上，还可以通过元素的dataset属性进行读取设置。要转成驼峰形式，和style属性一样。
{% highlight javascript %}
    var height = link.dataset.height;
    var width = link.dataset.width;
{% endhighlight %}

## dl描述列表

使用dl描述列表定义FAQ

之前使用有序列表或者div，但是缺乏语义。我们需要将问题链接到答案。

基本结构：
{% highlight html %}
    <article>
        <h1>AwesomeCo FAQ</h1>
        <dl>
            <dt>What is it that AwesomeCo actually does?</dt>
            <dd>
                <p>
                    AwesomeCo creates innovative solutions for business that
                    leverage growth and promote synergy, resulting in a better
                    life for the global community.
                </p>
            </dd>
        </dl>
    </article>
{% endhighlight %}

# ch3 用户友好的表单

新增的input类型

* range滑动条
* spinbox数字的上下改变按钮，默认大于等于0
* date选择日期。只有chrome和opera支持。
* email进行验证，在手机上虚拟键盘会切换，使输入@更容易
* url
* color选择颜色，显示在按钮上。firefox和chrome支持

## 使用color picker

对于不支持color的浏览器，使用[jQuery-simple-color](http://recursive-design.com/projects/jquery-simple-color/)

检测浏览器是否支持，创建一个input，设置type属性为color。有些浏览器只是部分支持，并不实际显示控件，所以还要进一步判断。给input赋值一个字符串，如果像普通text类型表现，说明不支持。
{% highlight javascript %}
    function hasColorSupport(){
        element = document.createElement("input");
        element.setAttribute("type","color");
        var hasColorType = (element.type === "color");
        if(hasColorType){
            var testString = "foo";
            element.value = testString;
            hasColorType = (element.value != testString);
        }
        return hasColorType;
    }
{% endhighlight %}

如果不支持，就引入插件。其他浏览器绑定onload处理函数。IE中script元素不支持onload，只支持onreadystatechange事件。FF中刚好相反。
{% highlight javascript %}
    var applyColorPicker = function(){
        $('input[type=color]').simpleColor();
    };
    if (!hasColorSupport()){
        var script = document.createElement('script');
        script.src = "javascripts/jquery.simple-color.js";
        if(script.readyState){ // IE support
            script.onreadystatechange = function () {
                if (this.readyState === 'loaded' || this.readyState === 'complete'){
                    script.onreadystatechange = null;
                    applyColorPicker();
                }
            };
        }else{
            // Other browsers
            script.onload = applyColorPicker;
        }
        document.getElementsByTagName("head")[0].appendChild(script);
    }
{% endhighlight %}

## 使用Modernizr检测特性

[Modernizr](http://www.modernizr.com/)检测浏览器对HTML5和CSS3特性的支持。
不会提供缺失的功能，但是会提供检测方法。

检测是否支持`input[type="color"]`
{% highlight javascript %}
    if(Modernizr.inputtypes.color){
        // we have color support
    }else{
        // we don't have color support.
    }
{% endhighlight %}

大多数情况下，检测到缺失时需要加载类库，使用load方法。支持时使用yep属性加载，不支持使用nope加载。callback当外部文件加载完成时调用。
{% highlight javascript %}
    var applyColorPicker = function(){
        $('input[type=color]').simpleColor();
    };
    Modernizr.load(
        {
            test: Modernizr.inputtypes.color,
            nope: "javascripts/jquery.simple-color.js",
            callback: function(url, result){
                if (!result){
                    applyColorPicker();
                }
            }
        }
    );
{% endhighlight %}

需要[yepnope.js](http://yepnopejs.com/)支持

## autofocus

页面加载后将用户鼠标移动到表单中某个控件，过去搜索引擎通过js实现。HTML5提供autofocus属性。出现就代表true。只有一个，多个取最后一个。

如果不支持，使用jquery查找具有autofocus属性的input
{% highlight javascript %}
    if (!Modernizr.autofocus){
        $('input[autofocus]').focus();
    }
{% endhighlight %}

## placeholder

目的和label不同，只是提供参考值

对于不支持的浏览器，使用[jquery-placeholder插件](https://github.com/mathiasbynens/jquery-placeholder)

这里书中有个错误，可能是新版本的Modernizr将placeholder，required等属性放在input中，Modernizr.placeholder返回undefined。
{% highlight javascript %}
    var applyPlaceholders = function(){
        $("input").placeholder();
    }
    Modernizr.load(
        {
            test: Modernizr.input.placeholder,
            nope: "javascripts/jquery.placeholder.js",
            callback: function(url, result){
                if (!result){
                    applyPlaceholders();
                }
            }
        }
    );
{% endhighlight %}

## 不使用js进行表单验证

必填项通过required属性表示，支持此属性的浏览器会阻止表单提交，显示错误信息。

复杂的验证通过正则表达式pattern属性，title属性表示详细的错误信息。但是验证密码和重复输入是否一致无法做到，只能通过js实现。
{% highlight html %}
    <li>
        <label for="password">Password</label>
        <input id="password" type="password" name="password" value=""
            autocomplete="off" placeholder="8-10 characters"
            pattern="^(?=.{8,})(?=.*[a-z])(?=.*[A-Z])(?=.*[\d])(?=.*[\W]).*$"
            title="Password must be 8 or more characters with at
                least one number, an uppercase letter, and one special character" />
    </li>
{% endhighlight %}

-----------------

上面的正则表达式用到了正向先行断言。

断言只匹配位置，不占用字符，所以被称作“零宽”。

先行和后行。之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。

正向就表示匹配括号中的表达式，负向表示不匹配。

-------------------

有的浏览器会在无效的input失去焦点时进行高亮显示，也可以通过valid/invalid伪类定义样式：
{% highlight css %}
    input[required]:invalid, input[pattern]:invalid{
        border-color: #A5340B;
    }
    input[required]:valid, input[pattern]:valid{
        border-color: #0B9900;
    }
{% endhighlight %}

### 不支持的情况

不同于之前的一些类库，[H5F](https://github.com/ryanseddon/H5F)本身会检测浏览器支持程度。仍然使用Modernizr，要注意H5F接受dom元素而非jquery对象作为参数。
{% highlight javascript %}
    var applyPlaceholders = function(){
        $("input").placeholder();
    };
    var configureH5F = function(){
        H5F.setup(document.getElementById("create_account"));
    };
    Modernizr.load([
    {
        test: Modernizr.input.placeholder,
        nope: "js/jquery.placeholder.js",
        callback: function(url, result){
            if(!result){
                applyPlaceholders();
            }
        }
    },
    {
        test: Modernizr.input.pattern && Modernizr.input.required,
        nope: "js/h5f.min.js",
        callback: function(url, result){
            if(!result){
                configureH5F();
            }
        }
    }
    ]);
{% endhighlight %}

## 表单字段的编辑状态切换

不想使用另外的表单让用户编辑信息，原本需要使用隐藏的input，当用户点击text字段时，使用input替换。再通过ajax请求将数据发送到服务端。

HTML5增加了contenteditable属性，虽然可能仍然需要使用ajax传递数据，但是不用切换input的可见状态了。几乎所有元素都有这个属性。

添加悬停和获得焦点时的样式提醒用户当前是可编辑状态：
{% highlight javascript %}
    li > span[contenteditable]:hover{
        background-color: #ffc;
    }
    li > span[contenteditable]:focus{
        background-color: #ffa;
        border: 1px shaded #000;
    }
{% endhighlight %}

修改后在失去焦点时读取数据：
{% highlight javascript %}
    $("span[contenteditable]").blur(function(){
        var field = $(this).attr("id");
        var value = $(this).text();
        //ajax请求发送数据
    });
{% endhighlight %}

### 不支持的情况

检测元素是否有该属性。如果不支持，提供一个普通的编辑表单的链接。
{% highlight javascript %}
    var hasContentEditableSupport = function(){
        return(document.getElementById("edit_profile_link").contentEditable != null)
    };
{% endhighlight %}

# ch4 样式

## 在table中使用伪类选择器

### 使用:nth-of-type定义行斑马纹样式

接受关键字或者公式作为参数。
公式形式为an+b，n从0开始。

CSS3中的关键字odd和even，等价于公式2n+1和2n
{% highlight css %}
    tr:nth-of-type(even){
        background-color: #F3F3F3;
    }
    tr:nth-of-type(odd) {
        background-color:#ddd;
    }
{% endhighlight %}

### 使用:nth-child设置列文本对齐方式

除第一列都右对齐
{% highlight css %}
    td:nth-child(n+2), th:nth-child(n+2){
        text-align: right;
    }
{% endhighlight %}

### 使用:last-child加粗最后一列

移除最后`<p>`的底部外边距。

加粗最后一个td
{% highlight css %}
    td:last-child{
        font-weight: bolder;
    }
{% endhighlight %}

### 使用:nth-last-child从后往前数

倒数第二个tr
{% highlight css %}
    tr:nth-last-child(2){
        color: green;
    }
{% endhighlight %}

最后3个tr
{% highlight css %}
    tr:nth-last-child(-n+3) td{
        text-align: right;
    }
{% endhighlight %}

### IE8以下的版本不支持

在html标记中添加类。混合显示和内容，不是一个好的选择。

使用[Selectivizr](http://selectivizr.com/)，在IE中使用CSS3选择器。
{% highlight html %}
    <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js'>
    </script>
    <!--[if (gte IE 5.5)&(lte IE 8)]>
        <script src="javascripts/selectivizr-min.js"></script>
    <![endif]-->
{% endhighlight %}

## 使用:after让链接可打印

使用单独的打印样式表
{% highlight html %}
    <link rel="stylesheet" href="print.css" type="text/css" media="print">
{% endhighlight %}

使用:after伪元素配合attr取得href属性值。
{% highlight css %}
    a:after {
        content: " (" attr(href) ") ";
    }
{% endhighlight %}

单冒号的伪元素使用方式在CSS2.1中被引入。最新的版本推荐使用两个冒号用来区分伪元素和伪类。但是不是所有浏览器都支持。

## 使用媒体查询

可以决定分辨率，设备的宽高，浏览器窗口的宽高，横版(landscape mode)还是竖版(portrait mode)。

关于handheld媒体类型，本来是被设计针对手持设备的，但是大多数设备忽略它，使用screen媒体类型。

可以在统一的样式表中定义
{% highlight css %}
    @media only screen and (max-device-width: 480px) {
        body{ width:480px; }
        nav, section, header, footer{ margin: 0 10px 0 10px; }
        #sidebar, #posts{
            float: none;
            width: 100%;
        }
    }
{% endhighlight %}

也可以在引入专门针对手持设备的样式表中定义
{% highlight html %}
    <link rel="stylesheet" type="text/css"
    href="stylesheets/mobile.css" media="only screen and (max-device-width: 480px)">
{% endhighlight %}

在firefox的响应式测试工具中进行调试。

IE8以下不支持媒体查询，可以使用[Respond.js](https://github.com/scottjehl/Respond)进行min-/max-的媒体查询。

Bootstrap中在条件注释中使用了该类库对IE8进行支持。

## 多栏布局

报纸的平均分栏效果，便于阅读。缺点是内容很长时，用户需要从底部滚动到顶部阅读新的一行。

分栏数量，栏间距和栏间的边框。需要加上浏览器前缀，但是不要盲目加前缀导致css文件太大。[CanIUse](http://caniuse.com/)帮助了解浏览器支持程度。
{% highlight css %}
    #newsletter{
        column-count: 2;
        column-gap: 20px;
        column-rule: 1px solid #ddccb5;
    }
{% endhighlight %}

### 不支持的情况

[CSS3MultiColumn](https://github.com/BetleyWhitehorne/CSS3MultiColumn)

{% highlight html %}
    <!--[if lte IE 9]>
    <script>
        // support for styling HTML5 elements
        document.createElement("section");
        document.createElement("header");
        document.createElement("footer");
        document.createElement("article");
        document.createElement("aside");
    </script>
    <script src="javascripts/css3-multi-column.min.js"></script>
    <![endif]-->
{% endhighlight %}

# ch6 浏览器绘图

## canvas

书中这里有错误：fill会填充未闭合的路径（从起始点到结束点连线关闭路径），应该使用stroke绘制路径。

translate指定当前坐标系原点的偏移量。在改变坐标系之前使用save保存当前canvas状态，压入栈中。restore恢复到栈顶保存的状态。
{% highlight javascript %}
    context.save();
    context.translate(20,20);
    context.fillRect(0,0,20,20);
{% endhighlight %}

使用渐变颜色
{% highlight javascript %}
    var gradient = context.createLinearGradient(0, 0, 0, 40);
    gradient.addColorStop(0, "#AA0000"); // darker red
    gradient.addColorStop(1, "#FF0000"); // red
    context.fillStyle = gradient;
    context.strokeStyle = gradient;
{% endhighlight %}

### IE9之前的版本

excanvas.js不能支持canvas全部功能。
{% highlight html %}
    <!--[if lte IE 8]>
    <script src="javascripts/excanvas.js"></script>
    <![endif]-->
{% endhighlight %}

{% highlight javascript %}
    var canvas = document.getElementById("logo");
    if (G_vmlCanvasManager != undefined) { // IE 8
        var G_vmlCanvasManager; // so non-IE browsers won't error
        G_vmlCanvasManager.initElement(canvas);
    }
    if (canvas.getContext){
        drawLogo();
    }
{% endhighlight %}

## 使用RGraph绘制统计图

## 使用SVG绘制矢量图

有个问题，不明白为什么要放在`<script>`中，在FF和Chrome中都无法显示。

HTML5之前嵌入SVG有[三种方式](http://www.w3school.com.cn/svg/svg_inhtml.asp)
`<object><embed><iframe>`

HTML5支持内联SVG

d属性表示如何绘制路径。M表示移动，L表示连线，Z表示关闭路径。
{% highlight html %}
    <path id="Triangle"
        d="M20,40 L30,20 L40,40 Z M20,40"
        fill="rgb(255,255,255)"></path>
{% endhighlight %}

### 不支持SVG的浏览器

使用SVGWeb，将svg.js和svg.swf放在同一个文件夹下。支持部分功能，使用flash实现。
{% highlight html %}
    <script src="javascripts/svg.js" data-path="javascripts"></script>
{% endhighlight %}

### HTML5 canvas游戏引擎和SVG库

2D:
* [ImpactJS](http://impactjs.com/)
* [CraftyJS](http://craftyjs.com/)

3D:
[three.js](http://threejs.org/)

SVG:
[Raphaël](http://raphaeljs.com)

# ch7 音频视频

## 历史

embed标签不是标准，而object是。为了让不支持object标签的浏览器也支持，将embed嵌套在object内也是常见的做法。
{% highlight html %}
    <embed src="awesome.mp3" autostart="true"
        loop="true" controller="true"></embed>
    <object>
        <param name="src" value="simpsons.mp3">
        <param name="autoplay" value="false">
        <param name="controller" value="true">
        <embed src="awesome.mp3" autostart="false"
            loop="false" controller="true"></embed>
    </object>
{% endhighlight %}

## 容器和编解码器

3种视频格式：

* H.264 MPEG小组创建，在2003年成为标准。
* Theora
* VP8

3种音频格式：

* AAC
* MP3
* Vorbis(OGG)

容器包装音频视频流。OGG（Theora+Vorbis）
，MP4(H.264+AAC)，WebM(VP8+Vorbis)

## 音频

audio的control属性表示显示控制比如音量。
source的type让浏览器不必问服务器音频格式。
如果第一个source无法播放，就会尝试第二个。
最后提供的链接是为了不支持audio的浏览器。
{% highlight html %}
    <audio id="drums" controls>
        <source src="sounds/ogg/drums.ogg" type="audio/ogg">
        <source src="sounds/mp3/drums.mp3" type="audio/mpeg">
        <a href="sounds/mp3/drums.mp3">Download drums.mp3</a>
    </audio>
{% endhighlight %}

## 视频

不添加autoplay属性告诉浏览器不要自动播放。
preload属性表示浏览器会在后台加载视频。
{% highlight html %}
    <video id="video_blur" preload="auto" controls
        width="640" height="480">
        <source src="video/h264/01_blur.mp4" type='video/mp4'>
        <source src="video/theora/01_blur.ogv" type='video/ogg'>
        <source src="video/webm/01_blur.webm" type='video/webm'>
        <p>Your browser does not support the video tag.</p>
    </video>
{% endhighlight %}

在Apache的.htaccess文件中添加正确的MIME类型
{% highlight html %}
    AddType video/ogg .ogv
    AddType video/mp4 .mp4
    AddType video/webm .webm
{% endhighlight %}

### 不支持的情况

[Video.js](http://www.videojs.com/)为不支持video的浏览器生成flash文件。

{% highlight html %}
    <link href="http://vjs.zencdn.net/4.0/video-js.css" rel="stylesheet">
    <script src="http://vjs.zencdn.net/4.0/video.js"></script>
    <video id="video_blur" preload="auto" controls
        width="640" height="480"
        class="video-js vjs-default-skin"
        data-setup="{}">
{% endhighlight %}

# ch8 视觉效果

## 圆角

{% highlight html %}
    .login input, .login fieldset, .login legend{
        border-radius: 5px;
    }
{% endhighlight %}

### 不支持的情况

IE8不支持，使用[PIE](http://css3pie.com/)

将PIE.htc放在stylesheets文件夹下

使用条件注释
{% highlight html %}
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css" type="text/css" media="screen">
    <![endif]-->
{% endhighlight %}

在ie.css中使用IE专属的behavior规则。为了达到其他浏览器中的效果还需要调整位置。
{% highlight css %}
    .login {margin-top: 20px;}
    .login fieldset legend{
        margin-top: -10px;
        margin-left: 10px;
    }
    .login fieldset{
        padding-left: 10px;
    }
    .login fieldset, .login input, .login legend{
        behavior: url(stylesheets/PIE.htc);
    }
{% endhighlight %}

## gradient

[标准](http://dev.w3.org/csswg/css3-images/#linear-gradients)使用to bottom而不是top
{% highlight css %}
    #badge{
        background-image: -webkit-linear-gradient(top, #fff, #eee);
        background-image: -moz-linear-gradient(top, #fff, #eee);
        background-image: linear-gradient(to bottom, #fff, #eee);
    }
{% endhighlight %}

## shadow

IE10和其他现代浏览器都支持不加浏览器前缀。如果要支持iOS 3，Android 2.1，还是要加。

[box-shadow](http://www.w3.org/TR/css3-background/#the-box-shadow)一共有6个参数
第一个参数是水平偏移，正值代表阴影出现在对象的右侧，负值代表左侧。
第二个参数是垂直偏移，正代表下，负代表上。
第三个参数是模糊的半径，0就是尖锐的效果。
第四个参数是阴影的宽度。
第五个参数是阴影颜色。
最后一个参数是可选的inset，代表阴影出现在内侧。默认是外部阴影。

文本使用text-shadow

## transform

旋转
{% highlight css %}
    -webkit-transform: rotate(-7.5deg);
    -moz-transform: rotate(-7.5deg);
    -ms-transform: rotate(-7.5deg);
    -o-transform: rotate(-7.5deg);
    transform: rotate(-7.5deg);
{% endhighlight %}

可以使用[变换矩阵](http://peterned.home.xs4all.nl/matrices/)精确控制。

## 透明背景

CSS3使用rgb和rgba
{% highlight css %}
    #info{
        background-color: rgba(255,255,255,0.95);
    }
{% endhighlight %}

## font

CSS2引入了@font-face。IE的实现使用Embedded OpenType(EOT)字体格式。如今大多数浏览器支持字体使用TrueType或者OpenType格式。

浏览器会从src中依次尝试。eot格式后加上#iefix是为了解决IE8中的一个bug：IE8尝试解析剩余src时会产生404错误。加上?让IE8认为eot后面都是参数而忽略。
{% highlight css %}
    @font-face {
        font-family: 'GarogierRegular';
        src: url('fonts/garogier_unhinted-webfont.eot?#iefix')
                format('embedded-opentype'),
            url('fonts/garogier_unhinted-webfont.woff') format('woff'),
            url('fonts/garogier_unhinted-webfont.ttf') format('truetype'),
            url('fonts/garogier_unhinted-webfont.svg#garogierregular') format('svg');
        font-weight: normal;
        font-style: normal;
    }
{% endhighlight %}

### 不支持的情况

使用字体堆栈，也就是优先级列表，将首选字体放在最前面。
{% highlight css %}
    font-family: "GarogierRegular", Georgia,
        "Palatino", "Palatino Linotype",
        "Times", "Times New Roman", serif;
{% endhighlight %}

## transition

通过以下属性定义transition：

* transition-property css属性
* transition-duration 持续时间
* transition-delay 开始转变的延时
* transition-timing-function 时间函数

### 理解时间函数

cubic Bézier曲线，通过4个控制点定义。第一个和最后一个通常设置为(0,0)和(1,1)。
中间两个点决定了曲线的形状。

内置的easing函数：linear ease-in ease-out ease-in-out ease

linear曲线将中间的两个控制点放在(0,0)和(1,1)，就是45度的直线。

[曲线的例子](http://www.netzgesta.de/dev/cubic-bezier-timing-function.html)

### 定义transition

{% highlight css %}
    .login input[type="email"], .login input[type="password"]{
        -webkit-transition: background 0.3s linear
                            border 0.3s linear;
        -moz-transition: background 0.3s linear,
                            border 0.3s linear;
        -o-transition: background 0.3s linear,
                            border 0.3s linear;
        transition: background 0.3s linear,
                            border 0.3s linear;
    }
{% endhighlight %}

## animation

定义摇晃动画效果。IE10 FF Chrome支持。Safari需要加前缀。
{% highlight css %}
    @keyframes shake{
        0%{left:0;}
        20%{left:-2%;}
        40%{left:2%;}
        60%{left:-2%;}
        80%{left:2%;}
        100%{left:0;}
    }
{% endhighlight %}

有了keyframes，需要定义animation。最后一个参数代表迭代计数。
{% highlight css %}
    .shake{
        -webkit-animation: shake 0.5s 1;
        -moz-animation: shake 0.5s 1;
        animation: shake 0.5s 1;
    }
{% endhighlight %}

### 实现表单提交错误晃动的效果。

使用promise避免异步回调函数的嵌套。ajax返回promise对象。
{% highlight javascript %}
    var processLogin = function(form, event){
        event.preventDefault();
        var request = $.ajax({
            url: "/login",
            type: "POST",
            data: form.serialize(),
            dataType: "json"
        });
        request.done = function(){
            // Do what you do when the login works.
        };
        return(request);
    };
{% endhighlight %}

定义表单提交事件的处理函数：
{% highlight javascript %}
    var addFormSubmitWithCSSAnimation = function(){
        $(".login").submit(function(event){
            var form = $(this);
            request = processLogin(form, event);
            request.fail(function(){
                form.addClass("shake");
            });
        });
    };
{% endhighlight %}

动画结束需要移除shake类，监听animationend事件：
{% highlight javascript %}
    var addAnimationEndListener = function(){
        $(".login").on
            ("webkitAnimationEnd oanimationend msAnimationEnd animationend",
                function(event){
                    $(this).removeClass("shake");
                });
        };
{% endhighlight %}

### 不支持的情况

#### 支持transition

使用jQuery和[jQuery Color](https://github.com/jquery/jquery-color/)用来实现颜色上的动画效果。
{% highlight javascript %}
    var addTransitionFallbackListeners = function(){
        $(".login input[type=email], .login input[type=password]").focus(function(){
            $(this).animate({
                backgroundColor: "#ffe"
            }, 300 );
        });
        $(".login input[type=email], .login input[type=password]").blur(function(){
            $(this).animate({
                backgroundColor: "#fff"
            }, 300 );
        });
    };
{% endhighlight %}

使用Modernizr检测特性：
{% highlight javascript %}
    Modernizr.load(
        {
            test: Modernizr.csstransitions,
            nope: "javascripts/jquery.color-2.1.2.min.js",
            callback: function(url, result){
                if (!result){
                    addTransitionFallbackListeners();
                }
            }
        }
    );
{% endhighlight %}

#### 支持animation

之前通过添加定义好的shake，现在得通过animate方法实现，其实就是将keyframes定义一遍。
{% highlight javascript %}
    form.animate({left: "-2%"}, 100)
        .animate({left: "2%"}, 100)
        .animate({left: "-2%"}, 100)
        .animate({left: "2%"}, 100)
        .animate({left: "0%"}, 100);
{% endhighlight %}

使用`Modernizr.cssanimations`检测。

# ch9 客户端数据存储

过去只能通过cookies存储键值对加上过期时间。
{% highlight javascript %}
    function SetCookie(cookieName,cookieValue,nDays) {
        var today = new Date();
        var expire = new Date();
        if (nDays==null || nDays==0) nDays=1;
        expire.setTime(today.getTime() + 3600000*24*nDays);
        document.cookie = cookieName+"="+escape(cookieValue)
            + ";expires="+expire.toGMTString();
    }
{% endhighlight %}

## 使用Web Storage存储个人偏好设置

`local/sessionStorage.get/setItem`

localStorage中存储的数据无法共享给服务端或者其他电脑。

## 使用IndexedDB

不同浏览器的实现：
{% highlight javascript %}
    window.indexedDB = window.indexedDB || window.mozIndexedDB ||
                        window.webkitIndexedDB || window.msIndexedDB;
{% endhighlight %}

当版本号改变时，会触发upgradeneeded事件。这样更新客户端的表结构就只要更改版本号了。
{% highlight javascript %}
    var connectToDB = function(){
        var version = 1;
        var request = window.indexedDB.open("awesomenotes", version);
        request.onupgradeneeded = function(event) {
            console.log("unupgradeneeded fired");
            var db = event.target.result;
            db.createObjectStore("notes", { keyPath: "id", autoIncrement: true });
        };
        request.onsuccess = function(event) {
            db = event.target.result;
            fetchNotes();
        };
        request.onerror = function(event){
            console.log(event.debug[1].message);
        }
    };
{% endhighlight %}

查询全部数据，首先配置事务。使用游标查询，触发success事件后，调用result.continue读取下一条记录，然后又会触发success事件。采用事件递归而不是循环。
result的key就是创建对象时定义的keyPath属性也就是id。data是一个对象包含note的title和body。
{% highlight javascript %}
    var fetchNotes = function(){
        var keyRange, request, result, store, transaction;
        transaction = db.transaction(["notes"], "readwrite");
        store = transaction.objectStore("notes");
        // Get everything in the store;
        keyRange = IDBKeyRange.lowerBound(0);
        request = store.openCursor(keyRange);
        request.onsuccess = function(event) {
            result = event.target.result;
            if(result){
                addToNotesList(result.key, result.value);
                result.continue();
            }
        };
        request.onerror = function(event) {
            console.log("Unable to fetch records.");
        };
    };
{% endhighlight %}

使用attr而不是data设置`data-`属性，因为jQuery中data方法在jQuery对象上保存值而不是设置元素的data-属性。
{% highlight javascript %}
    var addToNotesList = function(key, data){
        var item = $("<li>");
        var notes = $("#notes");
        item.attr("data-id", key);
        item.html(data.title);
        notes.append(item);
    };
{% endhighlight %}

可以为每一个li添加click处理函数，但更好的做法是在ul上绑定，通过target取得事件发生的具体地点。
{% highlight javascript %}
    $("#notes").click(function(event){
        var element = $(event.target);
        if (element.is('li')) {
            getNote(element.attr("data-id"));
        }
    });
{% endhighlight %}

使用store.get获取指定id的对象。
{% highlight javascript %}
    var getNote = function(id){
        var request, store, transaction;
        id = parseInt(id);
        transaction = db.transaction(["notes"]);
        store = transaction.objectStore("notes");
        request = store.get(id);
        request.onsuccess = function(event) {
            showNote(request.result);
        };
        request.onerror = function(error){
            console.log("Unable to fetch record " + id);
        };
    }
{% endhighlight %}

### 不支持的情况

IE10+或者Chrome，FF支持IndexedDB。
Safari，安卓浏览器，iOS上的Safari不支持IndexedDB，但是支持Web SQL Database。
IE89全都不支持。

使用[IndexedDBShim](http://nparashuram.com/IndexedDBShim/)让支持WebSQLDatabase的浏览器支持IndexedDB。
{% highlight html %}
    <script src="javascripts/IndexedDBShim.min.js"></script>
{% endhighlight %}

可以使用Modernizr检测，但是IndexedDBShim本身就会检测。

### Web SQL Database

基于SQLite，标准委员会废止。

## 脱机工作

[HTML5’s Offline Web Applications](http://www.w3.org/TR/html5/browsers.html#offline)

IE不支持，暂时没有补救措施。

### 通过Manifest定义缓存

第一次访问网页，所有文件都会被下载。这里在notes.appcache文件中定义：
{% highlight html %}
    CACHE MANIFEST
    # v = 1.0.0
    stylesheets/style.css
    javascripts/notes.js
    javascripts/IndexedDBShim.min.js
    javascripts/jquery-1.9.1.min.js
{% endhighlight %}

通过改变v也就是版本号让浏览器更新。

在html上链接缓存文件。
{% highlight html %}
    <html manifest="notes.appcache">
{% endhighlight %}

一旦所有文件都被缓存了，用户断线，程序还是可以工作。

要注意manifest文件需要使用`text/cache-manifest`MIME类型，否则浏览器不会使用。
在Apache中定义.htaccess文件`AddType text/cache-manifest .appcache`。

### 检测是否在线

使用`navigator.onLine`判断。还可以监听offline和online事件。

# ch10 可交互的Web应用

## 历史记录

### 存储当前的状态

pushState第一个参数是存储的对象，第二个是标示，大多数浏览器都会忽略，所以传入空字符串。第三个是显示在标题栏的url。
{% highlight javascript %}
    var tab = target.attr("href");
    var stateObject = {tab: tab};
    window.history.pushState(stateObject, "", tab);
{% endhighlight %}

### 获取存储的状态

当用户点击回退按钮时，会触发popstate事件。这时就可以将之前存储的对象取出来了。
{% highlight javascript %}
    window.onpopstate = function(event) {
        if(event.state){
            var tab = (event.state["tab"]);
            activateTab(tab);
        }
    };
{% endhighlight %}

### 设置默认的状态

第一次访问页面时，历史状态是空的，需要设置默认的状态。

另外，切换tab页时url也需要随之改变
{% highlight javascript %}
    var activateDefaultTab = function(){
        tab = window.location.hash || "#welcome";
        activateTab(tab);
        window.history.replaceState( {tab: tab}, "", tab);
    };
{% endhighlight %}

### 不支持的情况

[History.js](https://github.com/browserstate/history.js/)

## 跨域

[同源策略](https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript)

Cross-Document Messaging(Web Messaging)支持在不同域的脚本传递消息。

### 发送消息

`postMessage(email, origin);`

### 接收消息

{% highlight javascript %}
    $(window).on("message",function(event){
        $("#to").val(event.originalEvent.data);
    });
{% endhighlight %}

### IE89中的限制

只能传递字符串消息，不能处理对象。而且，消息只能在frames和iframes之间传递。

使用[jQuery PostMessage](http://benalman.com/projects/jquery-postmessage-plugin/)将对象序列化，就可以传递了。

## 使用Web Socket聊天

{% highlight javascript %}
    var setupChat = function(){
        var webSocket = new WebSocket('ws://localhost/');
        webSocket.onopen = function(event){
            $('#chat').append('<br>Connected to the server');
        };
        webSocket.onmessage = function(event){
            $('#chat').append("<br>" + event.data);
            $('#chat').animate({
                scrollTop: $('#chat').height()
            });
        };
        webSocket.onclose = function(event){
            $("#chat").append('<br>Connection closed');
        };
        $("form#chat_form").submit(function(e){
            e.preventDefault();
            var textfield = $("#message");
            webSocket.send(textfield.val());
            textfield.val("");
        });
        $("form#nick_form").submit(function(e){
            e.preventDefault();
            var textfield = $("#nickname");
            webSocket.send("/nick " + textfield.val());
        });
    };
{% endhighlight %}

### 不支持的情况

使用[](http://github.com/gimite/web-socket-js/)

## 使用Drag&Drop实现排序

丢下去的元素排在下面元素的后面。

和之前一样，委托父元素处理。on方法的第二个参数表示过滤器，只有card类触发的dragstart事件才处理。通过originalEvent定位到原始事件。

事件携带的数据存储在dataTransfer对象中，通过setData进行设置，第一个参数是数据类型这里只是文本数据，所以使用text。
{% highlight javascript %}
    cards.on("dragstart", ".card", function(event){
        event.originalEvent.dataTransfer.setData('text', this.id);
    });
{% endhighlight %}

getData只能在drop事件处理函数中使用，为了安全性考虑，其他事件都不能访问存储的数据。
{% highlight javascript %}
    cards.on("drop",".card", function(event){
        event.preventDefault();
        var id = event.originalEvent.dataTransfer.getData('text');
        var originalCard = $("#" + id); 
        originalCard.insertAfter(this);
        return(false);
    });
{% endhighlight %}

书中阻止dragover事件触发，因为浏览器默认阻止将元素丢在另一个元素上。
[Dragover](https://developer.mozilla.org/en-US/docs/Web/Reference/Events/dragover)
但注释掉之后还是可以。

### 不支持的情况

IE8只支持文本，链接和图片的拖拽。使用jQueryUI的sortable方法。

# ch11 实验性的特性

## Flexible Box 模型

让容器`display:flex;`，容器内通过order设置显示顺序，通过flex设置宽度的比例。
这里只有sidebar设置了flex为1，就是20%。
{% highlight javascript %}
    #main{
        width: 80%;
        -webkit-order: 2;
        order: 2;
    }
    #sidebar{
        -webkit-flex: 1;
        flex: 1;
        -webkit-order: 1;
        order: 1;
    }
{% endhighlight %}

### 补救措施

IE10和Safari不支持。使用[Flexie](http://flexiejs.com/)，基于Selectivizr，扫描样式表。

## CORS 跨域资源共享

[更多信息，关于服务端客户端的设置](http://enable-cors.org/)

服务器要配置`Access-Control-Allow-Origin: *`，浏览器发送Origin请求头，服务器会检查是否匹配，否则拒绝请求。